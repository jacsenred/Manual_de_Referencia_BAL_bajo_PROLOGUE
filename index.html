<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BAL ‚Äî Manual de Referencia</title>
  
  <style>
    /* ========================================
       1. VARIABLES Y ESTILOS BASE
       ======================================== */
    :root {
      --bg-body: #f3f4f6;
      --bg-white: #ffffff;
      --text-main: #1f2937;
      --text-muted: #6b7280;
      --border-color: #e5e7eb;
      --primary-color: #2563eb;     /* Azul intenso */
      --primary-hover: #1d4ed8;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    * { box-sizing: border-box; }
    
    /* Fuente de la interfaz (botones, men√∫s) */
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: var(--bg-body);
      color: var(--text-main);
      -webkit-font-smoothing: antialiased;
    }

    /* ========================================
       2. LAYOUT DE LA APLICACI√ìN
       ======================================== */
    .app-header {
      position: sticky;
      top: 0;
      z-index: 50;
      background-color: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(4px);
      border-bottom: 1px solid var(--border-color);
      box-shadow: var(--shadow-sm);
    }

    .app-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    .header-content {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.75rem 0;
    }

    .header-titles h1 { font-size: 1.125rem; font-weight: 600; margin: 0; color: #111827; }
    .header-titles div { font-size: 0.875rem; color: var(--text-muted); }

    .btn-group { display: flex; gap: 0.5rem; flex-wrap: wrap; }

    /* Botones */
    .btn {
      cursor: pointer;
      border-radius: 0.75rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 600;
      border: 1px solid transparent;
      transition: all 0.2s;
      font-family: inherit;
    }

    .btn-primary {
      background-color: var(--primary-color);
      color: white;
      box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
    }
    .btn-primary:hover { background-color: var(--primary-hover); }

    .btn-secondary {
      background-color: white;
      color: #374151;
      border-color: #d1d5db;
    }
    .btn-secondary:hover { background-color: #f9fafb; border-color: #9ca3af; }

    /* Grid Principal */
    .main-grid {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: 1fr;
    }
    @media (min-width: 1024px) {
      .main-grid { grid-template-columns: 1fr 320px; }
    }

    /* Sidebar */
    .sidebar-sticky { position: sticky; top: 5rem; }
    
    .card {
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 1rem;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-sm);
    }
    .card h2, .card h3 { margin-top: 0; font-size: 1rem; font-weight: 600; color: #111827; }
    
    .action-list { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem; }
    .action-list .btn { width: 100%; text-align: left; }

    /* Toast (Notificaciones) */
    #toast {
      display: none;
      border-radius: 1rem;
      padding: 0.75rem;
      font-size: 0.875rem;
      margin-top: 1rem;
      animation: fadeIn 0.3s ease;
      position: fixed;
      bottom: 20px; right: 20px; z-index: 100; max-width: 300px;
    }
    @media (min-width: 1024px) { #toast { position: static; } }

    #toast.show { display: block; }
    .toast-success { background: #ecfdf5; border: 1px solid #a7f3d0; color: #065f46; }
    .toast-error { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    /* ========================================
       3. ESTILOS DEL DOCUMENTO (Clase .doc)
       ======================================== */
    .doc {
      font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
      color: #333333;
      line-height: 1.7;
      font-size: 12pt;
    }

    /* Encabezados */
    .doc h1, .doc h2, .doc h3, .doc h4 {
      font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
      color: #000000;
      line-height: 1.3;
    }

    .doc h1 { font-size: 24pt; font-weight: 700; margin: 0 0 18pt; letter-spacing: -0.02em; }
    .doc h2 { font-size: 17pt; font-weight: 700; margin: 24pt 0 10pt; border-bottom: 2px solid #e5e5e5; padding-bottom: 4pt; }
    .doc h3 { font-size: 14pt; font-weight: 600; margin: 18pt 0 8pt; }
    .doc h4 { font-size: 12.5pt; font-weight: 600; margin: 14pt 0 6pt; }

    /* P√°rrafos */
    .doc p { margin: 0 0 10pt; text-align: justify; }
    .doc hr { border: 0; border-top: 1px solid #d1d5db; margin: 20pt 0; }

    /* Listas y Enlaces */
    .doc ul, .doc ol { margin: 0 0 10pt 24pt; padding: 0; }
    .doc li { margin: 0 0 4pt; }
    .doc a { color: #0056b3; text-decoration: underline; text-underline-offset: 2px; }
    .doc a:hover { color: #003d80; }

    /* C√ìDIGO: Color rojo, */
    .doc code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10.5pt;
      background: #f5f7f9;
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #e1e4e8;
      color: #ff0000;     /* Color de texto resaltado en rojo */
    }

    .doc pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10pt;
      line-height: 1.45;
      background: #f6f8fa;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 12pt;
      margin: 0 0 14pt;
      white-space: pre;   /* Respetar espacios exactos */
      overflow-x: auto;
      color: #111827;     /* Color de texto oscuro neutro */
    }
    .doc pre code { 
        background: transparent; 
        padding: 0; 
        border: none; 
        color: inherit; 
    }

    /* Citas */
    .doc blockquote {
      margin: 12pt 0;
      padding: 8pt 16pt;
      border-left: 4px solid #0056b3;
      background: #f0f7ff;
      border-radius: 0 4px 4px 0;
      font-style: italic;
    }

    /* Tablas (Estilo Pantalla) */
    .doc table { width: 100%; border-collapse: collapse; margin: 0 0 14pt; font-size: 11pt; }
    .doc th, .doc td { border: 1px solid #d1d5db; padding: 8pt 12pt; vertical-align: top; }
    .doc th { background: #f3f4f6; font-weight: 700; text-align: left; }
    .doc tr:nth-child(even) td { background: #fafafa; }

    /* Utilidades */
    .doc .callout { background: #f9fafb; border: 1px solid #e5e7eb; padding: 12pt; border-radius: 6px; margin: 12pt 0; }
    .doc .callout-info { background: #eff6ff; border-color: #bfdbfe; color: #1e3a8a; }
    
    .doc .chapter-placeholder {
      background: #fffbeb;
      border: 2px dashed #fcd34d;
      border-radius: 6px;
      padding: 12pt;
      margin: 12pt 0;
      text-align: center;
      color: #92400e;
      font-weight: 600;
      font-family: sans-serif;
      font-size: 0.9rem;
    }

    /* ========================================
       4. P√ÅGINA VISUAL (Hoja A4 en pantalla)
       ======================================== */
    .page {
      width: 210mm;
      min-height: 297mm;
      padding: 25mm 20mm;
      background: white;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      border: 1px solid #e5e7eb;
      margin: 0 auto;
    }
    @media (max-width: 850px) {
      .page { width: 100%; min-height: auto; padding: 20px; box-shadow: none; }
    }

    /* ========================================
       5. IMPRESI√ìN (L√≥gica de ajuste de tablas)
       ======================================== */
    @media print {
      @page { margin: 2cm; size: A4; }
      
      body { background: white !important; font-size: 11pt; }
      .doc * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
      
      .no-print, header, aside { display: none !important; }

      .app-container, .main-grid, section, article, div {
        display: block !important; width: 100% !important; margin: 0 !important; padding: 0 !important; float: none !important;
      }

      .page {
        margin: 0 !important; padding: 0 !important; border: none !important; box-shadow: none !important; width: 100% !important;
      }

      /* AJUSTE DE TABLAS ANCHAS */
      .doc table {
        width: 100% !important;
        table-layout: fixed;        /* Fuerza a respetar el ancho del papel */
        font-size: 8pt !important;  /* Reduce letra SOLO en tablas */
        word-wrap: break-word;
      }
      .doc th, .doc td {
        padding: 4px !important;    /* Menos relleno para ganar espacio */
        word-break: break-word;     /* Romper palabras largas si es necesario */
        overflow-wrap: break-word;
      }

      /* Saltos de P√°gina */
      .doc h2 { break-before: page; page-break-before: always; margin-top: 0; padding-top: 20pt; }
      .doc h2:first-of-type { break-before: auto; page-break-before: avoid; padding-top: 0; }
      
      .doc pre, .doc table, .doc blockquote { break-inside: avoid; page-break-inside: avoid; border: 1px solid #ccc; }
      .doc a { text-decoration: none; color: black; }
      .doc .chapter-placeholder { display: none; }
    }
  </style>
</head>


<body>

  <!-- CABECERA -->
  <header class="app-header no-print">
    <div class="app-container">
      <div class="header-content">
        <div class="header-titles">
          <div style="font-size: 0.85rem; font-weight: 500; color: #6b7280; margin-bottom: 2px;">Manual de Referencia BAL bajo PROLOGUE</div>
          <h1 style="font-size: 1.25rem;">BAL ‚Äî Edici√≥n Junio 1987 - Versi√≥n 2.1</h1>
        </div>
        <div class="btn-group">
          <button id="copyLibreOffice" class="btn btn-primary">üìã Copiar formato enriquecido</button>
          <button id="copyPlain" class="btn btn-secondary">Texto plano</button>
          <button id="print" class="btn btn-secondary">üñ®Ô∏è Imprimir / PDF</button>
        </div>
      </div>
    </div>
  </header>

  <!-- CONTENIDO -->
  <main class="app-container" style="padding-top: 2rem; padding-bottom: 2rem;">
    <div class="main-grid">

      <!-- DOCUMENTO -->
      <section>
        <div class="page">
          <article id="doc" class="doc">

            <!-- ================== INICIO DEL DOCUMENTO =================== -->
            <h1>BAL</h1>

            <h3>Bajo PROLOGUE</h3>

            <h2>MANUAL DE REFERENCIA DE SOPORTE T√âCNICO</h2>

            <p>Este documento es un √∫til de informaci√≥n y no puede de ninguna manera comprometer la responsabilidad de <b>BULL MICRAL</b> en el caso de que haya modificaciones aportadas por posteriores informaciones.</p>
            <p>Este documento ha sido escrito con EDV bajo PROLOGUE y editado con la ayuda del programa BAL: IMPRIME.</p>
            <hr />

            <h3>Notas</h3>

            <ul>
              <li>Todo lo que est√° entre corchetes es facultativo: <code>[ xx ]</code></li>
              <li>El car√°cter <code>v</code> simboliza la <b>Validaci√≥n</b> (Return o CR o <code>&lt;==</code>)</li>
              <li>Cuando existe alguna ambig√ºedad, los caracteres a pulsar en el teclado aparecen subrayados.</li>
              <li><code>[ xyz ... ]</code> ‚Äî Tres puntos suspensivos despu√©s de un par√°metro, aqu√≠ <code>xyz</code>, significan que este puede ser repetido tantas veces como sea necesario.</li>
              </ul>

            <hr />

            <p><b>Edici√≥n:</b> Junio 1987</p>
            <p><b>Versi√≥n:</b> 2.1</p>
            <p><b>TR:</b> 5.1f</p>
            <hr />

            <h3>SUMARIO</h3>

            <h4>Cap√≠tulo 1: Generalidades PROLOGUE</h4>
            <ul>
              <li>Soporte Volumen SUP</li>
              <li>Fichero FICH</li>
              <li>Carga del sistema</li>
              <li>Definiciones de Comandos</li>
              <li>CPS: Copia de Soporte</li>
              <li>CP: Copia</li>
              <li>/: Cat√°logo</li>
              <li>EDV: Editor de textos</li>
              </ul>

            <h4>Cap√≠tulo 2: Generalidades BAL</h4>
            <ul>
              <li>Estructura Programa Instrucciones</li>
              <li>√ìrdenes de estructuraci√≥n BAL</li>
              <li>Traductor BAL</li>
              <li>Ejecutor-Debug BAL</li>
              </ul>

            <h4>Cap√≠tulo 3: Declaraci√≥n Variables BAL</h4>
            <ul>
              <li>Fuente BAL Multificheros</li>
              <li>Variables y Constantes</li>
              <li>Declaraci√≥n de CONSTantes</li>
              <li>Declaraci√≥n de variables</li>
              </ul>

            <h4>Cap√≠tulo 4: Expresiones - Afectaciones</h4>
            <ul>
              <li>Operadores de c√°lculo</li>
              <li>Operadores de relaci√≥n</li>
              <li>Expresiones de c√°lculo</li>
              <li>Expresiones de relaci√≥n</li>
              <li>√ìrdenes de afectaci√≥n</li>
              </ul>

            <h4>Cap√≠tulos 5 y 6: Las funciones</h4>
            <ul>
              <li>Funciones Encadenadas</li>
              <li>Funciones de Conversi√≥n</li>
              <li>Funciones Matem√°ticas</li>
              <li>Funciones Bibliotecas</li>
              <li>Funciones/Orden opci√≥n PS</li>
              </ul>

            <h4>Cap√≠tulo 7: Las rupturas de secuencias</h4>
            <ul>
              <li>Ramificaciones</li>
              <li>Bucles</li>
              <li>Sub-Programas</li>
              <li>Tratamiento de errores</li>
              </ul>

            <h4>Cap√≠tulo 8: Entrada / Salida Impresora Pantalla/Teclado</h4>
            <ul>
              <li>Salida Pantalla/Impresora</li>
              <li>Formatos</li>
              <li>M√°scaras</li>
              <li>Entradas por teclado</li>
              </ul>

            <h4>Cap√≠tulos 9 y 10: M√©todos de acceso</h4>
            <ul>
              <li>Los Ficheros = M√©todos de acceso</li>
              <li>Acceso Directo</li>
              <li>√ìrdenes Generales</li>
              <li>Acceso Relativo</li>
              <li>Acceso Secuencial</li>
              <li>Acceso Secuencial-indexado</li>
              <li>Acceso Multi-Criterio</li>
              </ul>

            <h4>Anexos</h4>
            <ul>
              <li>Declaraci√≥n SI</li>
              <li>Tiempos de acceso S.I.</li>
              <li>Ejemplo de programa M.C.</li>
              <li>C√°lculo espacio disco/memoria</li>
              <li>Estructura -T, Cat√°logo</li>
              <li>Cable TELE</li>
              <li>C√≥digos ASCII, PROLOGUE</li>
              <li>C√≥digos de Errores</li>
              <li>Palabras Reservadas</li>
              <li>Tabla de √≠ndices</li>
              </ul>

            <hr />

            <h3>ESTRUCTURA DE M√ÅQUINAS 16 Bits</h3>

            <h4>Estructura de un monopuesto 9050</h4>
            <h4>Unidad Central: Procesador</h4>
            <ul>
              <li>Busca, decodifica y ejecuta las instrucciones almacenadas:</li>
              <ul>
                <li>En memoria</li>
                <li>En c√≥digo m√°quina (binario)</li>
                </ul>
              </ul>

            <ul>
              <li>Direcciones: 16 bits (para E/S directas), 20 bits (para memoria)</li>
              <li>Datos: 8/16 bits</li>
              </ul>

            <h4>Entrada/Salida Directas</h4>
            <ul>
              <li>INP / OUT</li>
              </ul>

            <h4>MEMORIA: 1024 K octetos (M√°ximo)</h4>
            <ul>
              <li>1 K Octeto = 1024 Octetos</li>
              <li>1 Octeto = 8 bits</li>
              </ul>

            <p><b>Programas: Instrucciones</b></p>
            <ul>
              <li>Sistema (PROLOGUE)</li>
              <li>Ejecutor</li>
              </ul>

            <p><b>Datos: &lt;= 54 K octetos</b></p>
            <ul>
              <li>Tabla de segmentos</li>
              <li>Tabla de variables</li>
              <li>Segmentos[0], Llamados</li>
              <li>Variables del programa</li>
              </ul>

            <p><b>Entradas/Salidas Memoria</b></p>
            <h4>Perif√©ricos</h4>
            <ul>
              <li><b>Pantalla</b> ‚Äî CO</li>
              <li><b>Teclado</b></li>
              <li><b>Disco:</b></li>
              <ul>
                <li>Disquete 5"1/4 ‚Äî FL</li>
                <li>5"1/4 ‚Äî MD</li>
                <li>8" ‚Äî DS</li>
                <li>Externo 10 Mo ‚Äî WD</li>
                <li>Disquete 8" ‚Äî FS</li>
                <li>Externo 60 Mo ‚Äî GS</li>
                </ul>
              </ul>

            <ul>
              <li><b>Impresora</b> ‚Äî IM, LO</li>
              <li><b>Teletransmisi√≥n:</b></li>
              <ul>
                <li>As√≠ncrona ‚Äî LA</li>
                <li>S√≠ncrona ‚Äî LS</li>
                </ul>
              </ul>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 1: Generalidades PROLOGUE</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <ul>
              <li>Soporte Volumen SUP</li>
              <li>Ficheros FICH</li>
              <li>Carga del Sistema</li>
              <li>Definici√≥n de Comandos</li>
              <li>Los utilitarios PROLOGUE</li>
              <ul>
                <li>CPS - Copia de Soporte</li>
                <li>CP - Copia</li>
                <li>/ - Cat√°logo</li>
                <li>EDV - Editor de textos</li>
                </ul>
              </ul>

            <hr />

            <h3>Soporte Volumen: SUP</h3>

            <h4>Definici√≥n</h4>
            <p>Un soporte es un objeto que permite almacenar la informaci√≥n, por ejemplo: un disco magn√©tico, una impresora, una pantalla, etc.</p>
            <p>Un volumen es un soporte sobre el cual es factible la operaci√≥n de "creaci√≥n de volumen".</p>
            <p>En todo este manual el mnem√≥nico <code>SUP</code> o <code>Sup</code> designar√° el nombre de un soporte o de un volumen.</p>
            <h4>Composici√≥n del nombre de soporte</h4>
            <p>El nombre de un soporte est√° compuesto:</p>
            <ul>
              <li>Del mnem√≥nico del soporte de DOS caracteres</li>
              <li>Eventualmente, del n√∫mero de unidad con una cifra (0 a 7 M√°ximo)</li>
              <li>Eventualmente de un punto</li>
              </ul>

            <p>As√≠: <code>Sup = Mnemo[cifra][.]</code></p>
            <p>En una m√°quina S.P.R. para direccionar un soporte del Ordenador Central (Coordinador), se reemplaza la segunda letra del mnem√≥nico por la letra X.</p>
            <h4>Nombres de Soportes</h4>
            <ul>
              <li><code>FL</code> - Disco flexible (Floppy 5")</li>
              <li><code>FS</code> - Disco flexible (Floppy 8")</li>
              <li><code>MD</code> - Mini Disco 5"</li>
              <li><code>DS</code> - Disco Duro 8"</li>
              <li><code>WD</code> - Disco externo DSS 5320 10 M.o.</li>
              <li><code>SD</code> - Disco externo DSS 5370 57 M.o.</li>
              <li><code>GS</code> - Disco externo D160 60 M.o.</li>
              <li><code>IM</code> - Impresora como gesti√≥n de fichero</li>
              <li><code>.X</code> - Soporte Central de un S.P.R. (el 2¬∫ car√°cter es una X en general)</li>
              <li><code>IS</code> - Impl√≠cito Sistema (Carga)</li>
              <li><code>IP</code> - Impl√≠cito Programas utilitarios</li>
              <li><code>IF</code> - Impl√≠cito Ficheros utilizadores</li>
              <li><code>CO</code> - Pantalla</li>
              <li><code>LO</code> - Impresora</li>
              </ul>

            <h4>Ejemplos</h4>
            <ul>
              <li><code>FL1</code> - Disco flexible unidad 1</li>
              <li><code>DX0</code> - Disco duro de 10 Mega-Oct unidad 0 del central de un S.P.R.</li>
              </ul>

            <hr />

            <h3>Fichero: FICH</h3>

            <h4>Definici√≥n</h4>
            <p>Un fichero es una colecci√≥n de informaciones almacenadas en un volumen. Debe estar √≠ntegramente contenido en un solo volumen. El tama√±o m√°ximo de un fichero es de 16 Mega-Octetos.</p>
            <p>En todo este manual el mnem√≥nico <code>Fich</code> o <code>FICH</code> designar√° el identificador de fichero.</p>
            <h4>Composici√≥n del identificador de fichero</h4>
            <p><b>Sintaxis:</b> <code>Fich = [[Sup].]Nomfich[-T][:CLAVES]</code></p>
            <h4>Componentes:</h4>
            <ul>
              <li><b>Sup</b> - Nombre del soporte (opcional)</li>
              <ul>
                <li>Por defecto: soporte impl√≠cito programa si Fich es el primer nombre despu√©s de <code>-&gt;</code></li>
                <li>Si no, el soporte impl√≠cito fichero (FL1 en est√°ndar para m√°quinas de discos flexibles)</li>
                </ul>
              </ul>

            <ul>
              <li><b>.</b> - Punto (obligatorio si Sup est√° presente)</li>
              <li><b>Nomfich</b> - Nombre de fichero: 7 u 8 letras/cifras/<code>/</code>/<code>$</code> (may√∫sculas y min√∫sculas indiferentes)</li>
              <li><b>-T</b> - Tipo: un gui√≥n seguido de 1 a 3 letras/<code>/</code>/<code>$</code>/blancos</li>
              <ul>
                <li>Por defecto: tipo previsible a priori (ej: -S para fuente)</li>
                <li>Si no, el tipo blanco</li>
                </ul>
              </ul>

            <ul>
              <li><b>:CLAVES</b> - Claves de acceso: dos puntos seguidos de 1 a 4 caracteres</li>
              <ul>
                <li>Los dos primeros: clave de protecci√≥n en lectura</li>
                <li>Los dos √∫ltimos: clave de protecci√≥n en escritura</li>
                <li>Por defecto: blancos</li>
                </ul>
              </ul>

            <h4>Ejemplos</h4>
            <ul>
              <li><code>CP</code></li>
              <li><code>FL1.PROGrama</code></li>
              <li><code>GESTION-S</code></li>
              <li><code>FL1.CLIENTE-S:LEEC</code></li>
              </ul>

            <hr />

            <h3>Fichero: Fich* (con asterisco)</h3>

            <h4>Definici√≥n</h4>
            <p>La sintaxis <code>Fich*</code> (identificador de fichero con asterisco) permite:</p>
            <h4>Uso del asterisco en el nombre:</h4>
            <ul>
              <li><b>Asterisco al principio:</b> <code>*CLIENTE</code> - designa todos los ficheros cuyo nombre termina por CLIENTE</li>
              <li><b>Asterisco al final:</b> <code>STOCK*</code> - designa todos los ficheros cuyo nombre comienza por STOCK</li>
              </ul>

            <h4>Uso del asterisco en el tipo:</h4>
            <ul>
              <li><code>-*</code> - designa todos los ficheros sea cual sea su tipo</li>
              </ul>

            <h4>Ejemplos</h4>
            <ul>
              <li><code>STOCK<i>-</i></code> - todos los ficheros cuyo nombre comience por STOCK, sea cual sea su tipo</li>
              <li><code><i>CLIENTE-</i></code> - todos los ficheros cuyo nombre termine en CLIENTE, sea cual sea su tipo</li>
              <li><code>*-S</code> - todos los ficheros de tipo -S (Fuentes)</li>
              </ul>

            <hr />

            <h3>Carga del Sistema 16 Bits 90-20 y/o 90-50</h3>

            <h4>Puesta en tensi√≥n</h4>
            <ul>
              <li>Poner el rotador de la pantalla en la posici√≥n deseada seg√∫n la nacionalidad</li>
              <li>Poner en tensi√≥n la unidad Central, y los perif√©ricos</li>
              <li>Poner el disco o el disquete sistema en su unidad, en la izquierda a priori</li>
              <li>Activar la impresora y la(s) unidad(es) de disco(s)</li>
              </ul>

            <h4>Carga del sistema</h4>
            <p>Despu√©s de la puesta en tensi√≥n el mensaje <code>MICRAL..</code> aparece en pantalla.</p>
            <p>Si vuestro sistema es de disquetes dar a la tecla de validaci√≥n (ENTER/Valid./CR). El sistema que se encuentra en el sector 100 hexadecimal de la unidad cero (normalmente la izquierda), se carga en memoria.</p>
            <h4>Sintaxis de carga:</h4>
            <pre><code>MICRAL..[ B:[ u, sect ]]v    (Disco flexible)
MICRAL..[ W:[ u, sect ]]v    (Mini-Disco 5", excepto externos y 5+5 Mo)
MICRAL..T:[ Fich ]v          (Telecarga en S.P.R.)</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>u</code> - Unidad de carga</li>
              <li><code>sect</code> - Sector de carga en Hexadecimal</li>
              <li><code>B</code> - Disco flexible</li>
              <li><code>W</code> - Mini-Disco 5"</li>
              <li><code>T</code> - Telecarga en S.P.R.</li>
              <li><code>Fich</code> - Identificador de fichero a telecargar (IP.//TSRnn-X por defecto)</li>
              <li><code>v</code> - Validaci√≥n/CR/INTRO/ENTER</li>
              </ul>

            <h4>Proceso de carga</h4>
            <p>El sistema se carga en principio del espacio memoria, despu√©s de cargar:</p>
            <ul>
              <li>La "Presentaci√≥n" es editada, e indica los n√∫meros de versi√≥n de PROLOGUE y de su entorno</li>
              <li>Las extensiones del sistema se cargan al final del espacio memoria</li>
              <li>Eventualmente un comando inicial es ejecutado, seg√∫n los par√°metros de inicializaci√≥n (CF90..)</li>
              <li>El sistema pasa a esperar la entrada de comandos despu√©s de editar una flecha <code>-&gt;</code> (prompt)</li>
              </ul>

            <p>Cada vez que un puesto de trabajo vuelve a este estado, esperando la entrada de un comando, todos los ficheros abiertos por este puesto de trabajo son cerrados autom√°ticamente.</p>
            <hr />

            <h3>Definiciones de Comandos</h3>

            <h4>Definici√≥n de Comando</h4>
            <p>Un Comando es:</p>
            <ul>
              <li>Una orden dada al sistema de explotaci√≥n. Ejemplo: <code>-&gt; /v</code> (Editar el nombre de los ficheros de la unidad impl√≠cita)</li>
              <li>O un comentario, entonces comienza por un punto y coma. Ejemplo: <code>-&gt; ; Esto es un comentario v</code></li>
              </ul>

            <h4>Composici√≥n de un Comando</h4>
            <ul>
              <li><b>FICH</b> - Identificador del fichero (por defecto tipo X Objeto, cargado de unidad impl√≠cita)</li>
              <li><b>v</b> - Validaci√≥n o coma (si valida, el fichero se carga en memoria)</li>
              <li><b>v</b> - Segunda validaci√≥n opcional (muestra n√∫mero de versi√≥n)</li>
              <li><b>P1[,P2...]</b> - Lista de par√°metros de ejecuci√≥n separados por comas</li>
              <li><b>v</b> - Validaci√≥n final</li>
              </ul>

            <p>La longitud m√°xima de un comando es de 72 caracteres.</p>
            <h4>Sintaxis</h4>
            <pre><code>-&gt; Fich[,P1[,P2...]]v      Ejecuci√≥n normal
-&gt; Fichv,P1[,P2...]v       Precarga
-&gt; Fich[v,]v               N√∫mero de versi√≥n</code></pre>

            <h4>Tipos de Comando</h4>
            <h4>Comando SIN PRECARGA:</h4>
            <pre><code>-&gt;FICH[,P1[,P2...]]v</code></pre>

            <h4>Comando CON PRECARGA:</h4>
            <pre><code>-&gt;FICHv[,P1[,P2...]]v</code></pre>

            <h4>Comando para conocer el n√∫mero de versi√≥n:</h4>
            <pre><code>-&gt;FICH,vv</code></pre>

            <h4>Ejemplos</h4>
            <ul>
              <li><code>-&gt; /,FL0v</code></li>
              <li><code>-&gt; CP,v</code></li>
              </ul>

            <hr />

            <h3>Utilitarios PROLOGUE</h3>

            <h4>CPS - Copia F√≠sica de Soportes</h4>
            <h4>Definici√≥n</h4>
            <p>Este utilitario permite hacer copias (dobles exactos) de soportes con id√©ntico n√∫mero de sectores por pista.</p>
            <h4>Sintaxis - Duplicaci√≥n de soporte:</h4>
            <pre><code>-&gt;[Sup.]CPS,Sup1,Sup2[,NBPIS=pp][,PM]v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Sup.</code> - Cargar CPS de este soporte (por defecto IP)</li>
              <li><code>Sup1</code> - Soporte de Entrada (a Leer)</li>
              <li><code>Sup2</code> - Soporte de Salida (a Escribir)</li>
              <li><code>NBPIS=pp</code> - N√∫mero de pistas a copiar (todas por defecto)</li>
              <li><code>PM</code> - Premarcar el soporte</li>
              </ul>

            <h4>Sintaxis - Copia en formato libre:</h4>
            <pre><code>-&gt; [Sup.]CPS,v

Versi√≥n: 2.3a

Origen     :[Sup1]v Pista :[PP]v Sector  :SSv No.Pistas :[NP]v No.Sect.:NSv
Destino    : Sup2v Pista :[PP]v Sector  : SSv   ( O/N ) : Ov</code></pre>

            <p>Notas:</p>
            <ul>
              <li>Dando ESC en Sup1, el utilitario vuelve a PROLOGUE</li>
              <li>Los valores num√©ricos pueden darse en decimal o hexadecimal (seguido de H)</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>-&gt; CPS,FL0,FL1,PMv</code></pre>

            <p>Copiar el disquete de la unidad 0 sobre el de la unidad 1, con premarcaje. Un Soporte Nuevo debe ser siempre premarcado antes o durante su primera utilizaci√≥n.</p>
            <hr />

            <h4>CP - Manipulaci√≥n de ficheros y vol√∫menes</h4>
            <p>Este utilitario permite:</p>
            <ul>
              <li><b>CV</b> - Crear un Volumen</li>
              <li><b>RV</b> - Renombrar un Volumen</li>
              <li><b>DV</b> - Duplicar un Volumen</li>
              <li><b>CF</b> - Crear un Fichero</li>
              <li><b>RF</b> - Renombrar un Fichero</li>
              <li><b>DF</b> - Duplicar un Fichero</li>
              <li><b>SF</b> - Suprimir un Fichero</li>
              </ul>

            <h4>CP,CV - Crear un Volumen</h4>
            <p>Antes de usar un soporte magn√©tico como Volumen bajo PROLOGUE, es preciso efectuar una creaci√≥n de volumen. Durante esta operaci√≥n se atribuye un nombre al volumen, se define el n√∫mero de ficheros que se van a poder crear, se puede premarcar (formatear) el volumen, y se define la longitud de un "gr√°nulo".</p>
            <p>La dimensi√≥n de un gr√°nulo es el m√°s peque√±o espacio de disco que el sistema puede atribuir a un fichero. Se expresa en sectores y es siempre una potencia entera de 2: 1, 2, 4, 8, 16, 32, 64, 128 o 256. El n√∫mero m√°ximo de gr√°nulos es de 8176.</p>
            <pre><code>-&gt;[Sup.]CP,CV,Sup,NomVolum[,LGR=2**N][,NBFIC=nf][,PM]v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Sup</code> - Soporte conteniendo el Volumen a crear</li>
              <li><code>NomVolum</code> - Nombre del volumen (1 a 8 caracteres)</li>
              <li><code>LGR=2**N</code> - Dimensi√≥n de un gr√°nulo (potencia de 2, &lt;=256, defecto=16)</li>
              <li><code>NBFIC=nf</code> - N√∫mero de ficheros a crear (&lt;=895, defecto=63, f√≥rmula: 31+N*32)</li>
              <li><code>PM</code> - Premarcar</li>
              </ul>

            <p><b>Ejemplo:</b> <code>-&gt; CP,CV,FL1,TRABAJO,PMv</code></p>
            <h4>CP,RV - Renombrar un Volumen</h4>
            <p>Cambia el nombre de un volumen. Si el volumen ha sido obtenido de una copia f√≠sica con cambio de volumen (CPS con opci√≥n SD y/o SDP), un di√°logo propone la actualizaci√≥n del n√∫mero de gr√°nulos gestionados.</p>
            <pre><code>-&gt; [Sup.]CP,RV,NomVolumv</code></pre>

            <p><b>Ejemplo:</b> <code>-&gt; CP,RV,FL1,MARA1v</code></p>
            <h4>CP,DV - Duplicar un Volumen</h4>
            <p>Copiar todos los ficheros del soporte Sup1 sobre el soporte Sup2. La copia se hace por gr√°nulo. Si el volumen Sup2 est√° lleno, la copia no termina, el fichero en curso es destruido y un di√°logo permite proseguir despu√©s de cambiar el volumen.</p>
            <pre><code>-&gt; [Sup.]CP,DV,Sup1,Sup2[,RZ]v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Sup1</code> - Soporte de Entrada (Lectura)</li>
              <li><code>Sup2</code> - Soporte de Salida (Escritura)</li>
              <li><code>RZ</code> - Con supresi√≥n previa de ficheros de Sup2</li>
              </ul>

            <p><b>Ejemplo:</b> <code>-&gt; CP,DV,FL0,FL1v</code></p>
            <h4>CP,CF - Crear un Fichero</h4>
            <p>Crear un fichero de tipo relativo sin atribuirle espacio en disco. Los ficheros de programas ser√°n creados con un editor de textos (EDV). Los ficheros de datos ser√°n creados por programas. Esta opci√≥n es utilizada raramente.</p>
            <pre><code>-&gt; [Sup.]CP,CF,FICHv</code></pre>

            <p><b>Ejemplo:</b> <code>-&gt; CP,CF,ds0.TITIv</code></p>
            <h4>CP,RF - Renombrar un Fichero</h4>
            <p>Cambia el nombre de un Fichero, y/o su tipo y/o sus claves de acceso. No se puede cambiar el nombre de un fichero abierto por otro puesto de trabajo.</p>
            <pre><code>-&gt; [Sup.]CP,RF,Fich1,Fich2v</code></pre>

            <p>Nota: Fich1 y Fich2 tienen que estar en el mismo soporte.</p>
            <p><b>Ejemplo:</b> <code>-&gt; CP,RF,TITI-S,TATA-Sv</code></p>
            <h4>CP,DF - Duplicar uno o m√°s ficheros</h4>
            <p>Duplica uno o varios (Fich*) ficheros de un soporte sobre otro soporte, o sobre el mismo soporte cambiando el nombre y/o el tipo. La copia se hace por gr√°nulos.</p>
            <pre><code>-&gt; [Sup.]CP,DF,Fich1[*][,[DEST=]Sup/Fich2]v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Fich1[*]</code> - Nombre de ficheros a copiar</li>
              <li><code>Sup</code> o <code>Fich2</code> - Soporte o Fichero destino (Fich2 es creado si no exist√≠a)</li>
              <li>Por defecto (sin Sup ni Fich2): copia sobre pantalla sin codificaci√≥n</li>
              </ul>

            <p><b>Ejemplo:</b> <code>-&gt; CP,DF,FL1.STOCK*-S,DS0v</code></p>
            <h4>CP,SF - Suprimir uno o m√°s ficheros</h4>
            <p>Suprime uno o varios (Fich<i>) ficheros de un soporte. Despu√©s de la supresi√≥n el nombre del fichero ya no existe, el espacio utilizado est√° libre. Si se usa Fich</i>, el utilitario pide confirmaci√≥n despu√©s de mostrar la lista.</p>
            <pre><code>-&gt; [Sup.]CP,SF,Fich[*]v</code></pre>

            <p><b>Ejemplo:</b> <code>-&gt; CP,SF,FL1.STOCK*-Sv</code></p>
            <hr />

            <h4>/ - Edici√≥n del Cat√°logo</h4>
            <h4>Definici√≥n</h4>
            <p>Cuando un volumen ha sido creado en un soporte, se puede pedir la edici√≥n del cat√°logo de este volumen, para conocer:</p>
            <ul>
              <li>Las caracter√≠sticas del volumen (Nombre, N√∫mero de ficheros M√°ximo/Real, tama√±o de gr√°nulos, N√∫mero de gr√°nulos M√°ximo/Real)</li>
              <li>Los nombres de ficheros y su tipo</li>
              <li>Opcionalmente, la implantaci√≥n f√≠sica de los ficheros (GR)</li>
              </ul>

            <h4>Sintaxis - Cat√°logo de volumen:</h4>
            <pre><code>-&gt; [Sup.]/[,Sup][,LIS=LO][,GR]v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Sup.</code> - Cargar / de este soporte (por defecto IP)</li>
              <li><code>Sup</code> - Editar el cat√°logo de este soporte (por defecto IF)</li>
              <li><code>LIS=LO</code> - Editar por impresora (por defecto pantalla)</li>
              <li><code>GR</code> - Editar la implantaci√≥n de ficheros (n√∫mero y rango de gr√°nulos)</li>
              </ul>

            <h4>Sintaxis - Cat√°logo de Fichero:</h4>
            <pre><code>-&gt; [Sup.]/[,Fich[*]][,LIS=LO][,GR]v</code></pre>

            <h4>Ejemplos:</h4>
            <ul>
              <li><code>-&gt; /v</code> - Editar el cat√°logo de la unidad fichero utilizador (IF)</li>
              <li><code>-&gt; /,LIS=LOv</code> - Editar por impresora</li>
              </ul>

            <hr />

            <h4>EDV - Editor de Textos</h4>
            <h4>Definici√≥n</h4>
            <p>El editor de textos EDV permite crear y/o modificar ficheros fuentes. Este editor tiene las mismas funciones que Word-Master, pero con sensibles mejoras.</p>
            <h4>Sintaxis:</h4>
            <pre><code>-&gt; [Sup.]EDV,Fich-S[:Claves]v</code></pre>

            <p>Notas:</p>
            <ul>
              <li>Es necesario precisar el tipo <code>-S</code> en la creaci√≥n (si no, se toma tipo blanco por defecto)</li>
              <li>Dos ficheros temporales son creados: tipo <code>-$</code> (modificaciones) y tipo <code>-#</code> (movimientos)</li>
              <li>La nueva versi√≥n estar√° en fichero de nombre Fich</li>
              <li>La antigua versi√≥n estar√° en fichero de tipo <code>-A</code></li>
              </ul>

            <h4>Ejemplos:</h4>
            <ul>
              <li>Crear un fichero fuente: <code>-&gt; EDV,PEPE-Sv</code></li>
              <li>Modificar un fichero fuente: <code>-&gt; EDV,PEPEv</code></li>
              </ul>

            <h4>Modos de trabajo</h4>
            <p><b>Modo VISU</b> (modo de partida):</p>
            <p>El texto es escrito en pantalla, pero no los comandos. Los comandos se representan con <code>^X</code> (Control + tecla X simult√°neamente). La tecla ESCape permite pasar a modo comando.</p>
            <p><b>Modo COMANDO:</b></p>
            <p>El texto no es escrito, pero los comandos se pueden usar. Para volver al modo VISU: teclear ESCape.</p>
            <p>Comandos principales del modo COMANDO:</p>
            <ul>
              <li><code>Ev</code> - Terminar con las puestas al d√≠a (SALVAR)</li>
              <li><code>Qv</code> o <code>Ov</code> - Abandonar las modificaciones</li>
              <li><code>Hv</code> - Salvar y volver al principio del texto en modo VISU</li>
              <li><code>Vv</code> - Volver al modo VISU</li>
              <li><code>YFich</code> - Inserci√≥n de otro fichero</li>
              <li><code>B</code> - Posicionamiento en principio de texto</li>
              <li><code>-B</code> - Posicionamiento en fin de texto</li>
              </ul>

            <h4>Comandos del Modo VISU</h4>
            <p><b>1. Desplazamientos del cursor por el texto:</b></p>
            <ul>
              <li><code>^E</code> o Flecha arriba - hacia la l√≠nea superior</li>
              <li><code>^X</code> o Flecha abajo - hacia la l√≠nea inferior</li>
              <li><code>^D</code> o Flecha derecha - hacia el car√°cter siguiente</li>
              <li><code>^S</code> o Flecha izquierda - hacia el car√°cter precedente</li>
              <li><code>^F</code> - hacia principio de palabra siguiente</li>
              <li><code>^A</code> - hacia principio de palabra precedente</li>
              <li><code>^B</code> - a principio o fin de l√≠nea (alternativamente)</li>
              </ul>

            <p><b>2. Desplazamientos del cursor Y del texto:</b></p>
            <ul>
              <li><code>^Z</code> - una l√≠nea arriba</li>
              <li><code>^W</code> - una l√≠nea abajo</li>
              <li><code>^L</code> - al centro de la pantalla</li>
              <li><code>^C</code> - pantalla siguiente</li>
              <li><code>^R</code> - pantalla precedente</li>
              </ul>

            <p><b>3. Borrado desde la posici√≥n del cursor:</b></p>
            <ul>
              <li><code>Rub out</code> o <code>Del</code> - del car√°cter precedente</li>
              <li><code>^G</code> - del car√°cter en cursor</li>
              <li><code>^\</code> o <code>Home</code> - del fin de palabra a la izquierda</li>
              <li><code>^T</code> - del fin de palabra a la derecha</li>
              <li><code>^U</code> - del principio de la l√≠nea izquierda</li>
              <li><code>^K</code> - del principio de la l√≠nea derecha</li>
              <li><code>^Y</code> - de la l√≠nea completa</li>
              </ul>

            <p><b>4. Diversos:</b></p>
            <ul>
              <li><code>^N</code> - Insertar una l√≠nea vac√≠a</li>
              <li><code>^O</code> - Inserci√≥n de texto (Principio/Fin alterno)</li>
              <li><code>^P</code> - Inserci√≥n de un c√≥digo Hexadecimal</li>
              <li><code>^J</code> o Line Feed - Visualizaci√≥n de instrucciones (alterno)</li>
              <li><code>ESCape</code> - pasar a modo COMANDO</li>
              </ul>

            <h4>Comandos de Memoria de Texto</h4>
            <p>Los comandos "Memoria" se activan a partir de la posici√≥n del cursor:</p>
            <ul>
              <li><code>nQP</code> - Transferir n instrucciones a memoria despu√©s de borrado</li>
              <li><code>n/QP</code> - Transferir n instrucciones a memoria (a continuaci√≥n)</li>
              <li><code>fQG</code> - Recopiar f veces el contenido de la memoria en el texto</li>
              <li><code>QT</code> - Visualizar el contenido de la memoria</li>
              <li><code>QK</code> - Borrar el contenido de la memoria</li>
              </ul>

            <h4>Operaciones sobre Cadenas</h4>
            <pre><code>[ + ] [ p ] [ N ] Cadena1 [ ESCape Cadena2 ]
[ - ] [ # ] [ F ]
            [ R ]
            [ S ]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>+</code> - hacia el fin de texto (por defecto)</li>
              <li><code>-</code> - hacia el principio de fichero</li>
              <li><code>p</code> - rango de la cadena (1 por defecto)</li>
              <li><code>#</code> - rango de la cadena = 65535</li>
              <li><code>N</code> - b√∫squeda en todo el fichero</li>
              <li><code>F</code> - b√∫squeda en memoria</li>
              <li><code>R</code> - reemplaza en todo el fichero</li>
              <li><code>S</code> - reemplaza en memoria</li>
              </ul>

            <p>Para buscar una cadena en principio de l√≠nea, comenzar la cadena por <code>^N</code>.</p>
            <h4>Ejemplo de Creaci√≥n de programa:</h4>
            <pre><code>-&gt; EDV,PEPE-Sv
PROGRAM "PEPE"v
DCL Xv
SEGMENT 0v
X=10.4v
PRINT=1:X,tabv(1)v
STOPv
ESEG 0v
ENDv
"Esc"               ; Pasar a Modo COMANDO
Ev                  ; Fin de modificaciones y vuelta a PROLOGUE
-&gt;</code></pre>

            <h4>Ejemplo de Modificaci√≥n de programa:</h4>
            <pre><code>-&gt; EDV,PEPEv
            X=10.4
            X=12v
"ESCape"            ; Pasar a Modo COMANDO
Ev                  ; Vuelta a PROLOGUE</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 2: Generalidades BAL</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <ul>
              <li>Estructura de un programa BAL</li>
              <li>Identificador IDENT</li>
              <li>Traducci√≥n condicional: <code>#DEF</code>, <code>#UNDEF</code>, <code>#RDEF</code>, <code>#IFDEF</code>, <code>#ELSE</code>, <code>#ENDIF</code></li>
              <li>Estructura de una instrucci√≥n BAL: <code>*</code>, <code>;</code></li>
              <li>Presentaci√≥n de la lista: <code>.</code>, <code>&lt;</code>, <code>&gt;</code>, <code>/</code></li>
              <li>Instrucciones no ejecutables</li>
              <li>Comentarios: <code>;</code>, <code>*</code>, <code>REM</code>, <code>/</code></li>
              <li>√ìrdenes de estructuraci√≥n BAL</li>
              <li><code>PROGRAM</code>, <code>MSIZE=</code>, <code>NOCLR</code></li>
              <li><code>END</code></li>
              <li><code>SEGMENT</code>, <code>NOLIST</code></li>
              <li><code>ESEG</code></li>
              <li>Utilitarios BAL</li>
              <li><code>TR</code> Traductor: <code>TP</code>, <code>NL</code>, <code>ND</code>, <code>LIS=LO</code></li>
              <li><code>EX</code> Ejecutor: par√°metros, <code>DB</code>, <code>CLR</code></li>
              <li><code>EX</code> Ejecutor - Debugger</li>
              </ul>

            <hr />

            <h3>Estructura de un programa BAL</h3>

            <h4>Definici√≥n</h4>
            <p>Un programa BAL est√° contenido en uno (o varios) fichero(s) de tipo <code>-S</code> (fuente).</p>
            <p>Es creado y puesto a punto con un editor de textos (<code>EDV</code> o <code>WM</code> o <code>ED</code>).</p>
            <h4>Sintaxis</h4>
            <pre><code>PROGRAM "Nombre Programa"         ; Principio de Programa

Declaraci√≥n obligatoria de todas las variables (FIELD= y DCL).
Declaraci√≥n e inicializaci√≥n de constantes     (CONST).
Declaraci√≥n de un comando inicial, par√°metros de Ejecuci√≥n (ARG).

SEGMENT 0       ; Principio del Programa PRINCIPAL

Instrucciones

ESEG 0          ; Fin del Programa PRINCIPAL

[ SEGMENT c     ; Otros segmentos opcionalmente. 1 &lt;= c &lt;= 254
                ; Un segmento es un sub-programa residente en el disco.

Instrucciones

ESEG c          ; Fin del Segmento c ]

END             ; Fin del PROGRAMA BAL</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>PROGRAM "ejemplo"
FIELD=M         ; Declaraci√≥n obligatoria de todas las variables que
                ; ser√°n comunes a todos los segmentos.
                ; FIELD= Define el soporte, aqu√≠ la memoria.
DCL NOMBRE$     ; DCL Declara Una Variable
                ; DCL NomVar Tipo[= Longitud][ ( Dim1 [,Dim2] ) ]
                ; Aqu√≠ la variable NOMBRE es una cadena de 15 octetos.
                ; Siempre 15 caracteres en ASCII a priori.
DCL IND#        ; La variable IND es num√©rica corta de un octeto.
                ; Es un n√∫mero entero comprendido entre -128 y +127
DCL CANT%       ; La variable CANT es num√©rica corta de 2 octetos.
                ; Es un n√∫mero entero comprendido entre -32768 y +32767
DCL PRECIO      ; La variable PRECIO num√©rica larga de 8 octetos.
                ; Tiene 14 cifras, un signo y un punto decimal (BCD).
SEGMENT 0
NOMBRE="PEDRO"
CANT=10
PRECIO=8.75
PRINT=1:NOMBRE,CANT,PRECIO,TABV(1)
STOP
ESEG 0
END</code></pre>

            <hr />

            <h3>Identificador: IDENT</h3>

            <p>Un identificador permite designar zonas de memoria por un nombre.</p>
            <h4>Estructura de un identificador</h4>
            <p>Un identificador est√° compuesto:</p>
            <ul>
              <li>De 1 a 8 caracteres alfanum√©ricos (A-Z, 0-9) significativos</li>
              <li>La longitud m√°xima es de 255 caracteres</li>
              <li>Las letras min√∫sculas son equivalentes a las may√∫sculas</li>
              <li>El primer car√°cter es una letra (A a Z)</li>
              </ul>

            <p><b>Nota:</b> Un identificador no debe ser una palabra clave de BAL, <code>GOTO</code> por ejemplo.</p>
            <h4>Utilizaci√≥n de identificadores</h4>
            <p>Un identificador puede designar:</p>
            <h4>Una variable</h4>
            <p>En este caso <code>A</code> y <code>A0</code> son los mismos nombres de variables.</p>
            <h4>Una constante</h4>
            <p>La longitud de una cadena est√° limitada a 80 caracteres.</p>
            <h4>Una condici√≥n de traducci√≥n</h4>
            <ul>
              <li>No tiene valor asociado</li>
              <li>Es definido o indefinido</li>
              <li>Un m√°ximo de 5 identificadores de condici√≥n pueden ser definidos simult√°neamente</li>
              </ul>

            <h4>Una etiqueta de instrucci√≥n</h4>
            <ul>
              <li>Utilizado como un n√∫mero de instrucci√≥n</li>
              <li>Siempre es precedido de un <code>&amp;</code>: ej. <code>&amp;CABECERA</code></li>
              <li>Hay un m√°ximo de 256 identificadores de etiquetas en un mismo segmento</li>
              <li>Un identificador de instrucci√≥n puede ser el mismo nombre que el nombre de una variable o constante</li>
              </ul>

            <hr />

            <h3>Traducci√≥n condicional</h3>

            <h4>Definici√≥n</h4>
            <p>La traducci√≥n condicional permite parametrar las aplicaciones donde no haya m√°s que un solo programa fuente y generar varios programas traducidos diferentes.</p>
            <ul>
              <li>Si el identificador <code>ident</code> est√° definido entonces el <code>Bloc1</code> es traducido y el <code>Bloc2</code> no.</li>
              <li>Si <code>ident</code> es indefinido entonces solo el <code>Bloc2</code> es traducido.</li>
              <li>Solo el bloque traducido ser√° operativo.</li>
              </ul>

            <p><b>Restricciones:</b></p>
            <ul>
              <li>Est√° prohibido encajonar las condiciones de traducci√≥n</li>
              <li>Se puede cambiar la definici√≥n (definido o no definido) de un identificador de condici√≥n, incluso en un bloque traducido bajo condici√≥n</li>
              </ul>

            <p><b>Nota:</b> <code>ident</code> es un nombre donde solo los 8 primeros caracteres son significativos. En un instante dado, un m√°ximo de 5 identificadores de condici√≥n pueden ser definidos.</p>
            <h4>Sintaxis de definici√≥n de condiciones</h4>
            <p>Hay 2 modos de definir los identificadores de condici√≥n. Por defecto un identificador de condici√≥n es indefinido.</p>
            <h4>Modo directo</h4>
            <pre><code>#DEF      ident         [ ; Comentario ]    : "ident" es definido

#UNDEF    ident         [ ; Comentario ]    : "ident" es Indefinido</code></pre>

            <h4>Modo interactivo</h4>
            <pre><code>#RDEF     ident         [ ; Comentario ]</code></pre>

            <p>En este caso de traducci√≥n el mensaje siguiente ser√° presentado en pantalla:</p>
            <pre><code>Definir   ident    ( O/N )  ?  _</code></pre>

            <p>Y seg√∫n la respuesta del operador <code>ident</code> ser√° definido o indefinido.</p>
            <h4>Sintaxis de la traducci√≥n condicional</h4>
            <pre><code>#IFDEF    ident         [ ; Comentario ]

        Bloc 1

#ELSE                   [ ; Comentario ]

        Bloc 2

#ENDIF                  [ ; Comentario ]</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>PROGRAM "TR Condicionado"

#RDEF   pepe
#IFDEF  pepe

dcl ZONA$=15    ; si pepe es definido la longitud de la zona es 15

#ELSE

dcl ZONA$=100   ; si pepe es indefinido entonces la longitud es 100

#ENDIF

.

segment 0
.

eseg 0
end</code></pre>

            <hr />

            <h3>Estructura de una instrucci√≥n BAL</h3>

            <h4>Definici√≥n</h4>
            <p>El texto del programa puede ser escrito en may√∫sculas o min√∫sculas. Para el ejecutor son id√©nticos, salvo que aparezcan en una cadena constante de caracteres.</p>
            <p>Los nombres de ficheros son sistem√°ticamente presentados en letras may√∫sculas por el sistema de ficheros.</p>
            <p>Todas las instrucciones pueden ir seguidas de un punto y coma y de un comentario.</p>
            <h4>Etiquetas de instrucciones</h4>
            <p>Las etiquetas de instrucciones son facultativas; pueden ser puestas en cualquier orden.</p>
            <p>Una etiqueta es:</p>
            <ul>
              <li>Un n√∫mero comprendido entre 1 y 9999, o bien</li>
              <li>Un identificador (un nombre de 1 a 8 caracteres) siempre precedido del car√°cter <code>&amp;</code> (Ej: <code>&amp;CABECERA</code>)</li>
              </ul>

            <p><b>Restricciones:</b></p>
            <ul>
              <li>En un mismo segmento no puede haber m√°s de 256 identificadores de instrucciones diferentes unos de otros</li>
              <li>Sus nombres son independientes de los nombres de variables y constantes</li>
              <li>Las etiquetas son activas solo en el segmento donde han sido declaradas</li>
              <li>La longitud de una instrucci√≥n es de 255 caracteres</li>
              </ul>

            <h4>Reglas de sintaxis</h4>
            <ul>
              <li>El car√°cter igual <code>=</code>, seguido de una palabra clave, es siempre parte integrante de la palabra clave y no puede nunca ser precedido de espacio</li>
              <li>Las variables, las constantes y los caracteres <code>,</code>, <code>(</code>, <code>)</code> y los espacios pueden ser seguidos o precedidos de tantos espacios como se quiera</li>
              </ul>

            <h4>Composici√≥n de una instrucci√≥n BAL</h4>
            <p>Una instrucci√≥n BAL est√° compuesta:</p>
            <ul>
              <li>Opcionalmente de una etiqueta, seguida de un espacio</li>
              <li>De una orden BAL (opcionalmente)</li>
              <li>Eventualmente de un punto y coma <code>;</code> despu√©s un comentario</li>
              <li>De una validaci√≥n (<code>VALID</code>/<code>CR</code>/<code>ENTER</code>/<code>&lt;==</code>)</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>[ etiqueta espacio ][ Orden ] [ ; Comentario ] v
    |                  |             |          |---&gt; Validaci√≥n
    |                  |             |
    |                  |             '-----&gt; Comentario
    |                  |
    |                  '--&gt; Orden general o:
    |                        *   Asterisco = Comentario
    |                        .   Salto de p√°gina en la edici√≥n del programa
    |                        &gt;   Reanuda la edici√≥n del programa
    |                        &lt;   Suspende la edici√≥n del programa
    |                        /   Editar este comentario en la l√≠nea
    |                            de pantalla siguiente
    |
    '----------&gt; Etiqueta de instrucci√≥n facultativa
                    1 a 9999 o &amp;CABECERA (n√∫mero o &amp;identificador)</code></pre>

            <hr />

            <h3>Presentaci√≥n del programa</h3>

            <p>Se puede actuar en la presentaci√≥n de salida de la traducci√≥n.</p>
            <h4>Salto de p√°gina</h4>
            <p>Un punto como orden provoca un salto de p√°gina.</p>
            <h4>No editar toda la lista</h4>
            <p>Se puede pedir que a partir de una orden:</p>
            <ul>
              <li>Las instrucciones no sean listadas, poniendo un car√°cter <code>&gt;</code></li>
              <li>Las instrucciones sean de nuevo listadas, poniendo un car√°cter <code>&lt;</code></li>
              </ul>

            <p>Es decir: <code>&lt; principio de lista, luego fin de lista &gt;</code></p>
            <p>Se puede tambi√©n poner la opci√≥n <code>NOLIST</code> en un segmento completo (ver <code>SEGMENT</code>).</p>
            <h4>Comentarios editados siempre en pantalla</h4>
            <p>Se puede imponer la edici√≥n de un comentario en pantalla sean cuales sean las condiciones de traducci√≥n, poniendo antes del comentario un slash <code>/</code>.</p>
            <h4>Ejemplo</h4>
            <pre><code>1000  CANT=10        ; la CANTidad es igual a 10
      if N1 &lt;&gt; N2 goto &amp;CABECERA
      &gt;      fin de la edici√≥n
      * Comentario
      /  Esto ser√° siempre editado
&amp;CABECERA
      &lt;      reanudar la edici√≥n</code></pre>

            <hr />

            <h3>Instrucciones No Ejecutables</h3>

            <h4>Definici√≥n</h4>
            <p>Las instrucciones siguientes no son ejecutables, incluso no pueden ser ramificadas:</p>
            <ul>
              <li><code>PROGRAM "  "</code></li>
              <li><code>FIELD=</code></li>
              <li><code>DCL</code></li>
              <li><code>SEGMENT</code></li>
              <li><code>INCLUDE "Fich"</code> - Incluye un fichero fuente en la traducci√≥n</li>
              <li><code>FMT</code> - Formato</li>
              <li><code>END</code></li>
              </ul>

            <hr />

            <h3>Comentarios</h3>

            <h4>Definici√≥n</h4>
            <p>Todos los caracteres v√°lidos pueden ser puestos como comentarios.</p>
            <p>Un comentario puede aparecer:</p>
            <ul>
              <li>Al fin de una instrucci√≥n, despu√©s de un punto y coma <code>;</code></li>
              <li>Al comienzo de instrucci√≥n precedido de un asterisco <code>*</code> o punto y coma <code>;</code></li>
              <li>Despu√©s de un slash <code>/</code>, comentario que ser√° siempre editado en pantalla</li>
              <li>Despu√©s de la orden <code>REM</code></li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>REM  comentario</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>*       Comentario
***     Aqu√≠ est√° el c√°lculo
;
REM     del precio total
*
100  PRECIO=CANT * ( PRECIOUNIT * NUMERO ) ; c√°lculo del precio
/       Este comentario ser√° siempre editado en pantalla</code></pre>

            <hr />

            <h3>√ìrdenes de estructuraci√≥n BAL</h3>

            <h4>Generalidades</h4>
            <p>Las √≥rdenes de estructuraci√≥n permiten definir, para el traductor, el principio y el fin del texto del programa BAL y de cada uno de los segmentos. Estas √≥rdenes no son ejecutables en general.</p>
            <hr />

            <h3>PROGRAM</h3>

            <h4>Definici√≥n</h4>
            <pre><code>PROGRAM "PRUEBA"        ; Principio Programa</code></pre>

            <p>Esta orden es la primera de un programa BAL.</p>
            <p>El nombre lleva de 1 a 15 caracteres v√°lidos, y debe ser escrito entre comillas <code>"_____"</code>. Cada espacio cuenta como un car√°cter.</p>
            <p>Este nombre ser√° imprimido en la lista del programa arriba de cada p√°gina, excepto en la primera p√°gina.</p>
            <p>Este nombre es independiente del nombre del fichero que contiene el fuente.</p>
            <p>Debe haber al menos un espacio entre el fin de la palabra clave <code>PROGRAM</code> y la comilla <code>"</code> que indica el principio del nombre.</p>
            <h4>Opci√≥n MSIZE=C</h4>
            <p>La opci√≥n <code>MSIZE=C</code> indica al traductor la longitud m√°xima admisible para un segmento. La constante <code>C</code> da esta longitud en n√∫mero de octetos.</p>
            <p>Si en la traducci√≥n esta longitud es sobrepasada hay un error fatal (segmento inexistente en la ejecuci√≥n), y el mensaje "segment trop grand" es editado en la misma l√≠nea que el mensaje "Longueur programme".</p>
            <h4>Opci√≥n NOCLR</h4>
            <p>La opci√≥n <code>NOCLR</code> evita el borrado de pantalla en ejecuci√≥n, pues a priori, la opci√≥n (<code>CLR</code>) permite al ejecutor <code>EX</code> imponer el borrado de pantalla.</p>
            <p>Esta opci√≥n (<code>NOCLR</code>) solo puede ser utilizada si las variables han sido declaradas.</p>
            <p>Si la opci√≥n <code>NOCLR</code> es utilizada:</p>
            <ul>
              <li>Entonces el cursor se queda en la posici√≥n que ten√≠a antes de la ejecuci√≥n. Es preciso ejecutar un <code>TABV(1)</code> para editar al principio de la l√≠nea siguiente.</li>
              <li>Entonces las funciones <code>LIN</code> y <code>COL</code> que dan la posici√≥n del cursor, no dar√°n resultados correctos a no ser que el programa ejecute un <code>HOME</code> o un <code>CLEAR</code> de pantalla.</li>
              </ul>

            <p>Como todas las √≥rdenes, <code>PROGRAM</code> puede continuar con un comentario, por ejemplo, de la √∫ltima fecha de puesta a punto.</p>
            <h4>Sintaxis</h4>
            <pre><code>PROGRAM "Nomb 1 a 15 Car." [ , MSIZE= C ][ , NOCLR ][ ; Comentario ]</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>PROGRAM "PRIMERA PRUEBA"  ; FECHA: 25-02-1987</code></pre>

            <hr />

            <h3>END</h3>

            <h4>Definici√≥n</h4>
            <pre><code>END             ; Fin de Programa</code></pre>

            <p>Esta orden es la √∫ltima de un programa, e indica al traductor el fin del texto fuente. No es ejecutable, el fin de ejecuci√≥n de un programa ser√° indicado por una orden <code>STOP</code>.</p>
            <h4>Sintaxis</h4>
            <pre><code>END</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>END</code></pre>

            <hr />

            <h3>SEGMENT</h3>

            <h4>Definici√≥n</h4>
            <pre><code>SEGMENT         ; Principio de Segmento</code></pre>

            <p>Esta orden es la primera de cualquier segmento.</p>
            <ul>
              <li>El primer segmento lleva el n√∫mero cero, es el programa principal.</li>
              <li>Los dem√°s segmentos constituyen sub-programas residentes en disco y son cargados autom√°ticamente en memoria despu√©s de llamarlos si a√∫n no estaban en memoria.</li>
              <li>En el momento de una vuelta a llamar al segmento es recargado otra vez, si ya no estaba en memoria.</li>
              </ul>

            <h4>Gesti√≥n de memoria en m√°quinas de 16 bits</h4>
            <ul>
              <li>Se pueden tener 1 a n segmentos en memoria seg√∫n la capacidad</li>
              <li>El segmento 0 no tiene que ser forzosamente residente</li>
              <li>Al llamar a un segmento, si ya no estaba en memoria y si no hay capacidad disponible para cargar este segmento, la plaza de los segmentos que sean menos usados en llamadas ser√° recuperada</li>
              <li>Es indiferente el orden de llamadas de los segmentos</li>
              </ul>

            <p><b>Error 100:</b> La llamada de un segmento inexistente o que contenga cualquier error de traducci√≥n, genera un error 100: Segmento inexistente.</p>
            <h4>Sintaxis</h4>
            <pre><code>SEGMENT c [ , NOLIST ]</code></pre>

            <ul>
              <li><code>c</code> es una constante comprendida entre 0 y 254, es el n√∫mero del segmento</li>
              <li><code>NOLIST</code> ordena al traductor no editar la lista de este segmento. Sin embargo, en caso de error la lista se editar√° a partir de la instrucci√≥n err√≥nea.</li>
              </ul>

            <p>Esta orden no es ejecutable.</p>
            <h4>Ejemplo</h4>
            <pre><code>SEGMENT 0               ; Principio del programa principal</code></pre>

            <hr />

            <h3>ESEG</h3>

            <h4>Definici√≥n</h4>
            <pre><code>ESEG c          ; Fin del Segmento</code></pre>

            <p>Esta orden es la √∫ltima de un segmento, indica al traductor el fin de dicho segmento.</p>
            <p>Si es ejecutado, el sistema genera un <code>STOP</code>. Hay entonces una vuelta al sistema PROLOGUE y cierre de los ficheros.</p>
            <h4>Sintaxis</h4>
            <pre><code>ESEG c</code></pre>

            <ul>
              <li><code>c</code> es una constante comprendida entre 0 y 254, es el n√∫mero del segmento</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>ESEG 0</code></pre>

            <hr />

            <h3>Utilitarios BAL</h3>

            <hr />

            <h3>TR - Traductor</h3>

            <h4>Definici√≥n</h4>
            <p>El traductor lee un programa fuente:</p>
            <ul>
              <li>Analiza la sintaxis y edita los errores de sintaxis</li>
              <li>Genera el c√≥digo traducido, es un resumen del fuente (los espacios y los comentarios son suprimidos)</li>
              <li>Edita la lista de instrucciones y las direcciones (direcciones de DBUG) de las instrucciones, as√≠ como la longitud de los diferentes segmentos</li>
              </ul>

            <p><b>Nota:</b> En caso de error en un segmento la longitud de este es nula y no podr√° ser ejecutado.</p>
            <h4>Creaci√≥n de nuevo programa</h4>
            <p>Si el fichero fuente del que se pide la traducci√≥n no existe, el traductor pide si este es un nuevo programa. Si es as√≠, el fuente ser√° introducido por teclado y traducido.</p>
            <p>Para cada instrucci√≥n, si no hay error de traducci√≥n, los ficheros fuente y traducido son generados. En caso de error es preciso volver a escribir la instrucci√≥n.</p>
            <h4>Control de la edici√≥n</h4>
            <p>Listando se puede detener la edici√≥n pulsando <code>ESCape</code> o <code>SORTIE</code>. Despu√©s se puede:</p>
            <ul>
              <li>Reemprender el listado volviendo a pulsar <code>ESCape</code> o <code>SORTIE</code></li>
              <li>Abandonar definitivamente la traducci√≥n y volver al sistema pulsando la tecla <code>R</code></li>
              </ul>

            <h4>Errores de traducci√≥n</h4>
            <p>En caso de error en la traducci√≥n, un mensaje de error se edita. Si se lista por pantalla, la edici√≥n se para. A continuaci√≥n se puede:</p>
            <ul>
              <li>Reemprender la edici√≥n pulsando <code>ESCape</code> o <code>SORTIE</code></li>
              <li>Abandonar la traducci√≥n y volver al sistema pulsando la tecla <code>R</code></li>
              </ul>

            <h4>Mensajes al final de segmentos</h4>
            <ul>
              <li><b>Longueur Programme XXXX</b> - <code>XXXX</code> es la longitud en decimal de los c√≥digos del segmento traducido. Esto es nulo si el segmento contiene al menos un error.</li>
              <li><b>Longueur Donnee YYYY</b> - Este mensaje se edita al terminar el segmento 0. <code>YYYY</code> indica en decimal el n√∫mero de octetos de las variables declaradas en memoria por <code>FIELD=</code>.</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>[Sup.]TR,Fich1[,DEST=Fich2][,TP][,NL][,ND][,LIS=LO] v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Sup.</code> - Cargar TR de este soporte, o del soporte programa (IP), por defecto</li>
              <li><code>Fich1</code> - Fichero a traducir, por defecto: de tipo fuente, en el soporte Impl√≠cito Fichero utilizador (IF)</li>
              <li><code>DEST=Fich2</code> - Fichero o soporte de destino, por defecto: en el soporte del Fich1, de nombre FICH1, de tipo -T</li>
              <li><code>TP</code> - Traducci√≥n Parcial, por segmentos. Se dar√°n los n√∫meros del (de los) segmento(s) a traducir. El programa tiene que haberse traducido una vez por completo.</li>
              <li><code>NL</code> - No lista del programa</li>
              <li><code>ND</code> - No direcciones de DBUG</li>
              <li><code>LIS=LO</code> - Listar por impresora. Por defecto en pantalla.</li>
              <li><code>v</code> - Validar</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>TR,STOCK v</code></pre>

            <hr />

            <h3>EX - Ejecutor</h3>

            <h4>Definici√≥n</h4>
            <p>El ejecutor rueda el programa traducido, de tipo <code>-T</code>.</p>
            <h4>Carga en memoria</h4>
            <ul>
              <li>La tabla de segmentos, y la tabla de nombres de variables</li>
              <li>Las variables declaradas en memoria son inicializadas en el orden de las declaraciones: a cero las num√©ricas y blancos las cadenas alfanum√©ricas</li>
              <li>El segmento cero</li>
              <li>La pantalla se borra (<code>CLEAR</code>), salvo si la opci√≥n <code>NOCLR</code> se usa en la orden <code>PROGRAM "..."</code></li>
              </ul>

            <p>El borrado puede, sin embargo, ser impuesto por la opci√≥n <code>CLR</code> del ejecutor.</p>
            <p>El ejecutor est√° entonces preparado para trabajar con la primera instrucci√≥n.</p>
            <h4>Modo Debugger</h4>
            <p>Si la opci√≥n <code>DB</code> es pedida al lanzar la ejecuci√≥n, el Debugger pasa a estar en espera de comando. Se edita entonces <code>DBUG :</code> en pantalla y se puede utilizar DBug.</p>
            <p>Si no, se ejecuta la instrucci√≥n (la primera).</p>
            <h4>Errores de ejecuci√≥n</h4>
            <p>La ejecuci√≥n de la instrucci√≥n puede provocar un error: Disco no preparado o protegido en escritura, √≠ndice demasiado grande en una tabla, etc.</p>
            <p>El programador puede gestionar los c√≥digos de errores:</p>
            <ul>
              <li>En algunas instrucciones con la opci√≥n: <code>Addr, E0</code></li>
              <li>En el conjunto de un segmento con <code>ON ERROR GOTO Addr, E0</code></li>
              </ul>

            <p>Donde <code>Addr</code> es el n√∫mero de la instrucci√≥n a ejecutar en caso de error y <code>E0</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (error). Si no hay error el c√≥digo de respuesta es cero.</p>
            <h4>Prioridad de tratamiento de errores</h4>
            <p>En caso de error:</p>
            <ol>
              <li>Si el error se genera en la instrucci√≥n es prioritario</li>
              <li>Si no, el <code>ON ERROR GOTO</code> es utilizado</li>
              <li>Si no, hay un error fatal</li>
            </ol>

            <p>Si no hay errores FATALES de ejecuci√≥n, la instrucci√≥n siguiente es ejecutada, hasta el fin del programa (<code>STOP</code>).</p>
            <h4>Error fatal</h4>
            <p>En caso de error fatal el ejecutor muestra:</p>
            <ul>
              <li>El c√≥digo de error</li>
              <li>El n√∫mero del segmento</li>
              <li>La direcci√≥n de DBUG de la instrucci√≥n que ha provocado el error</li>
              </ul>

            <p>Si la opci√≥n <code>DB</code> est√° us√°ndose, el ejecutor pasa a esperar un comando.</p>
            <p>Si no es ejecutado un <code>STOP</code>, los ficheros abiertos son cerrados, los perif√©ricos reservados son liberados y el control se retorna al sistema. PROLOGUE pasa a esperar la entrada de nuevos comandos <code>-&gt;</code>.</p>
            <h4>Sintaxis 1: Ejecuci√≥n sin par√°metros (sin ARG)</h4>
            <pre><code>[Sup.]EX,Fich[, DB ][ , CLR ] v</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Sup.</code> - Cargar EX de este soporte, o del soporte programa (IP), por defecto</li>
              <li><code>Fich</code> - Fichero a ejecutar, por defecto: de tipo traducido -T en el soporte Impl√≠cito Fichero utilizador (IF)</li>
              <li><code>DB</code> - Puesta a punto bajo control del Debugger</li>
              <li><code>CLR</code> - Borra la pantalla al lanzar la ejecuci√≥n incluso si <code>PROGRAM " "</code> contiene <code>NOCLR</code></li>
              <li><code>v</code> - Validar</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>EX,STOCK v</code></pre>

            <h4>Sintaxis 2: Ejecuci√≥n con par√°metros (con ARG)</h4>
            <p>Se pueden poner par√°metros de ejecuci√≥n en un programa BAL, bien al lanzar la ejecuci√≥n por el interpretador de comandos, bien en el momento de un <code>CHAIN=</code> o de un <code>LOAD.GO=</code>.</p>
            <p>Para esto, es preciso haber declarado una variable para recibir estos par√°metros. La longitud m√°xima de los par√°metros es de 72 caracteres.</p>
            <h4>Declaraciones</h4>
            <pre><code>DCL COMANDO$=72     ; La variable COMANDO es de 72 caracteres
ARG COMANDO         ; COMANDO recibir√° los par√°metros seguidos de un /0D</code></pre>

            <h4>Sintaxis</h4>
            <pre><code>[Sup.]EX,Fich[, par√°metros [ ; DB [ , CLR ] ] ] v
                           [ ; CLR ]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>par√°metros</code> - Par√°metros de ejecuci√≥n a poner en la variable declarada como ARGumento (<code>ARG</code>). Los par√°metros estar√°n seguidos de un c√≥digo hexadecimal <code>/0D</code>.</li>
              </ul>

            <h4>Ejemplos</h4>
            <pre><code>PAGO v
PAGO,STILL v
PAGO,;DB v
PAGO,STILL;DB v</code></pre>

            <hr />

            <h3>EX - Ejecutor - Debugger</h3>

            <h4>Comandos de Debugger</h4>
            <h4>D - Mostrar variable</h4>
            <pre><code>DBUG : D NomVar v</code></pre>

            <p>Muestra en la pantalla el contenido de la variable nombrada por <code>NomVar</code>.</p>
            <p>El fichero de tipo <code>-T</code> en ejecuci√≥n no tiene que estar cerrado (no usado <code>CLOSE=0</code>).</p>
            <h4>M - Modificar variable</h4>
            <pre><code>DBUG : M NomVar=Val v</code></pre>

            <p>Modifica el valor de la variable cuyo nombre es <code>NomVar</code>. El nuevo valor es <code>Val</code>.</p>
            <p>El fichero de tipo <code>-T</code> en ejecuci√≥n no tiene que estar cerrado (no usado <code>CLOSE=0</code>).</p>
            <h4>A - Parada permanente</h4>
            <pre><code>DBUG : A Seg,Adbug v</code></pre>

            <p>Pone una parada permanente en la instrucci√≥n cuya direcci√≥n de DBug es <code>Adbug</code>, en el segmento cuyo n√∫mero es <code>Seg</code>.</p>
            <p>El Debugger pasa a la espera de un comando: despu√©s de ejecutar esta instrucci√≥n y despu√©s de mostrar en pantalla la direcci√≥n de esta instrucci√≥n y su n√∫mero de segmento.</p>
            <h4>B - Parada no permanente</h4>
            <pre><code>DBUG : B Seg,Adbug v</code></pre>

            <p>Pone una parada no permanente en la instrucci√≥n cuya direcci√≥n de DBug es <code>Adbug</code>, en el segmento cuyo n√∫mero es <code>Seg</code>.</p>
            <p>El Debugger pasa a la espera de un comando: despu√©s de ejecutar esta instrucci√≥n y antes de haber mostrado en la pantalla la direcci√≥n de esta instrucci√≥n y su n√∫mero de segmento.</p>
            <p>La parada es suprimida despu√©s de ser encontrada.</p>
            <h4>G - Ejecutar continuaci√≥n</h4>
            <pre><code>DBUG : G[Adbug] v</code></pre>

            <p>Ejecutar la continuaci√≥n del programa a partir:</p>
            <ul>
              <li>De la instrucci√≥n designada por <code>Adbug</code></li>
              <li>O, por defecto a partir de la instrucci√≥n previamente se√±alada</li>
              </ul>

            <h4>S - Modo paso a paso</h4>
            <pre><code>DBUG : S v</code></pre>

            <p>Selecci√≥n modo paso a paso. Las instrucciones ser√°n ejecutadas una por una, como si hubiera parada en todas las instrucciones.</p>
            <h4>Espacio - Ejecutar instrucci√≥n siguiente</h4>
            <pre><code>DBUG : _ (espacio)</code></pre>

            <p>Ejecutar la instrucci√≥n siguiente, despu√©s de seleccionar el modo paso a paso.</p>
            <h4>C - Anular modo paso a paso</h4>
            <pre><code>DBUG : C v</code></pre>

            <p>Anula el modo paso a paso y la parada se√±alada.</p>
            <h4>E - Fin de puesta a punto</h4>
            <pre><code>DBUG : E v</code></pre>

            <p>Fin de la puesta a punto y vuelta a Prologue.</p>
            <p>Los ficheros abiertos son cerrados y las reservas de memoria se liberan.</p>
            <h4>Interrupci√≥n de bucle</h4>
            <p>En caso de Bucle de un programa, el tecleo de la tecla <code>ESCape</code> (<code>SALIDA</code>) provoca el mismo efecto que una parada.</p>
            <p>El Debugger pasa a esperar un nuevo comando despu√©s de mostrar la direcci√≥n de Dbug y el n√∫mero del segmento de la pr√≥xima instrucci√≥n a ejecutar.</p>
            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 3: Declaraciones BAL</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <ul>
              <li>Programa fuente BAL multifichero - INCLUDE</li>
              <li>Lenguaje BAL: variables y constantes</li>
              <li>Tipo: Num√©rica corta, Num√©rica larga, Cadena</li>
              <li>Longitud, tabla, √≠ndice</li>
              <li>Designaci√≥n, Inicializaci√≥n</li>
              <li>Tipos de variables y de constantes: <code>#</code>, <code>%</code>, <code>$</code>, espacio</li>
              <li>Declaraci√≥n de constantes - CONST</li>
              <li>Declaraciones de variables - DCL</li>
              <li>FIELD=M (Memoria central)</li>
              <li>Memoria Virtual</li>
              <li>Variable para par√°metros de ejecuci√≥n - ARG</li>
              </ul>

            <hr />

            <h3>Programa Fuente BAL Multificheros</h3>

            <h4>Definici√≥n: INCLUDE</h4>
            <p>El texto fuente de un programa BAL puede ser registrado en varios ficheros diferentes.</p>
            <p>El traductor, al encontrar esta orden, traduce el fichero fuente relacionado en INCLUDE. El c√≥digo traductor es puesto a continuaci√≥n de esta orden.</p>
            <p>El fichero nombrado en INCLUDE puede contener otras √≥rdenes INCLUDE. El n√∫mero de niveles de inclusi√≥n est√° limitado a cinco.</p>
            <p>Despu√©s de traducir el fichero "Fich", se traducen las instrucciones siguientes al INCLUDE, salvo si encuentra la orden END.</p>
            <h4>Sintaxis:</h4>
            <pre><code>INCLUDE "Fich"</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>"Fich"</code> - Cadena de caracteres que da el nombre del fichero a incluir</li>
              <li>Este fichero es de tipo <code>-S</code> a priori</li>
              <li>Est√° en el soporte impl√≠cito fichero utilizador (IF)</li>
              </ul>

            <p>Formato de Fich:</p>
            <pre><code>Fich = [Sup.]NomFich[-S][:Claves]</code></pre>

            <h4>Ejemplo:</h4>
            <pre><code>PROGRAM "TOTO"
INCLUDE "DECLAR"        ; el fichero de declaraciones
SEGMENT 0
.
.
ESEG 0
END</code></pre>

            <p>Fichero: "DECLAR-S"</p>
            <pre><code>FIELD=M
DCL DIA%
DCL MES#
DCL PRECIO
DCL DIRECCION$</code></pre>

            <p>Todo esto es equivalente a:</p>
            <pre><code>PROGRAM "TOTO"
FIELD=M
DCL DIA%
DCL MES#
DCL PRECIO
DCL DIRECCION$
SEGMENT 0
.
.
ESEG 0
END</code></pre>

            <hr />

            <h3>Variables y Constantes</h3>

            <h4>Definici√≥n de Constante</h4>
            <p>Una constante es una informaci√≥n que no cambia de valor.</p>
            <p>Una constante puede ser declarada (entre PROGRAM y SEGMENT 0). Se puede asimismo darle un nombre (identificador) y un valor. El traductor verifica que esta constante no ser√° nunca modificada.</p>
            <p>Una constante cadena puede ser declarada con una longitud m√°xima de 80 caracteres.</p>
            <h4>Ejemplos de constantes:</h4>
            <pre><code>318             -1.42           "Pepito"        "Febrero"
CONST PI = 3.141592653589       P=2* PI * R</code></pre>

            <h4>Definici√≥n de Variable</h4>
            <p>Una variable es una informaci√≥n que puede cambiar de valor.</p>
            <p>Todas las variables deben ser declaradas, entre PROGRAM y SEGMENT 0. Las variables son todas globales, conocidas en el entorno del programa.</p>
            <h4>Soporte de almacenamiento (FIELD=)</h4>
            <p>La informaci√≥n de variables ser√° almacenada en el soporte definido por FIELD=</p>
            <ul>
              <li>En memoria central: <code>FIELD=M</code></li>
              <li>En disco (o disquete): <code>FIELD=c</code> donde <code>1 &lt;= c &lt;= 15</code></li>
              <ul>
                <li>Se trata entonces de variables en memoria virtual</li>
                <li>En un segmento, antes de la primera utilizaci√≥n de tales variables, una orden <code>ASSIGN=1 a 15</code> asociar√° a este n√∫mero un fichero o un soporte</li>
                <li>Esto da lugar a un fichero relativo o bien de acceso directo (fuera del sistema de ficheros)</li>
                </ul>
              </ul>

            <h4>Nombre de variable</h4>
            <p>La informaci√≥n variable ser√° designada por un nombre (PRECIO, DIA, ...). Un nombre de variable es un identificador donde:</p>
            <ul>
              <li>Tiene de 1 a 8 caracteres alfanum√©ricos significativos, y hasta 256 caracteres m√°ximo, aunque a partir del octavo car√°cter todos los dem√°s no son significativos</li>
              <li>El primer car√°cter de un nombre debe ser una letra</li>
              <li>Las may√∫sculas y min√∫sculas son equivalentes</li>
              <li>Si un nombre de variable solo tiene una letra, es equivalente a la misma letra seguida de un cero (<code>A</code> y <code>A0</code> son el mismo nombre de variable)</li>
              <li>Un nombre de variable no puede ser una palabra clave de BAL (GOTO por ejemplo). Ninguna palabra clave de BAL contiene ni contendr√° nunca una cifra</li>
              <li>El n√∫mero de nombres de variables es ilimitado</li>
              </ul>

            <h4>Ejemplos de nombres:</h4>
            <pre><code>TOTO            X       PRECIOTOTAL     CANTIDAD</code></pre>

            <hr />

            <h3>Tipos de Variables</h3>

            <h4>Num√©rica CORTA</h4>
            <ul>
              <li><code>#</code> - Entera un octeto: -128 a +127 o 0 a 255</li>
              <li><code>%</code> - Entera dos octetos: -32768 a +32767 o 0 a 65535</li>
              </ul>

            <p>El valor de una variable num√©rica corta es considerada sin signo √∫nicamente cuando:</p>
            <ul>
              <li>Esta variable indica una direcci√≥n f√≠sica (n√∫mero de sector en IO por ejemplo)</li>
              <li>Una num√©rica corta de un octeto se usa como √≠ndice de tablas o como longitud en una zona de transferencia</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>dcl I# , T1(255) , ZONA$=250
.
I=200
T1( I ) = ...                 ; correcto T1( 200 )
down=1: ZONA , I              ; equivalente a down=1 : ZONA , 200</code></pre>

            <h4>Num√©rica LARGA</h4>
            <ul>
              <li><code>[ ]</code> espacio - No entera, num√©rica larga o B.C.D.</li>
              <li>1 a 14 cifras, el signo y un punto decimal</li>
              </ul>

            <h4>CADENA</h4>
            <ul>
              <li><code>$</code> - Cadena de caracteres (STRING en ingl√©s)</li>
              <li>1 a 256 caracteres v√°lidos (a priori) codificados en ASCII 7 bits para los caracteres no acentuados y en 8 bits para los caracteres que no existen en ASCII</li>
              </ul>

            <h4>Longitud m√°xima (en octetos)</h4>
            <ul>
              <li>8 octetos para num√©rica larga: 14 cifras, un signo y un punto</li>
              <li>256 octetos (o caracteres) para una cadena de caracteres</li>
              </ul>

            <h4>Tablas y Dimensiones</h4>
            <p>El nombre de la variable contendr√°:</p>
            <ul>
              <li>Bien un solo valor: escalar o variables no dimensionadas</li>
              <li>O bien varios valores bajo forma de tabla:</li>
              <ul>
                <li>En una dimensi√≥n (vector)</li>
                <li>O en dos dimensiones (matrices)</li>
                </ul>
              </ul>

            <p>La variable ser√° entonces dimensionada. Para designar un elemento de la tabla, se dar√° el nombre de la variable y entre par√©ntesis <code>( )</code> el o los √≠ndices, separados por una coma.</p>
            <h4>√çndices</h4>
            <ul>
              <li>Es una num√©rica (corta o larga) cuyo valor debe ser entero, y comprendido entre uno y el valor m√°ximo declarado (inferior o igual a 32767)</li>
              <li>El √≠ndice puede ser una expresi√≥n num√©rica donde el resultado es un entero</li>
              <li>En memoria es el primer √≠ndice que var√≠a. As√≠ por ejemplo en la tabla <code>T1(3,2)</code> el orden es: <code>T1(1,1), T1(2,1), T1(3,1), T1(1,2), T1(2,2), T1(3,2)</code></li>
              </ul>

            <hr />

            <h3>Designaci√≥n en un Programa</h3>

            <h4>Variable</h4>
            <p>Es necesario dar su nombre y eventualmente su o sus √≠ndices.</p>
            <h4>Constante declarada</h4>
            <p>Es necesario dar su nombre.</p>
            <h4>Constante No declarada</h4>
            <ul>
              <li><b>Cadena:</b> Se pone entre comillas <code>"Cadena"</code>. Las comillas son obligatorias en una constante cadena de caracteres.</li>
              <ul>
                <li>Ejemplo: <code>"ABC abc 123 ' !*_?"</code></li>
                </ul>
              </ul>

            <ul>
              <li><b>Num√©rica:</b> Se escribe en decimal, con eventualmente un punto para designar la coma, con opcionalmente un signo <code>+</code> o <code>-</code> delante. Por defecto el n√∫mero es supuesto positivo.</li>
              <ul>
                <li>Ejemplo: <code>+12.356</code>  <code>-86</code></li>
                <li>Se puede escribir una num√©rica corta en hexadecimal, precedido el n√∫mero por el car√°cter <code>/</code>. Ejemplo: <code>/1B</code></li>
                </ul>
              </ul>

            <h4>Inicializaci√≥n</h4>
            <p>Al lanzar la ejecuci√≥n de un programa, las variables declaradas en memoria central son inicializadas, en el orden de la declaraci√≥n:</p>
            <ul>
              <li>A blancos para las cadenas</li>
              <li>A cero para las num√©ricas</li>
              </ul>

            <p>Las variables declaradas en memoria virtual no son inicializadas.</p>
            <p>Si una variable es declarada como ARGumento, ser√° inicializada al lanzar la ejecuci√≥n, con los par√°metros seguidos de un <code>/0D</code></p>
            <h4>Ejemplo:</h4>
            <pre><code>FIELD=M
dcl I1#
FIELD=M,I1
dcl A1$=1
FIELD=M</code></pre>

            <p>Despu√©s de inicializar habr√° <code>A0=" "</code> (blanco) y por tanto <code>I1 = 32</code> o lo que es lo mismo <code>32 = /20</code> que es el valor del blanco en ASCII.</p>
            <hr />

            <h3>Tabla de Tipos de Variables y Constantes</h3>

            <h4>NUM√âRICA CORTA - 1 octeto (#)</h4>
            <ul>
              <li><b>Sigla del Tipo:</b> <code>#</code></li>
              <li><b>Longitud:</b> 1 octeto</li>
              <li><b>Representaci√≥n en memoria:</b> Complemento a 2, binario puro. Valor siempre entero. C√°lculo m√≥dulo 256. No errores desbordamiento</li>
              <li><b>Constantes:</b> [+]127 a -128 o 0 a 255 o /Hexa</li>
              </ul>

            <h4>NUM√âRICA CORTA - 2 octetos (%)</h4>
            <ul>
              <li><b>Sigla del Tipo:</b> <code>%</code></li>
              <li><b>Longitud:</b> 2 octetos</li>
              <li><b>Representaci√≥n en memoria:</b> Complemento a 2, binario puro. Valor siempre entero. C√°lculo m√≥dulo 65536. No errores desbordamiento</li>
              <li><b>Constantes:</b> [+]32767 a -32768 o 0 a 65535 o /Hexa</li>
              </ul>

            <h4>NUM√âRICA LARGA (espacio)</h4>
            <ul>
              <li><b>Sigla del Tipo:</b> <code>[ ]</code> espacio</li>
              <li><b>Longitud:</b> [=2] a [=8], 8 por defecto</li>
              <li><b>Representaci√≥n en memoria:</b> Decimal Codificado en Binario Compactado (B.C.D.). 1 octeto es usado para el signo y el punto. En los dem√°s octetos hay 2 cifras por octeto siendo 14 si la longitud=8. Si longitud=N se tendr√°n (N-1)*2 cifras significativas. En caso de error de desbordamiento por valor superior o inferior hay un error 106</li>
              <li><b>Constantes:</b> [+] o [-] 123[[.]45..]</li>
              </ul>

            <h4>CADENA de caracteres ($)</h4>
            <ul>
              <li><b>Sigla del Tipo:</b> <code>$</code></li>
              <li><b>Longitud:</b> [=1] a [=256], 15 por defecto</li>
              <li><b>Representaci√≥n en memoria:</b> ASCII 7 bits a priori, salvo para caracteres acentuados (8 bits). 1 octeto = 1 car√°cter. A priori: cuadradas a izquierda, fin de cadena puesta a blancos. Nunca hay desbordamiento si la cadena de recepci√≥n es m√°s corta, solo el principio se conserva. No hay c√°lculos matem√°ticos con las cadenas</li>
              <li><b>Constantes:</b> "ABCab12!?"</li>
              </ul>

            <hr />

            <h3>Declaraci√≥n de Constantes: CONST</h3>

            <h4>Definici√≥n</h4>
            <p>La declaraci√≥n de constantes permite parametrizar una aplicaci√≥n. Esta declaraci√≥n es facultativa, se hace entre la orden PROGRAM y la orden SEGMENT 0.</p>
            <p>Una constante declarada ser√° inicializada:</p>
            <ul>
              <li>Bien con el valor literal dado en la declaraci√≥n</li>
              <li>O bien con el valor pedido en el curso de la traducci√≥n</li>
              </ul>

            <p>Se pueden definir varias constantes con una misma instrucci√≥n CONST separando las definiciones por comas.</p>
            <p>La longitud de las constantes de tipo cadena est√° limitada a 80.</p>
            <p>El valor de una constante es directamente generado en el T-code. La ejecuci√≥n del programa ser√° m√°s r√°pida, tomando una soluci√≥n que consiste en definir las variables que se utilizan para parametrar los programas: n√∫mero l√≥gico de fichero, mnem√≥nico de soporte, etc.</p>
            <p>Adem√°s, el traductor controla el uso "en lectura solamente", lo que refuerza la fiabilidad de los programas.</p>
            <h4>Sintaxis 1: Constante inicializada con un valor</h4>
            <pre><code>CONST Nomconst[Tipo] = Valor</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Nomconst</code> - Nombre de la constante, es un identificador (1 a 8 caracteres A-Z, 0-9)</li>
              <li><code>Tipo</code> - Tipo de la constante:</li>
              <ul>
                <li><code>#</code> - Num√©rica corta 1 octeto</li>
                <li><code>%</code> - Num√©rica corta 2 octetos</li>
                <li><code>$</code> - Cadena de caracteres (l√≠mite = 80)</li>
                <li>Por defecto: num√©rica larga</li>
                </ul>
              </ul>

            <ul>
              <li><code>Valor</code> - Valor atribuido a Nomconst</li>
              </ul>

            <h4>Sintaxis 2: Constante inicializada en curso de traducci√≥n</h4>
            <pre><code>CONST Nomconst[Tipo] = ?</code></pre>

            <p>El valor ser√° pedido en la traducci√≥n. Durante la traducci√≥n, el traductor mostrar√° en pantalla:</p>
            <pre><code>CONST lglinea# = ?</code></pre>

            <p>Habr√° que grabar por teclado el valor atribuido a <code>lglinea</code>. Este valor debe corresponder en tipo a la declaraci√≥n, su entrada se termina con validaci√≥n (CR/ENTER).</p>
            <p>En el caso de una cadena, las comillas no deben ser puestas.</p>
            <p>Si est√° la opci√≥n de listado, el car√°cter <code>?</code> aparecer√° en pantalla, y eventualmente en la lista impresa.</p>
            <p>Se puede tambi√©n preceder una de estas declaraciones de un comentario siempre mostrado por:</p>
            <pre><code>/ Poner el valor de ......</code></pre>

            <p>Los caracteres de control (de valor inferior al blanco ASCII) no pueden ser dados como valor de las constantes cadenas pedidas durante la traducci√≥n.</p>
            <h4>Advertencia</h4>
            <p>Una Constante puede ser utilizada desde su definici√≥n, como entidad cuyo valor es usado, pero no puede evidentemente aparecer en la parte izquierda de una afectaci√≥n, pues su valor hab√≠a sido definido una vez por todas al principio.</p>
            <h4>Ejemplo:</h4>
            <pre><code>PROGRAM "constantes"

CONST   dimtab% = 100
DCL     tablo( dimtab )

CONST   lglinea# = 80
DCL     linea$ = lglinea

DCL I% , lgco#
...

segment 0

...

for I = 1 to dimtab

        if lgco &lt;= lglinea  ...

...  etc  ...


eseg 0
end</code></pre>

            <hr />

            <h3>Declaraci√≥n de Variables: DCL</h3>

            <h4>Definici√≥n</h4>
            <p>Todas las variables deben ser declaradas, entre la instrucci√≥n PROGRAM y el segmento 0, y ser√°n comunes a todos los segmentos.</p>
            <p>Se declaran:</p>
            <ul>
              <li>El soporte (<code>FIELD=M</code> en memoria central, por ejemplo)</li>
              <li>Con una orden DCL:</li>
              <ul>
                <li>Bien: Una o varias variables por √≥rdenes DCL, comprendiendo:</li>
                <ul>
                  <li>El nombre de la variable</li>
                  <li>La sigla del tipo: <code>#</code>, <code>%</code>, espacio, o <code>$</code></li>
                  <li>Opcionalmente la longitud</li>
                  <li>Opcionalmente la o las dimensiones m√°ximas</li>
                <li>Bien: Una zona no utilizada por una o varias variables, declarando <code>FILLER=longitud</code>, donde longitud es un n√∫mero de octetos comprendido entre 1 y 65535</li>
                  </ul>
                </ul>
              </ul>

            <p>Se puede tambi√©n declarar varias variables en la misma orden DCL.</p>
            <h4>Sintaxis:</h4>
            <pre><code>DCL NOMVAR[Tipo][=Longitud][(Dim1max[,Dim2max])] [, ....]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>NOMVAR</code> - Nombre de la variable (Identificador):</li>
              <ul>
                <li>1 a 8 letras o cifras significativas (max. 256)</li>
                <li>El primer car√°cter es una letra</li>
                <li>May√∫sculas y min√∫sculas son id√©nticas</li>
                <li><code>A</code> es equivalente a <code>A0</code></li>
                </ul>
              </ul>

            <ul>
              <li><code>Tipo</code>:</li>
              <ul>
                <li><code>#</code> - Num√©rica corta 1 octeto (-128 a +127)</li>
                <li><code>%</code> - Num√©rica corta 2 octetos (-32768 a +32767)</li>
                <li><code>[ ]</code> - Num√©rica larga, longitud 2 a 8, 8 por defecto</li>
                <li><code>$</code> - Cadena de caracteres, longitud 1 a 256, 15 por defecto</li>
                </ul>
              </ul>

            <ul>
              <li><code>=Longitud</code> - Longitud en octetos de la variable</li>
              <li><code>(Dim1max)</code> - M√°ximo de la primera dimensi√≥n</li>
              <li><code>(Dim1max,Dim2max)</code> - M√°ximo de ambas dimensiones</li>
              <li><code>, ....</code> - Otra variable declarada</li>
              </ul>

            <h4>Declaraci√≥n de FILLER:</h4>
            <pre><code>DCL FILLER=Longitud [,...]</code></pre>

            <p>Donde <code>Longitud</code> es en octetos (1 a 65535).</p>
            <h4>Ejemplo:</h4>
            <pre><code>PROGRAM "PRUEBA"
DCL I1#         ; Num√©rica corta un octeto
DCL I2%         ; Num√©rica corta dos octetos
DCL PRECIO      ; Num√©rica larga 8 octetos, 14 cifras signo y punto
DCL VALOR=5     ; Num√©rica larga 5 octetos, 8 cifras signo y punto
DCL TEXTO$      ; Cadena de 15 caracteres
DCL DIRECC$=256 ; Cadena de 256 caracteres
DCL I3#(10)     ; Tabla de 10 elementos de un octeto
DCL A1$=6(5,4)  ; Tabla de 20 elementos cadenas de 6 octetos cada uno
SEGMENT 0</code></pre>

            <hr />

            <h3>Definici√≥n del Soporte: FIELD=</h3>

            <p>La orden <code>FIELD=</code> significa: Implantar las variables donde su declaraci√≥n indique:</p>
            <ul>
              <li>En el orden de declaraciones de variables</li>
              <li>Colocando el n√∫mero de octetos definidos por las declaraciones</li>
              <li>A partir del primer octeto...</li>
              </ul>

            <h4>Sintaxis: FIELD=M</h4>
            <p>Significa implantar las variables que a continuaci√≥n se declaran a partir del primer octeto disponible en memoria.</p>
            <p>Despu√©s de la instrucci√≥n "PROGRAM" por defecto de <code>FIELD=M</code> el sistema toma el primer octeto disponible en memoria.</p>
            <h4>Ejemplo:</h4>
            <pre><code>PROGRAM "PRUEBA"
FIELD=M
DCL I1#
.
.</code></pre>

            <h4>Sintaxis: FIELD=M,NomVar[(√çndice1[,√çndice2])]</h4>
            <p><code>NomVar[(√çndice1[,√çndice2])]</code> es un nombre de variable (y eventualmente sus √≠ndices), ya declarados en memoria.</p>
            <p>Esto significa implantar las variables declaradas a continuaci√≥n a partir del primer octeto (del elemento) de la variable designada. Se obtienen as√≠ las declaraciones en equivalencia.</p>
            <p>No es preciso declarar en equivalencia una longitud superior a la longitud declarada en memoria. Cuando las declaraciones en equivalencia se terminan se puede continuar las declaraciones en memoria despu√©s de <code>FIELD=M</code>.</p>
            <p>Las variables declaradas en equivalencia son inicializadas por el sistema en √∫ltimo lugar y sus valores son prioritarios.</p>
            <p>El n√∫mero de niveles de equivalencia es ilimitado.</p>
            <h4>Ejemplo:</h4>
            <pre><code>FIELD=M
DCL I1#         ; Num. corta 1 octeto
DCL I2%         ; Num. corta 2 octetos
FIELD=M,I1
DCL A1$=3       ; en equivalencia para I1 I2
FIELD=M         ; contin√∫an las DCL en memoria
...</code></pre>

            <hr />

            <h3>Declaraci√≥n de Variable en Memoria Virtual</h3>

            <h4>Definici√≥n</h4>
            <p>Las variables que son declaradas en memoria virtual son implantadas:</p>
            <ul>
              <li>En el orden de las declaraciones</li>
              <li>A partir del primer octeto del sector del fichero (o del soporte) definido en la orden <code>ASSIGN=</code></li>
              <li>Y ocupan din√°micamente el espacio necesario para almacenar todas las variables (o elementos) hasta la √∫ltima referencia</li>
              </ul>

            <p>Estas variables no son nunca inicializadas por el sistema.</p>
            <p>En el momento de la primera referencia la variable de memoria virtual de un fichero es creada, si no exist√≠a, y este se abre. Puede ser cerrado como otros tipos de ficheros por un <code>CLOSE=</code></p>
            <p>Cada referencia de una variable memoria virtual provoca una lectura o una escritura del soporte. Si se quiere optimizar los tiempos de acceso se pueden declarar en memoria virtual las tablas de cadenas de 256 octetos, y luego leer los elementos de 256 octetos haciendo una equivalencia en memoria central.</p>
            <h4>Sintaxis: FIELD=C[,N√∫mero de Sector]</h4>
            <p>Donde:</p>
            <ul>
              <li><code>C</code> - Constante comprendida entre 1 y 15, que corresponde al n√∫mero l√≥gico de la orden <code>ASSIGN=</code> que seguir√°</li>
              <li><code>N√∫mero de Sector</code> - Constante que define el n√∫mero del primer sector a utilizar, por defecto este n√∫mero es cero</li>
              </ul>

            <p>Una orden <code>ASSIGN=</code>, situada despu√©s del segment 0, ejecutada antes del primer uso de una variable memoria virtual, asociada a este n√∫mero C (1 a 15):</p>
            <ul>
              <li>Ya sea un fichero</li>
              <li>Ya sea un soporte Fuera del sistema de ficheros</li>
              </ul>

            <h4>Sintaxis: FIELD=C,NomVar</h4>
            <p><code>NomVar</code> es una Variable ya declarada en memoria virtual, y su o sus √≠ndices eventualmente, bajo el mismo n√∫mero l√≥gico.</p>
            <h4>Ejemplo:</h4>
            <pre><code>PROGRAM "PRUEBA"
FIELD=1         ; En Virtual
DCL VIR#(256)
FIELD=M         ; En Memoria
DCL I1#
.
.</code></pre>

            <hr />

            <h3>Asignaci√≥n de un Fichero o Soporte en Memoria Virtual: ASSIGN=</h3>

            <h4>Definici√≥n</h4>
            <p>El fichero (o el soporte) memoria virtual debe ser asignado antes de toda referencia a una variable memoria virtual por una orden <code>ASSIGN=</code></p>
            <p>Esta orden se pone justo detr√°s de SEGMENT 0.</p>
            <p>Si un fichero ha sido abierto con el n√∫mero l√≥gico de este <code>ASSIGN=</code>, este fichero es cerrado.</p>
            <p>El sistema asocia a este n√∫mero l√≥gico el fichero o el soporte, as√≠ como los par√°metros de la orden <code>ASSIGN=</code></p>
            <p>Si el fichero no existe, ser√° creado autom√°ticamente y abierto seg√∫n la orden <code>ASSIGN=</code>, en el instante de la primera referencia a una variable memoria virtual.</p>
            <p>En el caso de un fichero, este puede ser abierto y cerrado. Sin embargo, no se puede abrir ni cerrar un soporte asignado.</p>
            <h4>Sintaxis: Asignaci√≥n de un fichero</h4>
            <pre><code>ASSIGN=Nlog,"Fich"[,WR][,EX][:Ader,E0]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Nlog</code> - N√∫mero l√≥gico, es una num√©rica corta donde el valor est√° comprendido entre 1 y 15. Este valor es el de la orden <code>FIELD=</code></li>
              <li><code>"Fich"</code> - Cadena de caracteres identificador del fichero</li>
              <li><code>WR</code> - Pide la apertura en escritura y en lectura. Por defecto el fichero es abierto solo en lectura</li>
              <li><code>EX</code> - Pide la apertura en exclusividad. Por defecto el fichero es compartible</li>
              <li><code>:Ader,E0</code> - Direcci√≥n de desconexi√≥n si el c√≥digo respuesta es diferente de cero. <code>E0</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (0 = Ok)</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>PROGRAM "PRUEBA"
dcl I0%
field=1                 ; dcl en memoria virtual
dcl VIR#(1024)
segment 0
assign=1,"VIRTUAL",WR   ; Las variables memoria virtual estar√°n en el
                        ; fichero de nombre VIRTUAL que tendr√° el
                        ; n√∫mero l√≥gico 1
for I0=1 to 1024        ; Cuando VIR(1)=.. hay una Creaci√≥n del Fichero
VIR(I0)=I0              ; si no exist√≠a y abierto en escritura.
next I0                 ; En cada vuelta de bucle hay 1 escritura.
eseg 0                  ; Fin, el sistema cerrar√° el fichero.
end</code></pre>

            <p>El programa de arriba ha hecho 1024 escrituras. El programa de abajo no hace m√°s que 4 escrituras en disco, es mucho m√°s r√°pido.</p>
            <pre><code>PROGRAM "RAPIDO"
dcl I0% , ZONAMEM$=256  ; zona de transferencia de un sector
dcl S1%                 ; contador de sectores

field=m, ZONAMEM        ; Equivalencia para tener la misma estructura
dcl VIR#(256)           ; de un sector en memoria virtual.

field=1                 ; Memoria virtual
ZONAVIR$=256(4)         ; 4 * 256 = 1024
segment 0
assign=1,"VIRTUAL",WR

for S1 = 1 to 4         ; 4 sectores de 256 octetos

    for I0=1 to 256
    VIR(I0)=I0+(S1-1)*256       ; VIR(..) est√° en memoria

    next I0

ZONAVIR( S1 ) = ZONAMEM ; 1 escritura de 256 octetos ( 1 Sector ).
next S1

eseg 0
end</code></pre>

            <h4>Sintaxis: Asignaci√≥n de un soporte</h4>
            <p><b>Nota:</b> Esta posibilidad solo es utilizable si el ejecutor tiene la opci√≥n PS.</p>
            <p>En el caso de asignaci√≥n de un soporte, este no puede ser abierto ni cerrado.</p>
            <pre><code>ASSIGN=Nlog,"Sop"[,Nsect][,WR][:Ader,E0]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Nlog</code> - N√∫mero l√≥gico, es una num√©rica corta donde el valor est√° comprendido entre 1 y 15. Este valor es el de la orden <code>FIELD=</code></li>
              <li><code>"Sop"</code> - Cadena de caracteres identificando el soporte</li>
              <li><code>Nsect</code> - Num√©rica corta dando el n√∫mero del primer sector a utilizar, por defecto Nsec=0 (cero)</li>
              <li><code>WR</code> - Pide la apertura en escritura y en lectura, por defecto el soporte solo es abierto para lectura</li>
              <li><code>:Ader,E0</code> - Direcci√≥n de desconexi√≥n si el c√≥digo respuesta es diferente de cero. <code>E0</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (0 = Ok)</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>.
SEGMENT 0
ASSIGN=1,"FL0",WR       ; Disco flexible unidad cero acceso directo en
                        ; memoria virtual.
.
.</code></pre>

            <hr />

            <h3>Declaraci√≥n de Variable para Par√°metros de Ejecuci√≥n: ARG</h3>

            <h4>Definici√≥n</h4>
            <p>Cuando se lanza la ejecuci√≥n, un programa B.A.L. puede recibir par√°metros bajo la forma de una cadena (limitada a una longitud de 72 caracteres).</p>
            <p>Se lanza la ejecuci√≥n (ver el Ejecutor EX):</p>
            <pre><code>-&gt; ex,TOTO,FL0</code></pre>

            <p>Donde <code>FL0</code> es el par√°metro de ejecuci√≥n.</p>
            <p>Para realizar esto, el programa BAL debe contener la declaraci√≥n de una variable cadena de caracteres que contendr√° los par√°metros pasados, seguidos de un <code>/0D</code> (ENTER/CR hexadecimal).</p>
            <p>Si la longitud de la variable declarada es insuficiente, hay truncamiento antes de la inserci√≥n del ENTER.</p>
            <p>Si la longitud de la variable es mayor que el comando, se completa con blancos, y luego el ENTER (<code>/0D</code>).</p>
            <h4>Sintaxis:</h4>
            <pre><code>DCL Nomvar$=Long

ARG Nomvar</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>Nomvar</code> - Nombre de la variable cadena, ya declarada en un DCL que contendr√° los par√°metros (m√°s el <code>/0D</code>)</li>
              <li><code>Long</code> - Constante num√©rica corta que indica la longitud en octetos de "Nomvar"</li>
              </ul>

            <p>Solo puede haber un ARG en un programa.</p>
            <p>ARG aparece en las declaraciones, despu√©s de la declaraci√≥n de su variable y antes del fin de las declaraciones.</p>
            <h4>Ejemplo:</h4>
            <p>Ejemplo de programa que controla el mnem√≥nico de un volumen PROLOGUE bajo forma de par√°metros:</p>
            <pre><code>Program "ejemplo"

dcl VOLUMEN$=4  ; 3 para el nombre + 1 para el ENTER

ARG VOLUMEN     ; la variable VOLUMEN est√° preparada para recibir
                ; el par√°metro ...

dcl LG#

...

segment 0

        LG = index( VOLUMEN, chr$( /0D ))       ; LG = Posici√≥n del /0D

        assign=3, left( VOLUMEN , LG-1 ) ...    ; Asignaci√≥n con el
                                                ; nombre del soporte

        .....   ; tratamiento...

eseg 0
end</code></pre>

            <h4>Advertencia</h4>
            <p>Se remarca la necesidad de buscar la presencia del CR/ENTER en la cadena receptora. Ir√° incluso en el caso donde varios par√°metros deben ser interpretados (b√∫squeda de separadores...).</p>
            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 4: Expresiones - Afectaciones</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <ul>
              <li>Lenguaje BAL: Los operadores de c√°lculo</li>
              <li>Operadores aritm√©ticos: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
              <li>Operadores l√≥gicos: <code>AND</code>, <code>OR</code>, <code>OX</code></li>
              <li>Operador de cadena: <code>+</code></li>
              <li>Lenguaje BAL: Los operadores de relaci√≥n</li>
              <li>Operadores de comparaci√≥n: <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;&gt;</code></li>
              <li>Operadores l√≥gicos relacionales: <code>AND</code>, <code>OR</code></li>
              <li>Lenguaje BAL: Las expresiones de c√°lculo</li>
              <li>Lenguaje BAL: Las expresiones de relaci√≥n</li>
              <li>Lenguaje BAL: √ìrdenes de afectaci√≥n</li>
              <li><code>LET</code></li>
              <li><code>READ=0:</code></li>
              <li><code>RESTORE</code></li>
              <li><code>DATA</code></li>
              </ul>

            <hr />

            <h3>Lenguaje BAL: Los Operadores</h3>

            <h4>Definici√≥n</h4>
            <p>Un operador indica una operaci√≥n a realizar. No es activo m√°s que en par√°metros del mismo g√©nero y del mismo tipo.</p>
            <h4>Los operadores son de dos g√©neros</h4>
            <h4>Operadores de c√°lculo</h4>
            <pre><code>*    /    +    -    AND   OR   OX   +</code></pre>

            <p>Asociados a operandos (constantes, variables o expresiones de c√°lculo del mismo tipo) forman expresiones de c√°lculo de tres formas:</p>
            <ul>
              <li><b>Aritm√©ticas:</b> <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code></li>
              <li><b>L√≥gicas:</b> <code>AND</code>, <code>OR</code>, <code>OX</code></li>
              <li><b>Cadena:</b> <code>+</code></li>
              </ul>

            <h4>Operadores de relaci√≥n</h4>
            <pre><code>=   &lt;   &gt;   &lt;=   &gt;=   &lt;&gt;    AND   OR</code></pre>

            <p>Asociados a operandos, forman expresiones de relaci√≥n de dos tipos:</p>
            <ul>
              <li><b>Comparaci√≥n:</b> <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;&gt;</code></li>
              <li><b>L√≥gica relacional:</b> <code>AND</code>, <code>OR</code></li>
              </ul>

            <p>El resultado de una expresi√≥n de relaci√≥n es VERDADERA o FALSA.</p>
            <p>Los operadores de relaci√≥n de comparaci√≥n solo pueden estar asociados a expresiones de c√°lculo todas ellas del mismo tipo.</p>
            <p>Los operadores de relaci√≥n l√≥gica solo pueden ser asociados a expresiones de comparaci√≥n puestas entre par√©ntesis. La expresi√≥n obtenida no puede ser puesta entre par√©ntesis.</p>
            <hr />

            <h3>Los Operadores de C√°lculo</h3>

            <h4>Operadores de c√°lculos aritm√©ticos</h4>
            <p>Los operadores de c√°lculo aritm√©tico solo trabajan con variables num√©ricas cortas o largas, pero no se pueden mezclar las num√©ricas cortas y las num√©ricas largas en una misma expresi√≥n. Se pueden mezclar las num√©ricas cortas de 1 y 2 octetos.</p>
            <pre><code>Multiplicaci√≥n      *       ; Ej: Y=X * 2
Divisi√≥n            /       ; Ej: Y=Z / 3.14
Suma                +       ; Ej: N=N + 1
Resta               -       ; Ej: M=P - N</code></pre>

            <h4>Operadores de c√°lculos l√≥gicos</h4>
            <p>Los operadores de c√°lculo l√≥gico solo funcionan con num√©ricas cortas. Con una num√©rica corta de dos octetos (<code>%</code>), solo el octeto de menor rango es usado. La operaci√≥n es hecha en cada uno de los 8 bits y el resultado es afectado a cada uno de los 8 bits correspondientes del resultado.</p>
            <pre><code>Y  l√≥gico    AND     ; 1 AND 1 da 1, otra combinaci√≥n da cero.
O  inclusivo OR      ; 0 OR  0 da 0, otra combinaci√≥n da uno.
O  exclusivo OX      ; 0 OX  0 da 0
                     ; 1 OX  1 da 0, otra combinaci√≥n da uno.</code></pre>

            <p><b>Nota:</b> Otra definici√≥n de "O exclusivo" es: El resultado es CERO si los dos bits son id√©nticos, si no, el resultado es UNO, para cada bit del octeto.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl I1#
dcl J1#
dcl K1#
....
segment 0
I1=/26          ; es        0010 0110 en binario  o  /26 Hexadecimal
J1=/0F          ; es        0000 1111 en binario  o  /0F Hexadecimal
K1=I1 AND J1    ; da    K1= 0000 0110 en binario  o  /06 Hexadecimal
K1=I1 OR  J1    ; da    K1= 0010 1111 en binario  o  /2F Hexadecimal
K1=I1 OX  J1    ; da    K1= 0010 1001 en binario  o  /29 Hexadecimal</code></pre>

            <hr />

            <h3>Operadores de C√°lculo en Cadenas</h3>

            <p>Los operadores de c√°lculo de cadenas solo funcionan sobre cadenas de caracteres. Si se concatenan, las variables son puestas trozo a trozo considerando la longitud de la declaraci√≥n, incluso contando los blancos de fin de cadena.</p>
            <pre><code>Concatenaci√≥n       +     ; "Se√±or " + "PEREZ" da "Se√±or PEREZ".</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>dcl A1$=6
dcl B1$=4
dcl C1$=10
.
.
SEGMENT 0
A1="ABCD"
B1="123"
C1=A1 + B1      ; da C1="ABCD  123 "
                ;       1234567890</code></pre>

            <hr />

            <h3>Los Operadores de Relaci√≥n</h3>

            <h4>Operadores de comparaci√≥n relacional</h4>
            <p>Los operadores de comparaci√≥n relacional son los siguientes:</p>
            <pre><code>&lt;    Inferior a ...
&gt;    Superior a ...
&lt;=   Inferior o igual a ...
&gt;=   Superior o igual a ...
&lt;&gt;   Diferente de ...
=    Igual a ... para operandos NUM√âRICOS
=    Incluido en ... en el sentido de SUB-CADENA para operandos CADENAS</code></pre>

            <p>Una SUB-CADENA es una sucesi√≥n de caracteres no blancos seguidos de un blanco, o varias sub-cadenas reunidas por un blanco. Esto no tiene nada que ver con una igualdad.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl D1$=3
.
D1="01"     ; N√∫mero de provincia de √Ålava.
;           ; El total de provincias del Pa√≠s Vasco
IF D1="01 20 48" goto 100           ; Es VERDADERO y va a instrucci√≥n 100
;                   El 01 es una de las provincias vascas.
D1="12"     ; Castell√≥n
;
IF D1="01 20 48" goto 100           ; Es FALSO: en la secuencia
;   no est√° el "12" pero s√≠ "1 2"
D1="1"      ;
;
IF D1="01 20 48" goto 100           ; Es FALSO: en la secuencia
;   no est√° el "1 " pero s√≠ "01 "</code></pre>

            <p>Para encontrar la igualdad entre dos cadenas es preciso escribir:</p>
            <pre><code>IF V1 &lt;&gt; V2 THEN Adr1 ELSE Adr2
;
; si V1 es igual a V2 hay salida a Adr2.</code></pre>

            <h4>Operadores l√≥gicos relacionales</h4>
            <p>Los operadores l√≥gicos relacionales son los siguientes:</p>
            <pre><code>AND     ; (Verdad) AND (Verdad) es VERDADERO, sino es FALSO
OR      ; (Falso)  OR  (Falso)  es FALSO, sino es VERDADERO</code></pre>

            <p>Los operandos de estos operadores deben ser siempre expresiones de comparaci√≥n relacional puestas entre par√©ntesis.</p>
            <hr />

            <h3>Lenguaje BAL: Las Expresiones</h3>

            <h4>Definici√≥n</h4>
            <p>Existen expresiones de g√©nero C√ÅLCULO y expresiones de g√©nero RELACIONAL.</p>
            <ul>
              <li>Las expresiones de c√°lculo son realizadas con operadores de C√ÅLCULO</li>
              <li>Las expresiones de relaci√≥n son realizadas con operadores de RELACI√ìN</li>
              </ul>

            <h4>Expresi√≥n de C√ÅLCULO</h4>
            <p>Una expresi√≥n de c√°lculo aritm√©tica, l√≥gica o cadena es una sucesi√≥n de variables, constantes, funciones y/o expresiones de c√°lculos de mismo tipo, unidas por operadores (aritm√©ticos, l√≥gicos o cadena) y/o par√©ntesis.</p>
            <p>Una expresi√≥n quiz√° usada para todo o una variable (para lectura) puede ser utilizada.</p>
            <p>Las prioridades para el c√°lculo de una expresi√≥n de c√°lculo es la siguiente (por orden de prioridad decreciente):</p>
            <ol>
              <li><b>Par√©ntesis:</b> <code>( .. )</code></li>
              <li><b>Menos absoluto:</b> <code>-</code> (multiplicado por -1, ej: <code>A=-B</code>)</li>
              <li><b>Multiplicar/Dividir:</b> <code>*</code>, <code>/</code></li>
              <li><b>Resto de operadores:</b> <code>+</code>, <code>-</code></li>
            </ol>

            <p>Si no se aplica ninguna orden de prioridad las operaciones son efectuadas de izquierda a derecha.</p>
            <h4>Advertencias</h4>
            <p>Las funciones siguientes no pueden ser usadas en una expresi√≥n:</p>
            <ul>
              <li><code>INCLUD</code> - Inclusi√≥n de una cadena</li>
              <li><code>MOVE</code> - Transferencia de una zona de variable(s)</li>
              <li><code>POKE</code> - Escritura de un octeto en memoria</li>
              <li><code>PRINT</code> - Afectaci√≥n de expresi√≥n(s) con formato</li>
              <li><code>TRAN</code> - Transcodificaci√≥n de una cadena</li>
              </ul>

            <p><b>Nota:</b> En las instrucciones <code>ASK=</code> y <code>PRINT=</code>, una expresi√≥n no puede comenzar por un par√©ntesis de apertura, puesto que ser√° puesto con un formato.</p>
            <h4>Ejemplo</h4>
            <pre><code>PRECIOTOT = ( PRECUNIT * NUMERO - DEVUELTO ) * ( 1 + IVA )

print=1:gener( NB+3 , CAR ) ; muestra NB + 3 veces el 1er. car√°cter de CAR</code></pre>

            <hr />

            <h3>Expresi√≥n de RELACI√ìN</h3>

            <p>Las expresiones de relaci√≥n solo se usan en las √≥rdenes de tipo <code>IF ..</code></p>
            <p>No hay √≥rdenes de prioridades en las expresiones de relaci√≥n.</p>
            <p>El resultado de una expresi√≥n de relaci√≥n solo puede ser VERDADERO o FALSO.</p>
            <h4>Expresiones de COMPARACI√ìN relacional</h4>
            <p>Una expresi√≥n de relaci√≥n de comparaci√≥n est√° constituida por dos variables, constantes, funciones y/o expresiones del mismo tipo, del g√©nero c√°lculo, unidas por un operador de comparaci√≥n como:</p>
            <pre><code>=     &lt;     &gt;     &lt;=     &gt;=     &lt;&gt;</code></pre>

            <h4>Expresi√≥n L√ìGICA relacional</h4>
            <p>Una expresi√≥n de relaci√≥n l√≥gica est√° constituida por dos (o m√°s) expresiones de comparaci√≥n relacional, puestas entre par√©ntesis y unidas por un operador de relaci√≥n L√ìGICA como:</p>
            <pre><code>AND   OR</code></pre>

            <p>Una expresi√≥n de relaci√≥n L√ìGICA no puede ser puesta nunca entre par√©ntesis. Las relaciones se eval√∫an de izquierda a derecha.</p>
            <h4>Ejemplo</h4>
            <pre><code>if ( X1 &gt; X2 ) OR ( Y1 = Y2 ) then ...

if ( X=Y ) AND ( Z=T ) OR ( B=C ) then ...
;  si ( X=Y y Z=T ) entonces ....
;  o si B=C entonces ....

if ( I+2 &lt; J*3 ) OR ( len$( A ) &gt; 10 ) then ...
; si     I+2 &lt; J*3        entonces ....
; o si   len$( A ) &gt; 10   entonces ....</code></pre>

            <hr />

            <h3>Lenguaje BAL: √ìrdenes de AFECTACI√ìN</h3>

            <p>Una orden de afectaci√≥n atribuye un valor a una variable.</p>
            <h4>LET - Afectaci√≥n de una Expresi√≥n</h4>
            <h4>Definici√≥n</h4>
            <p>La orden <code>LET</code>, es opcional, eval√∫a la expresi√≥n de c√°lculo que est√° a la derecha del signo <code>=</code> (igual), y pone el resultado en la variable de la izquierda (VAR).</p>
            <p>La expresi√≥n y la variable deben ser del mismo tipo, no obstante, se pueden mezclar num√©ricas cortas de un octeto con las de dos octetos en la misma orden de afectaci√≥n.</p>
            <p>Si el resultado es demasiado grande puede ser almacenado en la variable resultado y si:</p>
            <ul>
              <li><b>Este es num√©rico largo:</b> hay un error de ejecuci√≥n 106: Desbordamiento de capacidad de una variable num√©rica larga.</li>
              </ul>

            <ul>
              <li><b>Este es num√©rico corto:</b> el resultado es tomado m√≥dulo 256 para un num√©rico corto de un octeto y m√≥dulo 65536 para un num√©rico corto de dos octetos. No hay ning√∫n error de ejecuci√≥n.</li>
              </ul>

            <ul>
              <li><b>Este es una Cadena de caracteres:</b> solo los caracteres de la izquierda se conservan, seg√∫n el n√∫mero declarado para esta variable. No hay ning√∫n error de ejecuci√≥n.</li>
              </ul>

            <p>Si se trabaja con cadenas de caracteres, y si la cadena resultado es m√°s corta que la variable (V), entonces el fin de dicha variable es rellenada con blancos. Esto es v√°lido salvo para ciertas funciones particulares donde solo se modifica una parte de la cadena resultado (<code>INCLUD</code> por ejemplo).</p>
            <h4>Sintaxis</h4>
            <pre><code>[ LET ] VAR = EXPresi√≥n</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>EXPresi√≥n</code> es una expresi√≥n de c√°lculo, una variable, una constante o una funci√≥n</li>
              <li><code>VAR</code> es una variable del mismo tipo que la expresi√≥n calculada</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>    PRECIO = ( PRECIOUNIT * PESO ) - DESCUENTO
LET IVA  = 12
    N1   = N1 + 1
    A1   = "Estimado " + NOMBRE</code></pre>

            <hr />

            <h3>READ=0, DATA - Afectaci√≥n de Constantes</h3>

            <h4>Definici√≥n</h4>
            <p>En un segmento si es preciso inicializar una o varias variables con constantes se puede hacer por medio de una orden <code>READ=0</code>.</p>
            <p>Las constantes (datos) ser√°n definidas en una o varias √≥rdenes <code>DATA</code> al fin del segmento (justo antes de <code>ESEG c</code>), y despu√©s de una instrucci√≥n de ruptura de secuencia.</p>
            <p>Si una orden <code>DATA</code> se ejecuta, el ejecutor genera una orden <code>STOP</code> y la ejecuci√≥n se para.</p>
            <p>Desde la primera orden <code>READ=</code> de un segmento, el sistema empieza a leer la primera constante de este segmento (a priori).</p>
            <h4>Sintaxis READ=0</h4>
            <pre><code>READ=0: V1 [ ,V2 [ , ... ] ]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>V1</code>, <code>V2</code> son una sucesi√≥n de nombres de variables, eventualmente con √≠ndices</li>
              <li>Cada nombre est√° separado del siguiente por una coma</li>
              <li>La pr√≥xima constante a leer es almacenada en la primera variable del <code>READ=0</code></li>
              <li>La constante siguiente es almacenada en la variable siguiente, etc.</li>
              <li>Los tipos de variables (V1, V2) deben corresponder al tipo de constantes que leen</li>
              </ul>

            <p>Por medio de una orden <code>READ=0</code> posterior, la constante siguiente (a priori) ser√° le√≠da.</p>
            <p>Si se intenta leer (<code>READ=0</code>) una constante cuando el puntero est√° despu√©s de la √∫ltima constante, hay un error fatal: 101 "Fin de las DATA en una instrucci√≥n READ=0 en memoria".</p>
            <p>No obstante, se puede reposicionar el puntero de lectura por: <code>RESTORE [ N1 ]</code>.</p>
            <h4>Sintaxis RESTORE</h4>
            <pre><code>RESTORE [ N1 ]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>N1</code> es un num√©rico corto &gt; 0 e inferior o igual al n√∫mero total de constantes de DATA de este segmento</li>
              <li>Por defecto <code>N1 = 1</code></li>
              </ul>

            <p>Esta orden reposiciona el puntero de lectura, para el pr√≥ximo <code>READ=0</code> de este segmento, en la N1 √©sima constante de la zona DATA. Por defecto de par√°metro N1, en la primera constante.</p>
            <p>Se puede ejecutar una orden <code>RESTORE N1</code> antes de la primera <code>READ=0</code>, si no se quiere leer la primera constante.</p>
            <p>Por defecto <code>RESTORE</code>, al principio del segmento el puntero se coloca en la primera constante de dicho segmento.</p>
            <h4>Sintaxis DATA</h4>
            <pre><code>DATA C1 [ ,C2 [ ,... ] ]</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>C1</code>, <code>C2</code>, ... son constantes num√©ricas cortas o largas o cadenas de caracteres</li>
              <li>Ser√°n le√≠das por √≥rdenes <code>READ=0</code> de este segmento</li>
              </ul>

            <p><b>Restricciones:</b></p>
            <ul>
              <li>Las √≥rdenes <code>DATA</code> tienen que estar agrupadas al fin del segmento, despu√©s de una orden de ruptura de secuencia incondicional, y justo antes de <code>ESEG</code></li>
              <li>Las constantes pueden ser escritas en una o varias √≥rdenes <code>DATA</code></li>
              <li>Ser√°n consideradas como escritas consecutivamente en una sola y √∫nica zona DATA</li>
              <li>El n√∫mero m√°ximo de constantes es de 32767</li>
              <li>La ejecuci√≥n de una orden <code>DATA</code> provoca un <code>STOP</code></li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>program "prueba"
dcl A1$
dcl N1%
dcl X1
dcl Y1
.
.
segment 0   ; el puntero de datos (DATA) colocado en la 1a. constante
.
READ=0: A1 , N1     ; A1="Hola" y N1=25, el puntero se coloca en la 3a.
.                   ; constante de la zona de datos (DATA)
.
READ=0: X1 , Y1     ; X1=15.36 e Y1=365.10, todas las constantes han sido
.                   ; le√≠das.
RESTORE 2           ; el puntero se coloca en la 2a. constante
READ=0: N1 , X1     ; N1=25 y X1=15.36
.
.
STOP
DATA "Hola", 25        ; las constantes corresponden en tipo con las
DATA 15.36, 365.10     ; variables de READ=0
ESEG 0</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 5: Las Funciones CADENAS</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <h4>Funciones de Cadenas</h4>
            <ul>
              <li><code>CHR$(N0)</code> - Car√°cter desde c√≥digo ASCII</li>
              <li><code>DATE(N0)</code> - Fecha y hora del sistema</li>
              <li><code>GENER(N0, A0)</code> - Generar cadena repetida</li>
              <li><code>INCLUD(N0, A0 [,N1])</code> - Incluir subcadena</li>
              <li><code>INDEX(A0, B0)</code> - Buscar posici√≥n de subcadena</li>
              <li><code>INSTR(A0, B0, N0)</code> - Verificar subcadena en posici√≥n</li>
              <li><code>INV(A0)</code> - Invertir cadena</li>
              <li><code>LARGE(A0)</code> - Convertir a may√∫sculas</li>
              <li><code>LEFT(A0, N0)</code> - Extraer caracteres izquierda</li>
              <li><code>LEN(A0)</code> - Longitud declarada</li>
              <li><code>LEN$(A0)</code> - Longitud efectiva</li>
              <li><code>MOVE(V2, N1, N2)</code> - Mover zona de memoria</li>
              <li><code>PRINT(formatos/expresiones)</code> - Formatear a cadena</li>
              <li><code>RIGHT(A0, N0)</code> - Extraer caracteres derecha</li>
              <li><code>SHL(A0)</code> - Cuadrar a izquierda</li>
              <li><code>SHR(A0)</code> - Cuadrar a derecha</li>
              <li><code>SMALL(A0)</code> - Convertir a min√∫sculas</li>
              <li><code>SPACE(N0)</code> - Generar espacios</li>
              <li><code>SUBSTR(A0, N0, N1)</code> - Extraer subcadena</li>
              </ul>

            <h4>Funciones de Conversi√≥n</h4>
            <ul>
              <li><code>CONV(V0)</code> - Convertir tipo</li>
              <li><code>DEC(A0, N0)</code> - Hexadecimal a decimal</li>
              <li><code>HEX(N0)</code> - Decimal a hexadecimal</li>
              <li><code>STRN(X0)</code> - Num√©rico a cadena</li>
              <li><code>VAL(A0, N0)</code> - Cadena a num√©rico</li>
              <li><code>TRAN(A0, B0, N0, C0)</code> - Transcodificar</li>
              </ul>

            <hr />

            <h3>Introducci√≥n a las Funciones</h3>

            <p>Una funci√≥n se escribe bajo la forma <code>NOMDEFUNCION(P1 [,P2 ...])</code> donde <code>NOMDEFUNCION</code> es el nombre de la funci√≥n y <code>P1</code>, <code>P2</code> ... son los par√°metros de la funci√≥n. Durante su ejecuci√≥n es evaluada seg√∫n los par√°metros y un valor se le atribuye. Este valor puede ser num√©rico corto o largo o cadena seg√∫n la funci√≥n (en ciertos casos seg√∫n el tipo de la variable de afectaci√≥n).</p>
            <p>Una funci√≥n puede usarse cada vez que una expresi√≥n de c√°lculo est√° autorizada. Excepto para las funciones <code>INCLUD</code>, <code>POKE</code>, <code>TRAN</code>, <code>MOVE</code>, <code>PRINT</code>.</p>
            <h4>Convenci√≥n de nombres en los ejemplos</h4>
            <p>En los ejemplos los nombres de variables simbolizar√°n los tipos:</p>
            <ul>
              <li><code>A0, B0, C0 ...</code> para cadenas de caracteres</li>
              <li><code>K0, K1, K2 ...</code> para num√©ricas cortas o largas</li>
              <li><code>N0, N1, N2 ...</code> para num√©ricas cortas</li>
              <li><code>X0, Y0, Z0 ...</code> para num√©ricas largas</li>
              <li><code>V0, V1, V2 ...</code> para cualquier tipo</li>
              </ul>

            <h4>Orden de descripci√≥n</h4>
            <p>Las funciones son descritas en el orden siguiente:</p>
            <ul>
              <li>Funciones de Cadenas</li>
              <li>Funciones de conversi√≥n</li>
              <li>Funciones Matem√°ticas</li>
              <li>Funciones Bibliotecas</li>
              <li>Opci√≥n PS</li>
              <li>Funciones y √≥rdenes generales</li>
              </ul>

            <hr />

            <h3>Funciones de Cadenas</h3>

            <h4>CHR$(N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>CHR$(N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Transfiere al primer octeto de la cadena resultante:</p>
            <ul>
              <li>El contenido de <code>N0</code>, si <code>N0</code> es una num√©rica corta 1 octeto</li>
              <li>O el octeto de menor rango de <code>N0</code>, si <code>N0</code> es una num√©rica corta 2 octetos</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>; Sea ESCape "b" para poner el atributo de inversi√≥n video
; y   ESCape "a" para volver al modo video normal.
; El c√≥digo hexadecimal de ESCape es /1B

print=1:CHR$(/1B),"b","Inversi√≥n Video",CHR$(/1B),"a","Normal",tabv(1)

; El mensaje "Inversi√≥n Video" aparece en inverso video en pantalla.</code></pre>

            <hr />

            <h4>DATE(N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>DATE(N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Esta funci√≥n da una cadena de caracteres cuadrada a izquierda, y sin cero a izquierda, que da la fecha y/o la hora seg√∫n el valor de <code>N0</code>.</p>
            <p>La fecha es la del sistema, y puede ser inicializada:</p>
            <ul>
              <li>Por el utilitario DATE</li>
              <li>Por √≥rdenes <code>DATE(N0)= ..</code>, si el ejecutor contiene la opci√≥n PS</li>
              </ul>

            <p>El sistema pone al d√≠a la fecha y la hora.</p>
            <p><code>N0</code> es una num√©rica corta:</p>
            <ul>
              <li>Si <code>N0=1</code> - <code>DATE(N0)</code> da el a√±o</li>
              <li>Si <code>N0=2</code> - <code>DATE(N0)</code> da el mes</li>
              <li>Si <code>N0=3</code> - <code>DATE(N0)</code> da el n√∫mero de d√≠a en el mes</li>
              <li>Si <code>N0=4</code> - <code>DATE(N0)</code> da el n√∫mero de d√≠a en el a√±o</li>
              <li>Si <code>N0=5</code> - <code>DATE(N0)</code> da la hora</li>
              <li>Si <code>N0=6</code> - <code>DATE(N0)</code> da los minutos</li>
              <li>Si <code>N0=7</code> - <code>DATE(N0)</code> da los segundos</li>
              <li>Si <code>N0=8</code> - <code>DATE(N0)</code> da las d√©cimas de segundos</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>dcl B0$=4
.
B0= DATE(1)      ; da B0="1987"          ; el a√±o
B0= DATE(2)      ; da B0="5   "          ; Mayo
print=1:DATE(3)+"/"+DATE(2)+" "+DATE(1)  ; Edita "22/5 1987"</code></pre>

            <p><b>Advertencia:</b> Existe una orden DATE, para iniciar la fecha, descrito en "La opci√≥n PS".</p>
            <hr />

            <h4>GENER(N0, A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>GENER(N0, A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena conteniendo <code>N0</code> veces el primer car√°cter de <code>A0</code>.</p>
            <p><code>N0</code> es una num√©rica corta, <code>A0</code> es una cadena que puede ser una constante.</p>
            <h4>Ejemplo:</h4>
            <pre><code>print=1:GENER(79,"*"),tabv(1)  ; Edita en pantalla una l√≠nea de 79 asteriscos</code></pre>

            <hr />

            <h4>INCLUD(N0, A0 [,N1])</h4>
            <h4>Sintaxis:</h4>
            <pre><code>B0=INCLUD(N0, A0 [,N1])</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>N0</code> y <code>N1</code> son variables o constantes num√©ricas cortas.</p>
            <p>Esta funci√≥n <code>INCLUD</code> no puede aparecer en una expresi√≥n.</p>
            <p><code>INCLUD</code> reemplaza, a partir de la posici√≥n <code>N0</code> de la cadena resultado (<code>B0</code>), los <code>N1</code> caracteres que siguen por los <code>N1</code> primeros caracteres de <code>A0</code>.</p>
            <p>Por defecto de <code>N1</code>, el sistema reemplaza por la cadena <code>A0</code> entera, cuya longitud es dada por la declaraci√≥n de <code>A0</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="ABCD"
B0="1234567"
B0=INCLUD(3, A0, 2)     ; da B0 = "12AB567"</code></pre>

            <hr />

            <h4>INDEX(A0, B0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>INDEX(A0, B0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da como resultado un num√©rico corto cuyo valor indica la posici√≥n de la cadena <code>B0</code> en <code>A0</code>, el valor indica la posici√≥n del primer car√°cter de <code>B0</code>.</p>
            <p>En la b√∫squeda los espacios a fin de la cadena <code>B0</code> (en la derecha) no son contados.</p>
            <p>Si <code>B0</code> no se encuentra en <code>A0</code> el valor resultante es cero.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="A1ABCDE"
B0="ABC"
N0= INDEX(A0, B0)       ; da N0 = 3

B0="Axx"
N0= INDEX(A0, B0)       ; da N0 = 0   "Axx" no est√° en A0</code></pre>

            <hr />

            <h4>INSTR(A0, B0, N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>INSTR(A0, B0, N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da como resultado un num√©rico corto, cuyo valor es 1 si <code>B0</code> est√° contenido en <code>A0</code>, estando el primer car√°cter <code>B0</code> en posici√≥n <code>N0</code>.</p>
            <p>En la b√∫squeda los espacios a fin de la cadena <code>B0</code> (en la derecha) no son contados.</p>
            <p>Si <code>B0</code> no est√° en <code>A0</code> en posici√≥n <code>N0</code> el valor resultante es cero.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="A1ABCDE"
B0="ABC"
N0= INSTR(A0, B0, 3)    ; da N0 = 1 (S√≠)

B0="A1A"
N0= INSTR(A0, B0, 3)    ; da N0 = 0 (No, falso en posici√≥n 3)</code></pre>

            <hr />

            <h4>INV(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>INV(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Inversi√≥n de la cadena <code>A0</code>. El primer car√°cter de <code>A0</code> es el primero de la cadena resultado, etc...</p>
            <p>Para que el primer car√°cter de <code>A0</code> sea el √∫ltimo car√°cter de <code>B0</code>, las dos cadenas deben ser declaradas con la misma longitud.</p>
            <h4>Ejemplo:</h4>
            <pre><code>DCL A0$=6, B0$=6
.
A0="123456"
B0=INV(A0)              ; da B0="654321"
print=1:INV("ROTAVATOR") ; edita ROTAVATOR</code></pre>

            <hr />

            <h4>LARGE(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>LARGE(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena resultado igual a la que tiene min√∫sculas (no acentuadas) reemplazadas por las may√∫sculas correspondientes.</p>
            <p>Esta funci√≥n puede ser interesante para las cadenas que ser√°n claves de acceso a un fichero, o en r√∫bricas multi-criterios.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="Precio 500 Pesetas"
B0= LARGE(A0)    ; da B0="PRECIO 500 PESETAS"</code></pre>

            <hr />

            <h4>LEFT(A0, N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>LEFT(A0, N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena conteniendo los <code>N0</code> primeros caracteres de <code>A0</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>DCL A0$=7, B0$=7
.
A0="A1ABCDE"        ;        1234567
B0= LEFT(A0, 3)     ; da B0="A1A    "</code></pre>

            <hr />

            <h4>LEN(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>LEN(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da como resultado una num√©rica corta cuyo valor es la longitud declarada para la variable <code>A0</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>DCL A0$=12
.
N0= LEN(A0)      ; da N0= 12 sea cual sea el contenido de A0</code></pre>

            <hr />

            <h4>LEN$(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>LEN$(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da como resultado un num√©rico corto cuyo valor es la posici√≥n del √∫ltimo car√°cter no blanco de la variable <code>A0</code>.</p>
            <p>Por ejemplo el n√∫mero de caracteres introducidos por teclado para <code>A0</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>DCL A0$=12
.
ASK=1:=A0   ; Entrada de "HOLA" por teclado
N0= LEN$(A0)     ; da N0= 4

A0="123 abc"
print=1:LEN$(A0)   ; da 7</code></pre>

            <hr />

            <h4>MOVE(V2, N1, N2)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>V1=MOVE(V2, N1, N2)</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>V1</code> y <code>V2</code> son variables de cualquier tipo declaradas en memoria central. Otras variables declaradas despu√©s de <code>V1</code> y/o <code>V2</code> pueden ser afectadas por esta funci√≥n.</p>
            <ul>
              <li><code>N1</code> es una num√©rica corta, indica el rango del primer octeto de <code>V2</code> a transferir</li>
              <li><code>N2</code> es una num√©rica corta, indica el n√∫mero de octetos a transferir en <code>V1</code> (a partir del octeto de rango <code>N1</code> y siguientes)</li>
              </ul>

            <p>Esta funci√≥n permite un desplazamiento r√°pido de una zona de memoria a otra, de una o varias variables, sin control ni del tipo ni de la longitud de las variables (la longitud transferida es <code>N2</code>).</p>
            <p>Esta funci√≥n no puede intervenir en una expresi√≥n.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl X1=8(5)         ; 40 octetos
dcl X2=8(5)         ; 40 octetos

X2(1)=MOVE(X1(1), 1, 40)  ; Despu√©s X2(i) = X1(i) ; i = 1 a 5</code></pre>

            <hr />

            <h4>PRINT(formatos/expresiones)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>A1=PRINT(seguido de formato y de expresiones)</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>A1</code> es una variable de tipo cadena de caracteres.</p>
            <p>El interior de par√©ntesis (formatos y expresiones) es id√©ntico a la orden <code>PRINT=</code>, excepto que las tabulaciones est√°n prohibidas.</p>
            <p>Las constantes deben tener un formato de edici√≥n como en un <code>PRINT=</code></p>
            <p>La longitud de la variable de recepci√≥n es respetada. Si esta longitud es m√°s grande que la zona a recibir, el fin de <code>A1</code> es puesto a blancos.</p>
            <p>Despu√©s de la ejecuci√≥n <code>A1</code> contiene los caracteres que ser√≠an editados por un <code>PRINT=</code></p>
            <p>Esta funci√≥n no puede intervenir en una expresi√≥n.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl A1$
                                        ;        12345678
A1=PRINT((N3.Z2, " /", 12))             ; da A1=" 12.00 /"</code></pre>

            <hr />

            <h4>RIGHT(A0, N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>RIGHT(A0, N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena conteniendo los <code>N0</code> √∫ltimos caracteres de <code>A0</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>DCL A0$=7, B0$=7
.
A0="A1ABCDE"        ;           1234567
B0= RIGHT(A0, 3)    ; da    B0="CDE    "</code></pre>

            <hr />

            <h4>SHL(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>SHL(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Cuadra a izquierda la cadena de caracteres <code>A0</code>.</p>
            <p>Los espacios a la izquierda (al principio) de <code>A0</code> pasan a la derecha (fin) de la cadena resultado, salvo en una expresi√≥n donde los espacios no est√°n a la derecha. Sin embargo, en una expresi√≥n los espacios a la derecha se conservan.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl A0$=10
.
;   1234567890
A0="  A1 BC   "             ;           1234567890
print=1:"!",SHL(A0),"!"     ; da       !A1 BC     !</code></pre>

            <hr />

            <h4>SHR(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>SHR(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Cuadra a la derecha la cadena de caracteres <code>A0</code>.</p>
            <p>Los espacios a la derecha (fin) de <code>A0</code> pasan a la izquierda (al principio) de la cadena resultado, incluso en una expresi√≥n donde los espacios est√°n a la izquierda.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl A0$=10
.
;   1234567890
A0="  A1 BC   "             ;           1234567890
print=1:"!", SHR(A0),"!"    ; da       !     A1 BC!</code></pre>

            <hr />

            <h4>SMALL(A0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>SMALL(A0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena resultado en la cual las may√∫sculas son reemplazadas por las min√∫sculas correspondientes.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="PRECIO 500 PESETAS"
B0= SMALL(A0)    ; da    B0="precio 500 pesetas"</code></pre>

            <hr />

            <h4>SPACE(N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>SPACE(N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <ul>
              <li>En una orden de afectaci√≥n: reemplaza los <code>N0</code> primeros caracteres de la cadena resultado por espacios, el fin de la cadena no es puesto con blancos</li>
              <li>En una expresi√≥n da una cadena de <code>N0</code> espacios</li>
              </ul>

            <p><code>N0</code> es una num√©rica corta.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl A0$=10
.
A0="1234567890"     ;           1234567890
A0= SPACE(5)        ; da    A0="     67890"
A0=" "              ; da    A0="          "
;                                   12345
print=1:"!",SPACE(5),"!"  ; Edita  !     !</code></pre>

            <hr />

            <h4>SUBSTR(A0, N0, N1)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>SUBSTR(A0, N0, N1)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena extra√≠da a partir del <code>N0</code> √©simo car√°cter de <code>A0</code>, la longitud extra√≠da es de <code>N1</code> caracteres.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="A1ABCDE"
B0= SUBSTR(A0, 3, 4)    ; Da    B0="ABCD      "
print=1:".", SUBSTR(A0, 3, 4),"."   ; Edita sin comillas ".ABCD."</code></pre>

            <hr />

            <h3>Funciones de Conversi√≥n</h3>

            <h4>CONV(V0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>CONV(V0)      ;  o   V1 = CONV(V0)</code></pre>

            <h4>Definici√≥n:</h4>
            <ul>
              <li>Convertir un valor de tipo <code>V0</code> en un valor de tipo <code>V1</code>, en una instrucci√≥n de afectaci√≥n simple (pues el tipo es conocido de antemano)</li>
              <li>Convertir un valor de tipo <code>V0</code> en un num√©rico largo, en una expresi√≥n de c√°lculo cuyo tipo es desconocido de antemano</li>
              </ul>

            <p>Cuando el resultado de la conversi√≥n de un num√©rico (corto o largo) es una cadena de caracteres, esta es cuadrada a la derecha con ceros a la izquierda y el signo m√°s es siempre omitido.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl A0$=9
.
A0="12.34ABC"
X0=CONV(A0)       ; da    X0=12.34 (Num√©rico largo)
A0=CONV(X0)       ; da    A0="000012.34" cadena</code></pre>

            <hr />

            <h4>DEC(A0, N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>DEC(A0, N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da un num√©rico corto cuyo valor est√° contenido en <code>A0</code> a partir del principio de <code>A0</code> y representado por <code>N0</code> caracteres ASCII hexadecimales.</p>
            <p><code>A0</code> es una cadena de caracteres, <code>N0</code> es un num√©rico corto.</p>
            <p>El valor en <code>A0</code> es representado en hexadecimal por una cadena de caracteres ASCII: <code>0-9 A-F</code></p>
            <p>En una orden de afectaci√≥n, si el tipo de la variable de recepci√≥n no permite obtener el resultado hay un error 108 (desbordamiento aritm√©tico).</p>
            <p>Si el contenido a convertir no est√° en hexadecimal hay un error 104 (cadena utilizada como num√©rico).</p>
            <h4>Ejemplo:</h4>
            <pre><code>DEC("20", 2)            ;       = 32
DEC("FF", 2)            ;       = -1 para un #, 255 para un %
DEC("A0 Bonjour", 2)    ;       = 160
DEC("G1F", 3)           ;       -&gt; error 104
DEC("1FFF07A", 4)       ;       -&gt; 8191 para %, error 108 para #</code></pre>

            <hr />

            <h4>HEX(N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>HEX(N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena de caracteres ASCII hexadecimal (<code>0-9 A-F</code>) representando el valor de <code>N0</code>.</p>
            <p><code>N0</code> es una num√©rica corta.</p>
            <p>En una orden de afectaci√≥n, si la longitud de la variable de recepci√≥n no permite obtener el resultado hay un error 112.</p>
            <p>Si la longitud de la variable de recepci√≥n es m√°s peque√±a que la cadena resultado, el final de dicha cadena es rellenado con blancos.</p>
            <h4>Ejemplo:</h4>
            <pre><code>HEX(10)          ; da      "A"
HEX(32)          ; da      "20"
HEX(-1)          ; da      "FF"
HEX(256)         ; da      "100"</code></pre>

            <hr />

            <h4>STRN(X0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>STRN(X0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Da una cadena de caracteres correspondiente al valor del num√©rico largo <code>X0</code>.</p>
            <p>La cadena es cuadrada a la izquierda y el signo <code>+</code> es omitido.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl A0$=10
.
X0= -123.45         ;           1234567890
A0=STRN(X0)         ; da    A0="-123.45   "
print=1:":", STRN(X0),"!"  ; Edita :-123.45!</code></pre>

            <hr />

            <h4>VAL(A0, N0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>VAL(A0, N0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>N0</code> es una num√©rica corta.</p>
            <p>Da un num√©rico largo cuyo valor est√° contenido en la cadena <code>A0</code>, a partir del <code>N0</code> √©simo car√°cter de <code>A0</code>, la conversi√≥n se detiene en el primer car√°cter que no es una cifra o el punto o la coma decimal.</p>
            <p>Los espacios a la izquierda son filtrados.</p>
            <p>Si no hay valores num√©ricos, el valor retornado es cero.</p>
            <h4>Ejemplo:</h4>
            <pre><code>A0="AB-12.34CD"
X0= VAL(A0, 3)      ; da    X0= -12.34</code></pre>

            <hr />

            <h4>TRAN(A0, B0, N0, C0)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>D0= TRAN(A0, B0, N0, C0)</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>N0</code> es una num√©rica corta, el resultado es una cadena.</p>
            <p>Esta funci√≥n transcodifica la cadena <code>C0</code>, utilizando el diccionario <code>A0 --&gt; B0</code>, no considerando m√°s que los <code>N0</code> primeros caracteres de <code>A0</code> y de <code>B0</code>.</p>
            <ul>
              <li>El 1er. car√°cter de <code>A0</code> da el 1er. car√°cter de <code>B0</code></li>
              <li>El 2o. car√°cter de <code>A0</code> da el 2o. car√°cter de <code>B0</code></li>
              <li>El 3er. car√°cter de <code>A0</code> da el 3er. car√°cter de <code>B0</code></li>
              <li>Etc... hasta <code>N0</code> √©simo car√°cter</li>
              </ul>

            <p>Los caracteres de <code>C0</code> que no pertenecen a los <code>N0</code> primeros caracteres de <code>A0</code> no son transcodificados.</p>
            <p>Esta funci√≥n no puede estar en una expresi√≥n.</p>
            <h4>Ejemplo:</h4>
            <pre><code>dcl C0$=10
.
A0="ABCDEF"
B0="1234"
C0="A1ABCDEAB"                      ;       C0="A1ABCDEAB"
D0= TRAN(A0, B0, 3, C0)             ; da    D0="11123DE12"

A0=" ,"                             ; la coma da un punto
B0="0."                             ; Espacio da cero
;   1234567890
C0="-123,45   "                     ;       C0="-123,45   "
D0= TRAN(A0, B0, 2, C0)             ; da    D0="-123.45000"
C1="  01230   "
C1=SHR(C1)                          ; cuadrar derecha C1="     01230"
D1= TRAN(A0, B0, 1, C1)             ; da              D1="0000001230"</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 6: Funciones Matem√°ticas, Bibliotecas y Opci√≥n PS</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <h4>Funciones Matem√°ticas</h4>
            <ul>
              <li><code>ABS</code> ( K0 )</li>
              <li><code>FIX</code> ( X0 [ , N0 ] )</li>
              <li><code>FP</code> ( X0 )</li>
              <li><code>INT</code> ( X0 )</li>
              <li><code>MOD</code> ( K0 , K1 )</li>
              <li><code>RND</code> [ ( N0 ) ]</li>
              <li><code>ROUND</code> ( X0 , N0 )</li>
              <li><code>SGN</code> ( K0 )</li>
              </ul>

            <h4>Funciones Bibliotecas</h4>
            <ul>
              <li><code>ATN</code> ( X0 )</li>
              <li><code>COS</code> ( X0 )</li>
              <li><code>EXP</code> ( X0 )</li>
              <li><code>LOG</code> ( X0 )</li>
              <li><code>SIN</code> ( X0 )</li>
              <li><code>SQR</code> ( X0 )</li>
              <li><code>TAN</code> ( X0 )</li>
              </ul>

            <h4>Funciones y √ìrdenes Opci√≥n PS</h4>
            <ul>
              <li>Orden <code>DATE</code> ( N0 )</li>
              <li>Orden <code>DEFSEG</code> [ = N1 ]</li>
              <li>Orden <code>INP</code> N0V , N1ADR</li>
              <li>Orden <code>OUT</code> N0 , N1ADR</li>
              <li>Funci√≥n <code>PEEK</code> ( N1ADR )</li>
              <li>Funci√≥n <code>POKE</code> ( N0 )</li>
              <li>Funci√≥n <code>VPTR</code> ( V0 )</li>
              <li>Funci√≥n <code>COL</code> [ ( V0 ) ]</li>
              <li>Funci√≥n <code>LIN</code> [ ( V0 ) ]</li>
              <li>Funci√≥n <code>CONF</code> ( N0 )</li>
              <li>Orden <code>KBF</code> ( N1 )</li>
              <li>Funci√≥n <code>KBF</code> ( N1 )</li>
              <li>Orden <code>PAUSE</code> V0</li>
              <li>Orden <code>PROCESS</code> N0V</li>
              <li>Funci√≥n <code>PROCESS</code></li>
              <li>Orden <code>WAIT</code> N0</li>
              </ul>

            <hr />

            <h3>Funciones Matem√°ticas</h3>

            <h4>ABS - Valor Absoluto</h4>
            <h4>Sintaxis</h4>
            <pre><code>ABS( K0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el valor absoluto de un num√©rico (corto o largo) K0. Es decir, fuerza el signo m√°s (+).</p>
            <p>El resultado es del tipo de K0.</p>
            <h4>Ejemplo</h4>
            <pre><code>K0= -12.34
K1=ABS( K0 )            ; da K1 = 12.34</code></pre>

            <hr />

            <h4>FIX - Parte Entera con Formato</h4>
            <h4>Sintaxis</h4>
            <pre><code>FIX( X0 [ , N0 ] )</code></pre>

            <h4>Definici√≥n</h4>
            <p><b>1) Sin par√°metro N0:</b></p>
            <p>Da la parte entera del num√©rico largo X0, conservando el signo. El resultado es un num√©rico largo.</p>
            <p>En memoria el n√∫mero se cuadra a la derecha, el punto es omitido, los ceros se ponen a la izquierda despu√©s del signo (siempre presente).</p>
            <p><b>2) Con par√°metro N0:</b></p>
            <p>N0 es un num√©rico corto cuyo valor da el n√∫mero de cifras a guardar antes de la coma, en el cuadre a la derecha.</p>
            <p>En memoria el n√∫mero es cuadrado a la derecha, con N0 cifras decimales, luego el punto, luego el n√∫mero con ceros a la izquierda y delante el signo (siempre presente). Si el n√∫mero X0 es negativo un complemento a FFFF es efectuado, as√≠ tanto el orden positivo como negativo es respetado si el resultado es una clave de acceso de un fichero S.I. (o una uni√≥n de M.C.).</p>
            <p>Luego, poner el par√°metro N0 = 0 da un resultado diferente a la ausencia de este par√°metro.</p>
            <p>Esto permite utilizar un num√©rico largo como clave de acceso (o uni√≥n) de un fichero, que ser√° de tipo K=.. (o B). Esta funci√≥n (FIX) debe ser ejecutada sobre todas las variables num√©ricas largas que forman parte de la clave (o uni√≥n), antes de todas las funciones del sistema de ficheros para las cuales la variable es un par√°metro de llamada.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl X0=6
.
X0=-12.34                          ; 010203040506 los 6 octetos en memoria
Y0= FIX ( X0 )      ; da Y0=-12    ; B00000000012 en memoria
                    ; signo        : B para menos ; C para +</code></pre>

            <hr />

            <h4>FP - Parte Fraccionaria</h4>
            <h4>Sintaxis</h4>
            <pre><code>FP( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da la parte fraccionaria del num√©rico largo X0, y conserva el signo.</p>
            <p>El resultado es un num√©rico largo.</p>
            <h4>Ejemplo</h4>
            <pre><code>X0=-12.34
Y0= FP ( X0 )       ; da Y0 = -0.34</code></pre>

            <hr />

            <h4>INT - Entero Inferior</h4>
            <h4>Sintaxis</h4>
            <pre><code>INT( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el m√°s grande entero inferior o igual al num√©rico largo X0.</p>
            <p>El resultado es un num√©rico largo.</p>
            <h4>Ejemplo</h4>
            <pre><code>X0=12.34
Y0=INT ( X0 )       ; da Y0 = 12
X0=-12.34
Y0=INT ( X0 )       ; da Y0 = -13</code></pre>

            <hr />

            <h4>MOD - M√≥dulo</h4>
            <h4>Sintaxis</h4>
            <pre><code>MOD ( K0 , K1 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el valor absoluto de K0 m√≥dulo K1, es decir, el resto de la divisi√≥n entera de K0 por K1.</p>
            <p>K0 y K1 deben ser num√©ricos del mismo tipo (cortos o largos los dos).</p>
            <p>El resultado es del tipo de K0 y de K1.</p>
            <h4>Ejemplo</h4>
            <pre><code>X0=-10.4
Y0= 4
Z0=MOD ( X0 , Y0 )  ; da Z0 = 2.4
N0= 10
N1= 4
N2=MOD ( N0 , N1 )  ; da N2 = 2</code></pre>

            <hr />

            <h4>RND - N√∫mero Pseudo-Aleatorio</h4>
            <h4>Sintaxis</h4>
            <pre><code>RND [ ( N0 ) ]</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da un n√∫mero pseudo-aleatorio.</p>
            <p>El resultado es un num√©rico corto.</p>
            <ul>
              <li>Si el resultado es un num√©rico corto de un octeto, su valor est√° comprendido entre 0 y 255 (o -128 y +127).</li>
              <li>Si el resultado es un num√©rico corto de dos octetos, su valor est√° comprendido entre 0 y +32767, y no est√° nunca con signo.</li>
              </ul>

            <p>N0 es un num√©rico corto que permite escoger el primer n√∫mero de la serie pseudo-aleatoria, por defecto N0 es igual a cero.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl N0#
dcl N1%
.
N0=RND(9)   ; da N0 = 20
N1=RND      ; da N1 = 42</code></pre>

            <hr />

            <h4>ROUND - Redondeo</h4>
            <h4>Sintaxis</h4>
            <pre><code>ROUND( X0 , N0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Redondea al m√°s cercano, a 0.5, el num√©rico largo X0 con N0 cifras despu√©s de la coma (o el punto).</p>
            <p>N0 es un num√©rico corto.</p>
            <p>Si N0 es igual a cero el resultado es entero.</p>
            <p>El resultado es un num√©rico largo.</p>
            <h4>Ejemplo</h4>
            <pre><code>X0=-10.454
Y0= ROUND ( X0 , 2 )    ; da Y0 = -10.45
X0=-10.455
Y0= ROUND ( X0 , 2 )    ; da Y0 = -10.46
X0=-10.456
Y0= ROUND ( X0 , 2 )    ; da Y0 = -10.46</code></pre>

            <hr />

            <h4>SGN - Signo</h4>
            <h4>Sintaxis</h4>
            <pre><code>SGN ( K0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da, como resultado, un num√©rico corto cuyo valor depende del signo de K0, que es un num√©rico corto o largo.</p>
            <ul>
              <li>El resultado es igual a <b>1</b> si K0 es positivo ( &gt; 0 )</li>
              <li>El resultado es igual a <b>0</b> si K0 es nulo ( = 0 )</li>
              <li>El resultado es igual a <b>-1</b> si K0 es negativo ( &lt; 0 )</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>X0=13.45
N0=SGN( X0 )        ; da N0 = 1
X0=-11
N0=SGN( X0 )        ; da N0 = -1</code></pre>

            <hr />

            <h3>Funciones Bibliotecas</h3>

            <h4>Requisitos</h4>
            <p>Estas funciones s√≥lo est√°n disponibles en ejecuci√≥n si el Ejecutor dispone de la opci√≥n BL. Para saber si el ejecutor tiene dicha opci√≥n, pedir su n√∫mero de versi√≥n haciendo:</p>
            <pre><code>-&gt; EXv,v</code></pre>

            <h4>Caracter√≠sticas Generales</h4>
            <ul>
              <li>Todos los c√°lculos se hacen con una precisi√≥n de 7 cifras y el resultado se da con una precisi√≥n de 6 cifras.</li>
              <li>Los operandos y el resultado son siempre num√©ricos largos.</li>
              <li>Los √°ngulos siempre se obtienen en radianes.</li>
              <li>1 radi√°n es igual a PI/180 grados.</li>
              <li>Se puede tomar PI = 3.14159265359</li>
              </ul>

            <hr />

            <h4>ATN - Arco Tangente</h4>
            <h4>Sintaxis</h4>
            <pre><code>ATN( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da en radianes el valor del arco cuya tangente es X0.</p>
            <p>X0 es un num√©rico largo.</p>
            <ul>
              <li>Si X0 &lt;= 0.001 entonces ATN(X0) da X0</li>
              <li>Si X0 &gt;= 10 potencia 6 entonces ATN(X0) da 1.5708 (PI / 2)</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>Y0=ATN( 1 )                 ; da Y0= 0.785398 es PI / 4</code></pre>

            <hr />

            <h4>COS - Coseno</h4>
            <h4>Sintaxis</h4>
            <pre><code>COS( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el coseno del √°ngulo X0.</p>
            <p>X0 es un num√©rico largo expresado en radianes.</p>
            <ul>
              <li>Si X0 &lt;= 0.001 entonces COS(X0) da 1</li>
              <li>Si X0 &gt;= 10 potencia 8 entonces COS(X0) da 0</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>Y0=COS( 0.52359877559833 )  ; es COS( PI/6 ) da Y0= 0.866025</code></pre>

            <hr />

            <h4>EXP - Exponencial</h4>
            <h4>Sintaxis</h4>
            <pre><code>EXP( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el exponencial de X0.</p>
            <p>X0 es un num√©rico largo.</p>
            <ul>
              <li>Si X0 &lt;= 10 potencia -6 entonces EXP(X0) da 1</li>
              <li>Si X0 &gt; 34 hay error 108</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>Y0=EXP( 2 )                 ; da Y0= 7.38906</code></pre>

            <hr />

            <h4>LOG - Logaritmo Neperiano</h4>
            <h4>Sintaxis</h4>
            <pre><code>LOG( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el logaritmo neperiano de X0.</p>
            <p>X0 es un num√©rico largo.</p>
            <p>Si X0 &lt;= 0 hay error 110.</p>
            <p><b>Nota:</b> El Logaritmo decimal es igual al logaritmo neperiano multiplicado por 0.4342945</p>
            <h4>Ejemplo</h4>
            <pre><code>Y0=LOG( 10 )                ; da Y0= 2.30259</code></pre>

            <hr />

            <h4>SIN - Seno</h4>
            <h4>Sintaxis</h4>
            <pre><code>SIN( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da el seno del √°ngulo X0.</p>
            <p>X0 es un num√©rico largo expresado en radianes.</p>
            <ul>
              <li>Si X0 &lt;= 0.001 entonces SIN(X0) da X0</li>
              <li>Si X0 &gt;= 10 potencia 8 entonces SIN(X0) da 0</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>Y0=SIN( 1.0471975511966 )   ; es SIN( PI/3 ) da Y0= 0.866026</code></pre>

            <hr />

            <h4>SQR - Ra√≠z Cuadrada</h4>
            <h4>Sintaxis</h4>
            <pre><code>SQR( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da la ra√≠z cuadrada de X0.</p>
            <p>X0 es un num√©rico largo.</p>
            <p>Si X0 es negativo hay un error 110.</p>
            <h4>Ejemplo</h4>
            <pre><code>Y0=SQR( 3 )                 ; da Y0= 1.73205</code></pre>

            <hr />

            <h4>TAN - Tangente</h4>
            <h4>Sintaxis</h4>
            <pre><code>TAN( X0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da la tangente del √°ngulo X0.</p>
            <p>X0 es un num√©rico largo expresado en radianes.</p>
            <ul>
              <li>Si X0 &lt;= 0.001 entonces TAN(X0) da X0</li>
              <li>Si X0 &gt;= 10 potencia 8 hay error 110, porque COS(X0)=0</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>Y0=TAN( 0.7853981633975 )   ; es TAN( PI/4 ) da Y0= 1</code></pre>

            <hr />

            <h3>Funciones y √ìrdenes Opci√≥n PS (Programador Sistema)</h3>

            <h4>Introducci√≥n</h4>
            <p>Ciertas √≥rdenes y funciones s√≥lo est√°n disponibles si el ejecutor contiene la opci√≥n PS. En efecto estas √≥rdenes y funciones tienen acciones directas sobre el material y/o sobre el sistema mismo. Usando estas posibilidades opcionales se asegura una mejor portabilidad de los logiciales.</p>
            <p>Adem√°s, en el sistema un par√°metro de configuraci√≥n (opci√≥n PS) permite autorizar (o prohibir) la ejecuci√≥n de estas √≥rdenes y/o funciones.</p>
            <p><b>Las √≥rdenes y funciones protegidas por la opci√≥n PS son:</b></p>
            <p><code>DATE=</code>, <code>DEFSEG</code>, <code>INP</code>, <code>OUT</code>, <code>PEEK</code>, <code>POKE</code>, <code>VPTR</code></p>
            <p>Adem√°s: <code>LOAD</code>, <code>CALL</code>, <code>IO=</code>, y la utilizaci√≥n de variables memoria virtual en acceso directo en un soporte, que se ver√°n m√°s adelante.</p>
            <hr />

            <h4>DATE - Inicializar Fecha/Hora (Orden, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>DATE( N0 ) = A0</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta orden es la inversa de la funci√≥n DATE. Permite inicializar la fecha y la hora del sistema seg√∫n el valor de N0. Tiene la misma correspondencia que con la funci√≥n DATE.</p>
            <ul>
              <li>N0 es una num√©rica corta.</li>
              <li>A0 es una cadena de caracteres.</li>
              </ul>

            <table>
              <thead>
                <tr>
                  <th>N0</th>
                  <th>Acci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>1</td>
                  <td>Inicializa el a√±o</td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>Inicializa el mes</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>Inicializa el n√∫mero del d√≠a en el mes</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>Inicializa el n√∫mero del d√≠a en el a√±o</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>Inicializa la hora</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>Inicializa los minutos</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>Inicializa los segundos</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>Inicializa las d√©cimas de segundos</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo</h4>
            <pre><code>DATE(1)="1987"      ; A√±o
DATE(2)="5"         ; Mayo
DATE(3)="6"         ; el 6
DATE(4)="126"       ; 126 d√≠a del a√±o</code></pre>

            <hr />

            <h4>DEFSEG - Definir Segmento CPU (Orden, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>DEFSEG [ = N1 ]</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta orden permite inicializar el n√∫mero de segmento del CPU (8086) (NO el n√∫mero de segmento del BAL), que ser√° tomado en cuenta para las √≥rdenes y funciones <code>PEEK</code>, <code>POKE</code> y <code>CALL</code>.</p>
            <p>Si no se utiliza esta orden s√≥lo el DATA SEGMENT (DS) conteniendo las variables del programa BAL es accesible.</p>
            <p>N1 es un num√©rico corto (%), da el nuevo valor del DATA SEGMENT a utilizar por <code>PEEK</code>, <code>POKE</code> y <code>CALL</code>.</p>
            <p>Si no hay par√°metro N1 ni ejecuci√≥n de la orden <code>DEFSEG</code>, los <code>PEEK</code>, <code>POKE</code> y <code>CALL</code> que sigan, direccionar√°n el segmento (del 8086) conteniendo las variables del programa BAL.</p>
            <p>Se aconseja hacer, despu√©s de usarlo, reposicionar el segmento por defecto lo m√°s r√°pidamente posible por una orden <code>DEFSEG</code> sin par√°metro.</p>
            <p><b>Excepci√≥n:</b> La orden <code>CALL</code> como direcci√≥n de sub-programa ensamblador, una variable no num√©rica corta, utiliza siempre el segmento por defecto (conteniendo las variables BAL).</p>
            <p><b>La inicializaci√≥n del segmento por defecto no se efect√∫a m√°s que en los lugares siguientes:</b></p>
            <ul>
              <li>Principio de un programa</li>
              <li>Encadenamiento de un programa</li>
              <li><code>DEFSEG</code> sin par√°metro</li>
              </ul>

            <hr />

            <h4>INP - Entrada Directa (Orden, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>INP N0V , N1ADR</code></pre>

            <h4>Definici√≥n</h4>
            <pre><code>( N1ADR ) --&gt; N0V</code></pre>

            <p>Esta orden transfiere en la variable num√©rica corta N0V, el contenido de la conexi√≥n de entrada directa cuya direcci√≥n es N1ADR.</p>
            <p>N1ADR es una num√©rica corta.</p>
            <hr />

            <h4>OUT - Salida Directa (Orden, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>OUT N0 , N1ADR</code></pre>

            <h4>Definici√≥n</h4>
            <pre><code>N0 --&gt; ( N1ADR )</code></pre>

            <p>Esta orden transfiere el valor del num√©rico corto N0 a la conexi√≥n de salida directa cuya direcci√≥n es N1ADR.</p>
            <p>N1ADR es una num√©rica corta.</p>
            <hr />

            <h4>PEEK - Lectura Memoria (Funci√≥n, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>N0V = PEEK ( N1ADR )
; o
PEEK ( N1ADR )</code></pre>

            <h4>Definici√≥n</h4>
            <pre><code>( N1ADR ) --&gt; N0V
; o
( N1ADR ) --&gt;</code></pre>

            <p>Da el contenido del octeto de memoria cuya direcci√≥n en el segmento (DS) es N1ADR. El n√∫mero del segmento utilizado es dado por <code>DEFSEG</code>. Por defecto, el segmento de las variables BAL es utilizado.</p>
            <ul>
              <li>El resultado es un num√©rico corto.</li>
              <li>N1ADR es un num√©rico corto de dos octetos a priori.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>FIELD=M
dcl TEXTO$=55 , N1ADR% , N0V#
.
DEFSEG                      ; por prudencia, para direccionar variables BAL
N1ADR= VPTR ( TEXTO )       ; da N1ADR = direcci√≥n del 1er. octeto de la
;                           ; variable TEXTO.
N0V = PEEK ( N1ADR )        ; da N0V = el primer car√°cter de TEXTO</code></pre>

            <hr />

            <h4>POKE - Escritura Memoria (Funci√≥n, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>N1ADR = POKE ( N0 )</code></pre>

            <h4>Definici√≥n</h4>
            <pre><code>N0 --&gt; ( N1ADR )</code></pre>

            <p>Escribe el valor del num√©rico corto N0, en el octeto memoria cuya direcci√≥n en el segmento (DS) es N1ADR.</p>
            <p>El segmento usado es definido por <code>DEFSEG</code>, si no, el segmento de variables BAL se utiliza.</p>
            <p>N1ADR es una variable num√©rica corta que indica la direcci√≥n.</p>
            <p>Despu√©s de una escritura (<code>POKE</code>) el contenido de la variable BAL N1ADR no es modificada.</p>
            <p><b>Nota:</b> Esta funci√≥n no puede aparecer en una expresi√≥n, no puede ser utilizada m√°s que en una orden de afectaci√≥n.</p>
            <h4>Ejemplo</h4>
            <pre><code>FIELD=M
dcl TEXTO$=55 , N1ADR% , N0#
.
DEFSEG              ; por prudencia, para direccionar las variables BAL
N1ADR= VPTR ( TEXTO )
N1ADR= POKE ( /41 ) ; Escribe /41 ( "A" ) en el primer octeto de TEXTO</code></pre>

            <hr />

            <h4>VPTR - Direcci√≥n de Variable (Funci√≥n, Opci√≥n PS)</h4>
            <h4>Sintaxis</h4>
            <pre><code>VPTR( V0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Da la direcci√≥n del primer octeto de la variable V0.</p>
            <p>V0 es una variable declarada en memoria.</p>
            <p>El resultado es un num√©rico corto.</p>
            <h4>Ejemplo</h4>
            <pre><code>FIELD=M
dcl TEXTO$=55
dcl N1ADR%
.
N1ADR= VPTR ( TEXTO )       ; da N1ADR = direcci√≥n del primer octeto de
;                           ; la variable TEXTO.</code></pre>

            <hr />

            <h3>Funciones y √ìrdenes Generales</h3>

            <h4>COL - N√∫mero de Columna (Funci√≥n)</h4>
            <h4>Sintaxis</h4>
            <pre><code>COL [ ( N0 ) ]</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta funci√≥n da un num√©rico corto cuyo valor es igual al n√∫mero de la columna del pr√≥ximo car√°cter a escribir.</p>
            <p>Ser√° 1 a 80 para la pantalla y 1 a 132 para una impresora, en general.</p>
            <p>N0 es un num√©rico corto que designa el perif√©rico donde se va a leer la posici√≥n del "punto de escritura" (cursor).</p>
            <ul>
              <li>Si N0 = 1, o por falta de par√°metro (N0), se designa la pantalla.</li>
              <li>Si N0 = 2 a 32, N0 designa la impresora asignada cuyo n√∫mero l√≥gico es N0.</li>
              <li>N0 = 2 designa la impresora impl√≠cita, por defecto.</li>
              </ul>

            <hr />

            <h4>LIN - N√∫mero de L√≠nea (Funci√≥n)</h4>
            <h4>Sintaxis</h4>
            <pre><code>LIN [ ( N0 ) ]</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta funci√≥n da un num√©rico corto cuyo valor es igual al n√∫mero de la l√≠nea del pr√≥ximo car√°cter a escribir.</p>
            <p>Ser√° 1 a 24 para la pantalla y 1 a 66 para una impresora, en general.</p>
            <p>N0 es un num√©rico corto que designa el perif√©rico donde se va a leer la posici√≥n del "punto de escritura" (cursor).</p>
            <ul>
              <li>Si N0 = 1, o por falta de par√°metro (N0), se designa la pantalla.</li>
              <li>Si N0 = 2 a 32, N0 designa la impresora asignada cuyo n√∫mero l√≥gico es N0.</li>
              <li>N0 = 2 designa la impresora impl√≠cita, por defecto.</li>
              </ul>

            <h4>Ejemplo</h4>
            <p>Escribir un mensaje en la l√≠nea 24 sin desplazar el cursor aparentemente:</p>
            <pre><code>dcl COLUMNA%        ; para almacenar el n√∫mero de COLumna.
dcl LINEA%          ; para almacenar el n√∫mero de L√çNea.
.
COLUMNA= COL        ; da COLUMNA = n√∫mero de columna actual de la pantalla
LINEA  = LIN        ; da LINEA   = n√∫mero de l√≠nea actual de la pantalla
*
print=1:TAB( 1 , 24 ) , "Mensaje "  ; Escribe Mensaje en l√≠nea 24, columna 1
print=1:TAB( COLUMNA , LINEA )      ; restablece el cursor a su posici√≥n
;                                   ; precedente.</code></pre>

            <hr />

            <h4>Advertencias sobre COL y LIN</h4>
            <p>Al cargar el sistema <code>COL(_)</code> y <code>LIN(_)</code> tienen cualquier valor. Son inicializados por: <code>CLEAR</code>, <code>PAGE</code>, <code>HOME</code>, <code>TAB(_,_)</code></p>
            <p><b>Para tener un funcionamiento correcto de estas funciones es preciso:</b></p>
            <ul>
              <li>De una parte que todas las ediciones pantalla y/o impresora se hagan exclusivamente por √≥rdenes <code>ASK=</code>, <code>PRINT=</code>, <code>PAUSE</code>. El uso de: <code>DBUG</code>, de sub-programas ensamblador, o utilitarios cargados por <code>LOAD.GO=</code>, y que utilizan la pantalla y/o la impresora destruyen <code>COL(_)</code> y <code>LIN(_)</code>.</li>
              </ul>

            <ul>
              <li>Por otra parte no hay que enviar a la pantalla y/o impresora caracteres que desplacen el cursor una posici√≥n a la derecha, a excepci√≥n de los caracteres: &lt;- (Flecha a izda.), LF (Line Feed). Es preciso utilizar las tabulaciones del BAL para hacerlo.</li>
              </ul>

            <p><b>Nota:</b> Cuando se lanza la ejecuci√≥n de un programa BAL que contiene la opci√≥n <code>NOCLR</code>, sea por <code>EX</code>, <code>LOAD.GO=</code> o <code>CHAIN=</code>, la posici√≥n del cursor se transmite. Las funciones <code>LIN</code> y <code>COL</code> dan entonces los valores correctos.</p>
            <hr />

            <h4>CONF - Configuraci√≥n del Sistema (Funci√≥n)</h4>
            <h4>Sintaxis</h4>
            <pre><code>CONF ( N0 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta funci√≥n da un num√©rico corto que depende del valor de N0.</p>
            <p>N0 es un num√©rico corto.</p>
            <table>
              <thead>
                <tr>
                  <th>N0</th>
                  <th>Resultado</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>1</td>
                  <td>N√∫mero de l√≠neas de la pantalla</td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>N√∫mero de columnas de una l√≠nea de la pantalla</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>N√∫mero de l√≠neas por p√°gina de la impresora est√°ndar</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>N√∫mero de columnas de una l√≠nea de la impresora est√°ndar</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>0 si la lengua de edici√≥n es franc√©s, 1 si es ingl√©s</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>N√∫mero de la versi√≥n de PROLOGUE</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>√çndice del n√∫mero de versi√≥n de PROLOGUE</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>Bits de protecci√≥n del sistema (ver detalle abajo)</td>
                </tr>
                <tr>
                  <td>9</td>
                  <td>N√∫mero de teclas de funci√≥n programables del teclado (11 en est√°ndar, n√∫mero /80 (128) y siguientes)</td>
                </tr>
              </tbody>
            </table>

            <p><b>Bits de protecci√≥n del sistema (N0=8):</b></p>
            <p>Se devuelve en 8 bits si N0 es un num√©rico de 1 octeto, en 16 bits si N0 es un num√©rico de 2 octetos. Un bit a 1 significa: autorizado.</p>
            <ul>
              <li><b>Bit 0:</b> Salvaguardia: CPS total, CP,CV; CP,DV; CP,RV</li>
              <li><b>Bit 1:</b> Escritura formato libre: PATCH, CPS parcial, IO=</li>
              <li><b>Bit 2:</b> Opci√≥n PS autorizada: PEEK, POKE, VPTR, LOAD, CALL, IO=, DATE(.)=, Variable en acceso directo</li>
              <li><b>Bit 3:</b> Configuraci√≥n ulterior por CF90..</li>
              <li><b>Bit 4:</b> Formato 8+3 para los nombres de ficheros</li>
              <li><b>Bit 5:</b> Traducci√≥n y DeBug autorizado</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>dcl NMAX%
.
NMAX= CONF ( 3 )    ; da NMAX= el n√∫mero de l√≠neas por p√°gina de la impr.</code></pre>

            <hr />

            <h4>KBF - Programaci√≥n de Teclas de Funci√≥n (Orden)</h4>
            <h4>Sintaxis</h4>
            <pre><code>KBF( N1 ) = A1</code></pre>

            <h4>Definici√≥n</h4>
            <p>N1 es un num√©rico corto (# %) que indica el n√∫mero de la tecla de funci√≥n a programar. El n√∫mero de la primera tecla de funci√≥n (F1) es 128 (o /80). Las teclas siguientes, hasta F11, llevan los n√∫meros siguientes 129 (o /81), 130 (o /82), ...</p>
            <p>A1 es la cadena de caracteres a asociar a la tecla de funci√≥n cuyo n√∫mero es N1. Los blancos al fin de la cadena A1 no son tomados en cuenta.</p>
            <p>La suma de los n√∫meros asociados a las teclas de funci√≥n programables est√° limitada a 256 por puesto de trabajo.</p>
            <p><b>Errores posibles:</b></p>
            <ul>
              <li><b>56:</b> El ejecutor no soporta la orden KBF (versi√≥n inferior a la 4.6a).</li>
              <li><b>111:</b> El n√∫mero de la tecla de funci√≥n es desconocido.</li>
              </ul>

            <p>Los valores programados est√°n activos hasta una nueva programaci√≥n, o hasta una reinicializaci√≥n del sistema.</p>
            <p>A partir de PROLOGUE 2.1b los valores por defecto de las teclas de funci√≥n son: /80 o 128 para F1, /81 para F2, /83 para F3, etc.</p>
            <h4>Ejemplo</h4>
            <pre><code>KBF(/80)=chr$(/91)                  ; F1 = como valor /91
KBF(/81)="/,FL1,GR"+chr$(/0D)       ; Comando y validaci√≥n ( CR/ENTER )</code></pre>

            <hr />

            <h4>KBF - Lectura de Teclas de Funci√≥n (Funci√≥n)</h4>
            <h4>Sintaxis</h4>
            <pre><code>KBF( N1 )</code></pre>

            <h4>Definici√≥n</h4>
            <p>N1 es un num√©rico corto (# %) que indica el n√∫mero de la tecla de funci√≥n a leer. El n√∫mero de la primera tecla de funci√≥n (F1) es 128 (o /80). Las teclas siguientes, hasta F11, llevan los n√∫meros siguientes 129 (o /81), 130 (o /82), ...</p>
            <p>El resultado es una cadena de caracteres que contiene, cuadrada a la izquierda, el o los caracteres asociados a la tecla cuyo n√∫mero es N1. El fin de la cadena de recepci√≥n es puesto a blancos, si el n√∫mero de caracteres asociados a la tecla de funci√≥n es m√°s peque√±o que la cadena resultado.</p>
            <p><b>Nota:</b> Esta funci√≥n no puede ser utilizada en una expresi√≥n.</p>
            <p><b>Errores posibles:</b></p>
            <ul>
              <li><b>56:</b> El ejecutor no soporta la orden KBF (versi√≥n inferior a la 4.6a).</li>
              <li><b>111:</b> El n√∫mero de la tecla de funci√≥n es desconocido.</li>
              <li><b>122:</b> La cadena de recepci√≥n es demasiado corta para recibir la cadena completa asociada a la tecla de funci√≥n. Hay p√©rdida de informaci√≥n, s√≥lo los primeros caracteres se transfieren a la cadena resultado.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>dcl A1$             ; cadena de 15 octetos (caracteres)
.
A1=KBF(128)         ; lectura de la tecla 128 (tecla F1)</code></pre>

            <hr />

            <h4>PAUSE - Espera del Operador (Orden)</h4>
            <h4>Sintaxis</h4>
            <pre><code>PAUSE V0</code></pre>

            <h4>Definici√≥n</h4>
            <p>Durante la ejecuci√≥n de esta orden el valor de V0 es mostrado en la pantalla, en la posici√≥n actual del cursor.</p>
            <p>Despu√©s el sistema espera que el operador teclee la validaci√≥n (CR/ENTER) para continuar la ejecuci√≥n del programa, y el cursor pasa al principio de la l√≠nea siguiente.</p>
            <p>V0 puede ser una constante, una variable o una expresi√≥n.</p>
            <p>Se puede as√≠ pedir al operador cambiar de disquete (despu√©s de cerrar los ficheros) y esperar su se√±al (la validaci√≥n) para proseguir la ejecuci√≥n.</p>
            <h4>Ejemplo</h4>
            <pre><code>PAUSE " Validar para continuar"     ; Este mensaje se muestra en pantalla
;           despu√©s de la validaci√≥n el programa proseguir√° la ejecuci√≥n.</code></pre>

            <hr />

            <h4>PROCESS - N√∫mero del Puesto (Orden)</h4>
            <h4>Sintaxis</h4>
            <pre><code>PROCESS N0V</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta orden da, en la variable num√©rica corta N0, el n√∫mero del puesto de trabajo que ejecuta el programa.</p>
            <ul>
              <li>Para un monopuesto el n√∫mero del puesto es siempre cero.</li>
              <li>En un 90-50 se obtienen N0V = 0, 1, 2, 3 para los puestos 0, 1, 2, 3</li>
              <li>En un S.P.R. se obtienen N0V = 8, 16, 24, ... para los puestos conectados en las l√≠neas: 0, 1, 2 etc.</li>
              </ul>

            <p>N0V = (N√∫mero de l√≠nea + 1) multiplicado por 8 (m√°s el n√∫mero del puesto del terminal que es siempre cero).</p>
            <p>Esto puede permitir, por testeo, prohibir la ejecuci√≥n de este programa seg√∫n el n√∫mero del puesto de trabajo. Por ejemplo el puesto del vendedor no puede ejecutar el programa PAGOS.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl N0V#
.
PROCESS N0V         ; da N0V = el n√∫mero del puesto.
IF N0V&lt;&gt;0 GOTO 9999 ; si N0V es distinto de cero ir a 9999.</code></pre>

            <hr />

            <h4>PROCESS - N√∫mero del Puesto (Funci√≥n)</h4>
            <h4>Sintaxis</h4>
            <pre><code>PROCESS</code></pre>

            <h4>Definici√≥n</h4>
            <p>Esta funci√≥n es equivalente a la orden <code>PROCESS N0V</code>, pero el resultado no es puesto en una variable.</p>
            <h4>Ejemplo</h4>
            <pre><code>.
IF PROCESS&lt;&gt;0 GOTO 9999     ; Si el puesto no es cero ir a 9999</code></pre>

            <hr />

            <h4>WAIT - Espera N0 Segundos (Orden)</h4>
            <h4>Sintaxis</h4>
            <pre><code>WAIT N0</code></pre>

            <h4>Definici√≥n</h4>
            <p>Durante la ejecuci√≥n de esta orden el sistema espera N0 segundos antes de ejecutar la orden siguiente.</p>
            <p>Permite mostrar un mensaje durante un cierto tiempo, antes de borrarlo.</p>
            <p>N0 es un num√©rico corto positivo.</p>
            <h4>Ejemplo</h4>
            <pre><code>WAIT 3      ; espera 3 segundos antes de ejecutar la orden siguiente</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 7: Las Rupturas de Secuencias</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <h4>Desv√≠os</h4>
            <ul>
              <li><code>GOTO Etiqu</code> - Salto incondicional</li>
              <li><code>ON Exp.C√°lculo GOTO Etiqu1,Etiqu2,Etiqu3</code> - Salto seg√∫n signo</li>
              <li><code>OF Exp.C√°lculo GOTO Etiqu1,Etiqu2,...</code> - Salto seg√∫n valor</li>
              <li><code>IF Exp.Relaci√≥n GOTO Etiqu</code> - Salto condicional</li>
              <li><code>IF Exp.Relaci√≥n THEN Etiqu1 ELSE Etiqu2</code> - Bifurcaci√≥n</li>
              <li><code>IF...ELSE...ENDIF</code> - Bloque condicional</li>
              <li><code>OP Etiqu [,N1]</code> - Interrupci√≥n por operador</li>
              <li><code>STOP</code> - Parada de ejecuci√≥n</li>
              <li><code>CHAIN=Nlog</code> - Encadenamiento de programas</li>
              </ul>

            <h4>Bucles</h4>
            <ul>
              <li><code>FOR K1=K2 TO K3 [STEP K4]...NEXT K1</code> - Bucle con contador</li>
              <li><code>REPEAT...UNTIL Exp.Relaci√≥n</code> - Repetir hasta</li>
              <li><code>WHILE Exp.Relaci√≥n...WEND</code> - Mientras</li>
              </ul>

            <h4>Sub-Programas</h4>
            <ul>
              <li><code>GOSUB Etiqu</code> - Llamada sub-programa interno</li>
              <li><code>OF Exp.C√°lculo GOSUB Etiqu</code> - Llamada seg√∫n valor</li>
              <li><code>IF Exp.Relaci√≥n GOSUB Etiqu</code> - Llamada condicional</li>
              <li><code>RETURN</code> - Retorno de sub-programa</li>
              <li><code>LDGO.SEG Exp.C√°lculo</code> - Llamada a segmento</li>
              <li><code>RET.SEG</code> - Retorno de segmento</li>
              <li><code>CLOSE=0</code> - Cerrar fichero programa</li>
              <li><code>CALL VarDato,VarCod</code> - Llamada ensamblador</li>
              <li><code>ASSIGN=Nlog,"FICH"</code> - Asignaci√≥n de fichero</li>
              <li><code>LOAD=Nlog</code> - Carga en memoria</li>
              <li><code>LOAD.GO=Nlog</code> - Carga y ejecuci√≥n</li>
              </ul>

            <h4>Tratamiento de Errores</h4>
            <ul>
              <li><code>ON ERROR GOTO Etiqu,VarEr</code> - Gesti√≥n de errores</li>
              <li><code>ON ERROR ABORT</code> - Anular gesti√≥n errores</li>
              <li><code>RESUME [Etiqu]</code> - Reanudar tras error</li>
              </ul>

            <hr />

            <h3>Introducci√≥n</h3>

            <p>Despu√©s de ejecutar una instrucci√≥n, si no hay errores de ejecuci√≥n, y si no hay ruptura de secuencia, el sistema ejecuta la instrucci√≥n siguiente.</p>
            <hr />

            <h3>Desv√≠os</h3>

            <p>Un desv√≠o indica la etiqueta (n√∫mero o <code>&amp;Identificador</code> expresado por <code>Etiqu</code>) de la pr√≥xima instrucci√≥n a ejecutar.</p>
            <p>Una etiqueta <code>Etiqu</code> es un n√∫mero comprendido entre 1 y 9999, o bien un Identificador (1 a 8 letras) precedido de un <code>&amp;</code></p>
            <p>Las etiquetas no son conocidas m√°s que en el segmento donde son declaradas.</p>
            <p>Las instrucciones siguientes no son ejecutables, por tanto, no se puede hacer desv√≠os hacia ellas:</p>
            <ul>
              <li><code>PROGRAM " "</code></li>
              <li><code>FIELD=</code></li>
              <li><code>DCL</code></li>
              <li><code>SEGMENT</code></li>
              <li><code>INCLUDE "Fich"</code></li>
              <li><code>FMT</code></li>
              <li><code>END</code></li>
              </ul>

            <hr />

            <h4>GOTO Etiqu</h4>
            <h4>Sintaxis:</h4>
            <pre><code>GOTO Etiqu</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>GOTO &amp;CONT3
.
&amp;CONT3 I1=I1+1</code></pre>

            <hr />

            <h4>ON K1 GOTO Etiqu1, Etiqu2, Etiqu3</h4>
            <h4>Sintaxis:</h4>
            <pre><code>ON K1 GOTO Etiqu1, Etiqu2, Etiqu3</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>K1</code> es una expresi√≥n calculada num√©rica corta o larga.</p>
            <ul>
              <li>Si <code>K1</code> es negativo ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu1</code></li>
              <li>Si <code>K1</code> es nulo ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu2</code></li>
              <li>Si <code>K1</code> es positivo ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu3</code></li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>ON I1+2 goto &amp;NEGAT, &amp;NULO, &amp;POSIT  ; Ir a &amp;NEGAT si I1 &lt; 0
                                    ; Ir a &amp;NULO  si I1 = 0
                                    ; Ir a &amp;POSIT si I1 &gt; 0</code></pre>

            <hr />

            <h4>OF K1 GOTO Etiqu1, Etiqu2, ..., EtiquN</h4>
            <h4>Sintaxis:</h4>
            <pre><code>OF K1 GOTO Etiqu1 [, Etiqu2 ... [, EtiquN]]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>K1</code> es una expresi√≥n calculada num√©rica corta o larga.</p>
            <p>Si <code>K1</code> es un num√©rico largo, su valor es truncado en un entero.</p>
            <p>El valor de este num√©rico es entonces <code>I</code>:</p>
            <ul>
              <li>Si <code>1 &lt;= I &lt;= N</code>, hay ejecuci√≥n de la instrucci√≥n cuya etiqueta es <code>EtiquI</code>, es decir, la etiqueta que se encuentra en I-√©sima posici√≥n.</li>
              <li>Si <code>K1</code> es inferior a 1 o superior o igual a N+1, no hay desv√≠o de secuencia y se ejecuta la siguiente instrucci√≥n.</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>&amp;ELEGIR     ASK=1,I=9999:CLEAR," Elige una opci√≥n : "= OPCION

    ; La opci√≥n es introducida desde el teclado.

OF OPCION GOTO 1000,&amp;MOD,3000,4000  ; ir a  1000 si OPCION = 1
;                                     ir a  &amp;MOD si OPCION = 2
;                                     ir a  3000 si OPCION = 3
;                                     ir a  4000 si OPCION = 4
; Ejecuci√≥n en secuencia si OPCION &lt; 1 o si OPCION &gt;= 5
;

GOTO &amp;ELEGIR        ; respuesta diferente de 1, 2, 3, 4
.
1000 ...
.
&amp;MOD ...
.
3000 ...
.
4000 ...
.
9999 STOP</code></pre>

            <hr />

            <h4>IF Exp.Relaci√≥n GOTO Etiqu</h4>
            <h4>Sintaxis:</h4>
            <pre><code>IF Exp.Relaci√≥n GOTO Etiqu</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Exp.Relaci√≥n</code> es una expresi√≥n de relaci√≥n.</p>
            <p>Si la expresi√≥n de relaci√≥n es:</p>
            <ul>
              <li><b>VERDADERA</b>: ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu</code></li>
              <li><b>FALSA</b>: ejecutar la instrucci√≥n que sigue en secuencia</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>IF I1 &lt;&gt; J1 GOTO 50 ; Ejecutar la instrucci√≥n 50, si I1 es diferente de J1
;                     Si no, ejecutar la instrucci√≥n que sigue.</code></pre>

            <hr />

            <h4>IF Exp.Relaci√≥n THEN Etiqu1 ELSE Etiqu2</h4>
            <h4>Sintaxis:</h4>
            <pre><code>IF Exp.Relaci√≥n THEN Etiqu1 ELSE Etiqu2</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Exp.Relaci√≥n</code> es una expresi√≥n de relaci√≥n.</p>
            <p>Si la expresi√≥n de relaci√≥n es:</p>
            <ul>
              <li><b>VERDADERA</b>: ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu1</code></li>
              <li><b>FALSA</b>: ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu2</code></li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>IF N1 = 5 THEN &amp;VERD ELSE &amp;FALSO ; Ejecutar la instrucci√≥n &amp;VERD, si N1 = 5
;                                  Si no, ejecutar la instrucci√≥n &amp;FALSO</code></pre>

            <hr />

            <h4>IF...ELSE...ENDIF (Bloque condicional)</h4>
            <h4>Sintaxis:</h4>
            <pre><code>IF Exp.Relaci√≥n  [; comentario]
        Bloc1
[ELSE            [; comentario]
        Bloc2]
ENDIF            [; comentario]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Exp.Relaci√≥n</code> es una expresi√≥n de relaci√≥n.</p>
            <p><code>Bloc1</code> es una sucesi√≥n de instrucciones a ejecutar si la expresi√≥n de relaci√≥n es <b>VERDADERA</b>.</p>
            <p><code>Bloc2</code> es una sucesi√≥n de instrucciones a ejecutar si la expresi√≥n de relaci√≥n es <b>FALSA</b>. La parte <code>ELSE Bloc2</code> es opcional.</p>
            <p>El n√∫mero de instrucciones de un bloque es ilimitado y se pueden encajonar IF hasta 16 niveles.</p>
            <h4>Sintaxis simplificada:</h4>
            <p>Para el caso donde solo hay una orden al ejecutor si la condici√≥n es verdadera:</p>
            <pre><code>IF Exp.Relaci√≥n : Orden [; Comentario]</code></pre>

            <p>En este √∫ltimo caso, la orden no puede ser un principio o un fin de estructura compuesta. Las palabras claves siguientes est√°n prohibidas: <code>FOR</code>, <code>NEXT</code>, <code>IF</code>, <code>ELSE</code>, <code>ENDIF</code>, <code>REPEAT</code>, <code>UNTIL</code>, <code>WHILE</code>, <code>WEND</code> y <code>ESEG</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>IF CANTIDAD &lt;= 50           ; Seg√∫n la cantidad
    DESCUENTO=15            ; para una peque√±a cantidad el DESCUENTO=15 %
    TIPOPAQUETE=1           ; el paquete es de tipo 1

ELSE                        ; Para una cantidad superior
    DESCUENTO=25            ; el descuento es del 25%
    TIPOPAQUETE=2           ; y el paquete es de tipo 2
ENDIF</code></pre>

            <hr />

            <h4>OP Etiqu [,N1]</h4>
            <h4>Sintaxis:</h4>
            <pre><code>OP Etiqu [, N1]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Etiqu</code> es una etiqueta de instrucci√≥n. <code>N1</code> es una variable num√©rica corta.</p>
            <ul>
              <li>Si antes de la ejecuci√≥n de esta orden, ning√∫n car√°cter es tecleado por el operador, hay ejecuci√≥n de la instrucci√≥n que sigue en secuencia y si el par√°metro <code>N1</code> existe, esta variable tiene el valor cero.</li>
              <li>Si antes de la ejecuci√≥n de esta orden se teclea cualquier car√°cter por el operador, hay ejecuci√≥n de la instrucci√≥n cuya etiqueta es <code>Etiqu</code> y:</li>
              <ul>
                <li>Si el par√°metro <code>N1</code> existe, el car√°cter tecleado se lee y el valor decimal de su c√≥digo (ASCII a priori) se pone en la variable <code>N1</code>. El car√°cter tecleado no aparece en pantalla.</li>
                <li>Si el par√°metro <code>N1</code> no existe, el car√°cter tecleado no es le√≠do. Ser√° le√≠do por la pr√≥xima orden de acceso al teclado, <code>ASK=1:=...</code> u otro <code>OP</code>.</li>
                </ul>
              </ul>

            <p>Esta orden permite al operador suspender un trabajo en curso.</p>
            <h4>Ejemplo:</h4>
            <pre><code>program "ejemplo"
DCL N1#
.
segment 0
.
1000 DOWN=1:C1,31   ; Leer el registro siguiente de un fichero
     PRINT=1:...    ; Editar el registro

     OP 1500,N1     ; Si accede el OPerador al teclado IR a 1500
                    ; y poner el c√≥digo en N1

1100 GOTO 1000      ; Contin√∫a la lectura


1500 IF N1=/1B then 9999 else 1000  ; Fin si ESCape ( /1B )
                                    ; si no, continuar leyendo
.
.
9999 STOP           ; Fin de ejecuci√≥n del programa.</code></pre>

            <hr />

            <h4>STOP</h4>
            <h4>Sintaxis:</h4>
            <pre><code>STOP</code></pre>

            <h4>Definici√≥n:</h4>
            <p>Esta orden provoca la parada de la ejecuci√≥n del programa BAL en curso. Ocurre entonces:</p>
            <ul>
              <li>Cierre de todos los n√∫meros l√≥gicos asignados en BAL, cierre de los ficheros BAL y liberaci√≥n de los soportes abiertos en exclusividad (liberaci√≥n de la o las impresoras reservadas, etc.).</li>
              <li>Encadenamiento de un programa BAL si ha sido pedido, o bien reenv√≠o al sistema PROLOGUE y espera de un comando operador <code>-&gt;</code></li>
              </ul>

            <p><b>Nota:</b> Esta orden puede ser puesta en cualquier segmento o sub-programa. Todo programa deber√≠a tener un STOP para parar la ejecuci√≥n. La ejecuci√≥n de las √≥rdenes <code>ESEG c</code> y <code>DATA</code> provocan la ejecuci√≥n de un STOP.</p>
            <h4>Ejemplo:</h4>
            <pre><code>.
9999 STOP           ; Fin de ejecuci√≥n del programa en curso</code></pre>

            <hr />

            <h4>CHAIN=Nlog</h4>
            <h4>Sintaxis:</h4>
            <pre><code>CHAIN=NLOG [,"par√°metros"] [:Aerr, E0]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>NLOG</code> es un num√©rico corto llamado n√∫mero l√≥gico cuyo valor est√° comprendido entre 1 y 32.</p>
            <p><code>"par√°metros"</code> es una cadena que contiene los par√°metros a pasar si el programa ha declarado una variable por <code>ARG</code>, para recibir dichos par√°metros.</p>
            <p>Una Orden <code>ASSIGN=NLOG,"Fich" [:Aerr, E0]</code>:</p>
            <ul>
              <li>Cierra el Fichero (o libera el Soporte) correspondiente a <code>NLOG</code> si este valor de n√∫mero l√≥gico ha sido utilizado.</li>
              <li>Asocia a <code>NLOG</code> el fichero cuyo nombre es <code>"Fich"</code>. <code>"Fich"</code> es una cadena de caracteres variable o constante.</li>
              </ul>

            <p>Solo los errores 30 y 31 pueden ocurrir (Soporte o n√∫mero de unidad desconocido).</p>
            <p>Cuando la ejecuci√≥n del programa en curso se termine por medio de un <code>STOP</code>, el espacio de memoria ocupado por el programa es liberado, el programa BAL asignado al n√∫mero l√≥gico <code>NLOG</code> ("Fich") ser√° lanzado en ejecuci√≥n, es decir, que un comando <code>-&gt; EX,Fichv</code> ser√° simulado.</p>
            <p>La orden <code>CHAIN=</code> precedente ser√° anulada, si hab√≠a sido ejecutada.</p>
            <p><code>CHAIN=0</code> anula todo encadenamiento (orden <code>CHAIN=</code>) precedente.</p>
            <p>Si el fichero programa a encadenar no existe, ocurre un error 40. Esto √∫ltimo se puede gestionar por <code>ON ERROR GOTO Aerr,E0</code>. Si surge el error, para anularlo, es preciso encadenar a otro programa o ejecutar un <code>CHAIN=0</code> para anular todo encadenamiento.</p>
            <h4>Ejemplo:</h4>
            <pre><code>ASSIGN=3,"PAGOS"
CHAIN=3
.
STOP                ; Cierra los N√∫meros L√≥gicos BAL, libera la impresora
                    ; Ejecuta  -&gt; EX,PAGOSv</code></pre>

            <hr />

            <h3>Bucles</h3>

            <h4>FOR...NEXT</h4>
            <h4>Sintaxis:</h4>
            <pre><code>FOR K1 = K2 TO K3 [STEP K4]
    .
    .
NEXT K1</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>K1</code> es una variable num√©rica corta o larga.</p>
            <p><code>K2</code>, <code>K3</code>, <code>K4</code> son num√©ricos del mismo tipo que <code>K1</code> (Constantes, variables o expresiones de c√°lculo).</p>
            <p><code>K1</code> se llama <b>√çNDICE</b> del bucle.</p>
            <p><code>K4</code> es el paso de incremento, por defecto de <code>STEP K4</code>, el valor uno es usado (<code>K4=1</code>). El valor cero est√° prohibido como paso de incremento.</p>
            <p>Cuando la orden <code>FOR K1</code> se ejecuta desde <code>K1 = K2</code>, el sistema ejecuta las instrucciones comprendidas entre <code>FOR K1</code> y <code>NEXT K1</code>.</p>
            <p>Cuando la orden <code>NEXT K1</code> se ejecuta el sistema hace <code>K1 = K1 + K4</code>.</p>
            <p>Despu√©s si <code>K4</code> es positivo:</p>
            <ul>
              <li>El sistema ejecuta la instrucci√≥n siguiente a <code>FOR K1</code>, si <code>K1 &lt;= K3</code></li>
              <li>El sistema ejecuta la instrucci√≥n siguiente a <code>NEXT K1</code>, si <code>K1 &gt; K3</code></li>
              </ul>

            <p>Despu√©s si <code>K4</code> es negativo:</p>
            <ul>
              <li>El sistema ejecuta la instrucci√≥n siguiente a <code>FOR K1</code>, si <code>K1 &gt;= K3</code></li>
              <li>El sistema ejecuta la instrucci√≥n siguiente a <code>NEXT K1</code>, si <code>K1 &lt; K3</code></li>
              </ul>

            <p>Sean cual sean <code>K2</code>, <code>K3</code>, <code>K4</code> el bucle <code>FOR...NEXT</code> se ejecuta al menos una vez.</p>
            <p>Al salir del bucle se toma como valor del √≠ndice (<code>K1</code>) el pr√≥ximo valor que tendr√≠a si se hubiera hecho una vuelta m√°s en el bucle.</p>
            <p>Se pueden tener bucles encajados los unos en los otros, pero un bucle incluido en otro no puede tener el mismo √≠ndice de bucle (aqu√≠ <code>K1</code>) que un bucle de nivel superior. El n√∫mero de niveles de bucles encajados es ilimitado.</p>
            <p>Se tiene que ejecutar un bucle comenzando por la orden <code>FOR</code>, est√° prohibido ejecutar una orden <code>NEXT</code> si la orden <code>FOR</code> correspondiente no ha sido hecha.</p>
            <p><b>Nota:</b> <code>K1</code>, <code>K2</code>, <code>K3</code>, <code>K4</code> pueden ser usados en el interior del bucle. Se puede salir de un bucle por una ruptura de secuencia sin salir por la orden <code>NEXT</code>, el √≠ndice (<code>K1</code>) conserva entonces su valor en curso.</p>
            <h4>Ejemplo:</h4>
            <pre><code>DCL I1#
.
FOR     I1= 1 to 4  ; Edita   1  2  3  4  en pantalla
print=1:I1
NEXT    I1</code></pre>

            <hr />

            <h4>REPEAT...UNTIL</h4>
            <h4>Sintaxis:</h4>
            <pre><code>REPEAT                [; comentario]
    Bloque de instrucciones
UNTIL Exp.Relaci√≥n    [; comentario]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Exp.Relaci√≥n</code> es una expresi√≥n de relaci√≥n.</p>
            <p><code>Bloque de instrucciones</code> es una sucesi√≥n de instrucciones que ser√°n ejecutadas hasta que la expresi√≥n de relaci√≥n sea <b>VERDADERA</b>.</p>
            <p>Es ejecutado al menos una vez.</p>
            <h4>Ejemplo:</h4>
            <pre><code>I=0
REPEAT              ; transferir la tabla T(I) en M(I)
    I=I+1
    M(I)=T(I)
UNTIL T(I)=0        ; hasta el √∫ltimo elemento cuyo valor es cero.</code></pre>

            <hr />

            <h4>WHILE...WEND</h4>
            <h4>Sintaxis:</h4>
            <pre><code>WHILE Exp.Relaci√≥n    [; comentario]
    Bloque de instrucciones
WEND                  [; comentario]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Exp.Relaci√≥n</code> es una expresi√≥n de relaci√≥n.</p>
            <p><code>Bloque de instrucciones</code> es una sucesi√≥n de instrucciones que ser√°n ejecutadas mientras la expresi√≥n de relaci√≥n sea <b>VERDADERA</b>.</p>
            <p>Eventualmente no es ejecutada del todo.</p>
            <h4>Ejemplo:</h4>
            <pre><code>I=1
WHILE T(I)&lt;&gt;0       ; transferir la tabla T(I) en M(I)
    M(I)=T(I)
    I=I+1           ; hasta el √∫ltimo elemento
WEND                ; cuyo valor es cero</code></pre>

            <hr />

            <h3>Sub-Programas</h3>

            <p>Un sub-programa es una sucesi√≥n de instrucciones que se ejecutan despu√©s de una orden de llamada de sub-programa (<code>GOSUB</code>, <code>LDGO.SEG n</code>, <code>CALL</code>) y que se termina por una orden de vuelta de sub-programa (<code>RETURN</code>, <code>RET.SEG</code>, <code>RET Far</code>). Un sub-programa no debe ser ejecutado en la secuencia del programa.</p>
            <p>Un sub-programa puede tener llamadas a otros sub-programas; el n√∫mero de niveles de sub-programas incluidos los unos en los otros es de 16.</p>
            <h4>Tipos de sub-programas en BAL</h4>
            <ul>
              <li><b>Sub-programas BAL internos:</b> escritos en BAL e incluidos en un segmento, se llaman por un <code>GOSUB</code> y se terminan con un <code>RETURN</code>.</li>
              <li><b>Sub-programas BAL externos (segmentos):</b> escritos en lenguaje BAL y puestos en el mismo programa BAL, en cualquier orden. Comienzan por <code>SEGMENT c</code> y terminan por <code>ESEG c</code>, se les llama por <code>LDGO.SEG n</code> y se terminan por un <code>RET.SEG</code>.</li>
              <li><b>Sub-programas Ensamblador:</b> escritos en lenguaje ensamblador, se cargan por <code>LOAD</code> y se llaman por un <code>CALL</code>, o bien son cargados y ejecutados por un <code>LOAD.GO=</code>, se terminan por un <code>RET Far</code>.</li>
              <li><b>Utilitarios de PROLOGUE y programas BAL:</b> Los utilitarios de PROLOGUE (de tipo -X) as√≠ como los programas escritos en BAL (de tipo -T) pueden ser cargados y ejecutados como si se trataran de sub-programas. Se cargan y ejecutan por <code>LOAD.GO=</code>. Para un programa BAL es preciso precisar su tipo (-T) en la asignaci√≥n (<code>ASSIGN=</code>).</li>
              </ul>

            <h4>Diagrama de flujo de Sub-Programas</h4>
            <pre><code>    Programa  Principal
            |
            V
            |
      Llamada de S/P -----&gt;-------&gt;---&gt; Sub- Programa
     ,----&gt; |                               |
     |      |                               V
     |      |                               |
     |   contin√∫a                           |
     |                                  Vuelta de S/P -
     |                                                |
     '-------------&lt;---------------&lt;-------------&lt;----'</code></pre>

            <hr />

            <h4>Sub-Programa Interno en un Segmento</h4>
            <p>Est√° contenido en el segmento llamado. Para que no sea ejecutado en secuencia debe ser escrito despu√©s de una orden de ruptura de secuencia incondicional (<code>STOP</code>, <code>GOTO</code> o <code>RETURN</code> por ejemplo).</p>
            <p>Empieza por una etiqueta que permitir√° la llamada, y se termina por <code>RETURN</code>.</p>
            <h4>GOSUB Etiqu</h4>
            <h5>Sintaxis:</h5>
            <pre><code>GOSUB Etiqu</code></pre>

            <h5>Definici√≥n:</h5>
            <p><code>GOSUB</code> es una orden de llamada de sub-programa interno del segmento en curso, <code>Etiqu</code> es la etiqueta de la primera instrucci√≥n del sub-programa a ejecutar.</p>
            <h5>Ejemplo:</h5>
            <pre><code>     GOSUB &amp;MUL             ; Llamada del S/P comenzando en &amp;MUL
     -                      ; Secuencia de ejecuci√≥n despu√©s del S/P
     -
     STOP                   ; Fin del programa principal

&amp;MUL X=Y*Z                  ; Principio del S/P
     -
     RETURN                 ; Fin del S/P</code></pre>

            <hr />

            <h4>OF K1 GOSUB Etiqu1, Etiqu2, ..., EtiquN</h4>
            <h5>Sintaxis:</h5>
            <pre><code>OF K1 GOSUB Etiqu1 [, Etiqu2 ... [, EtiquN]]</code></pre>

            <h5>Definici√≥n:</h5>
            <p><code>K1</code> es una expresi√≥n num√©rica corta o larga. Si <code>K1</code> es un num√©rico largo, su valor es truncado en un entero.</p>
            <p>El valor de este num√©rico le llamamos <code>I</code>:</p>
            <ul>
              <li>Si <code>1 &lt;= I &lt;= N</code>, hay una llamada al sub-programa que comienza por la instrucci√≥n cuya etiqueta es <code>EtiquI</code>, es decir, la etiqueta que se encuentra en I-√©sima posici√≥n.</li>
              <li>Si no, hay ejecuci√≥n de la instrucci√≥n que sigue en secuencia, es decir, si <code>K1</code> es inferior a 1, o superior o igual a N+1.</li>
              </ul>

            <p>Cuando una orden <code>RETURN</code> sea ejecutada, el sistema ejecutar√° la orden que siga a la √∫ltima llamada de sub-programa ejecutada (<code>OF..GOSUB..</code> por ejemplo).</p>
            <h5>Ejemplo:</h5>
            <pre><code>OF OPCION GOSUB 1000,&amp;MOD,3000      ; Llamada del S/P 1000 si OPCION=1
                                    ; Llamada del S/P &amp;MOD si OPCION=2
                                    ; Llamada del S/P 3000 si OPCION=3
                                    ; si no, ejecuci√≥n en secuencia</code></pre>

            <hr />

            <h4>IF Exp.Relaci√≥n GOSUB Etiqu</h4>
            <h5>Sintaxis:</h5>
            <pre><code>IF Exp.Relaci√≥n GOSUB Etiqu</code></pre>

            <h5>Definici√≥n:</h5>
            <p><code>Exp.Relaci√≥n</code> es una expresi√≥n de relaci√≥n.</p>
            <p>Si la expresi√≥n de relaci√≥n es:</p>
            <ul>
              <li><b>VERDADERA</b>: hay una llamada del sub-programa que comienza por la etiqueta <code>Etiqu</code></li>
              <li><b>FALSA</b>: ejecutar la instrucci√≥n que sigue en la secuencia</li>
              </ul>

            <h5>Ejemplo:</h5>
            <pre><code>IF I1 &lt;&gt; J1 GOSUB 5000 ; Llamada del S/P 5000, si I1 es diferente de J1
;                       Si no, ejecutar la instrucci√≥n que sigue.</code></pre>

            <hr />

            <h4>RETURN</h4>
            <h5>Sintaxis:</h5>
            <pre><code>RETURN</code></pre>

            <h5>Definici√≥n:</h5>
            <p>Vuelta del sub-programa: Reenv√≠a la ejecuci√≥n despu√©s del √∫ltimo <code>GOSUB</code>, <code>OF..GOSUB</code>, o <code>IF..GOSUB</code> que ha sido ejecutado.</p>
            <p>Est√° prohibido ejecutar una orden <code>RETURN</code> si no ha habido una orden de llamada de sub-programa interno (<code>GOSUB...</code>).</p>
            <h5>Ejemplo:</h5>
            <pre><code>5000
       RETURN               ; Fin del sub-programa interno</code></pre>

            <hr />

            <h4>Sub-Programa Externo: SEGMENT</h4>
            <p>El primer segmento ejecutado tiene que ser siempre el cero. El orden de los dem√°s segmentos es indiferente, los n√∫meros de los dem√°s segmentos est√° comprendido entre 1 y 254 (255 segmentos m√°ximo).</p>
            <p>Un segmento es un sub-programa residente en el disco.</p>
            <p>Al lanzar la ejecuci√≥n, se reserva el espacio para el segmento 0 y el m√°s grande de los dem√°s segmentos, o solamente para el m√°s grande de los segmentos si no hay suficiente espacio en memoria.</p>
            <p>Cuando se llama a un segmento, se carga en memoria por el ejecutor, si a√∫n no estaba hecho. Si no hay memoria disponible, el segmento menos utilizado es suprimido del espacio de la memoria, esto permite en general tener en memoria el segmento 0 u otro segmento.</p>
            <p>Un segmento puede llamar a cualquier otro segmento.</p>
            <p>En el curso de una vuelta de segmento, el segmento llamador puede ser recargado si hab√≠a sido "Borrado" por el segmento llamado (por falta de espacio en memoria).</p>
            <p>En la carga de segmento, el fichero programa de tipo -T tiene que estar presente en la unidad del disco, este fichero es abierto si hab√≠a sido cerrado por <code>CLOSE=0</code>.</p>
            <h4>LDGO.SEG K1</h4>
            <h5>Sintaxis:</h5>
            <pre><code>LDGO.SEG K1</code></pre>

            <h5>Definici√≥n:</h5>
            <p><code>K1</code> es una expresi√≥n num√©rica corta.</p>
            <p>Esta orden es una llamada al segmento cuyo n√∫mero es el valor de <code>K1</code>.</p>
            <p>El segmento <code>K1</code> es cargado en memoria si ya no lo estaba. Es ejecutado dicho segmento desde la primera instrucci√≥n.</p>
            <p>Cuando un <code>RET.SEG</code> sea ejecutado el sistema seguir√° en la orden siguiente al <code>LDGO.SEG</code> llamador.</p>
            <p>El segmento cero puede ser llamado desde otro segmento para autorizar la gesti√≥n de sub-programas comunes.</p>
            <h5>Ejemplo:</h5>
            <pre><code>ASK=1,I=9999:"Elige una Opci√≥n : "=OPCION
.
LDGO.SEG OPCION     ; Llamada del segmento cuyo n√∫mero es OPCION</code></pre>

            <hr />

            <h4>RET.SEG</h4>
            <h5>Sintaxis:</h5>
            <pre><code>RET.SEG</code></pre>

            <h5>Definici√≥n:</h5>
            <p>Retorno del segmento. El sistema va a ejecutar la instrucci√≥n que sigue a <code>LDGO.SEG</code> llamador, eventualmente el segmento llamador se recarga si se hab√≠a borrado. En este caso, el fichero tipo -T es abierto si se hab√≠a cerrado por <code>CLOSE=0</code>.</p>
            <h5>Ejemplo:</h5>
            <pre><code>SEGMENT 6           ; Principio del segmento 6
     I1=2           ; Principio de ejecuci√≥n del segmento
     -
     gosub 7000
     -
     RET.SEG        ; Fin de ejecuci√≥n del segmento
7000 -              ; S/P interno en este segmento 6 por ejemplo
     -
     RETURN
     DATA ...       ; por ejemplo
ESEG    6           ; Fin del segmento 6</code></pre>

            <hr />

            <h4>CLOSE=0</h4>
            <h5>Sintaxis:</h5>
            <pre><code>CLOSE=0</code></pre>

            <h5>Definici√≥n:</h5>
            <p>Cierra el fichero programa de tipo -T, si estaba abierto. Su n√∫mero l√≥gico es siempre cero. En DBUG no se podr√°n visualizar o modificar las variables por los comandos D y M.</p>
            <p>El <code>CLOSE=0</code> permite:</p>
            <ul>
              <li>Recuperar un n√∫mero l√≥gico para el puesto de trabajo.</li>
              <li>Asegurarse que el disco (o disquete) que contiene el fichero programa est√° bien en la unidad de disco, sobre todo para la posterior apertura del fichero, para las aplicaciones en las que el operador tiene que manipular los disque(tte)s.</li>
              </ul>

            <p>Por contra, la apertura del fichero programa (-T) aumenta un poco el tiempo de acceso a un segmento, si hay carga.</p>
            <h5>Ejemplo:</h5>
            <pre><code>segment 5
CLOSE=0             ; para cerrar el fichero de tipo -T en permanencia
-
LDGO.SEG N1
CLOSE=0             ; para cerrar el fichero de tipo -T en permanencia
    ; haci√©ndolo en principio de todos los segmentos incluido el cero.
    ; y despu√©s de cada LDGO.SEG</code></pre>

            <hr />

            <h4>Sub-Programa Ensamblador: Ya Cargado en Memoria</h4>
            <p><b>Nota:</b> Esta orden solo es posible si se dispone de la opci√≥n PS del ejecutor y si la opci√≥n PS ha sido autorizada en la configuraci√≥n del sistema.</p>
            <h4>CALL VarDato, VarCod [:Etiqu, VarEr]</h4>
            <h5>Sintaxis:</h5>
            <pre><code>CALL VarDato, VarCod [:Etiqu, VarEr]</code></pre>

            <h5>Definici√≥n:</h5>
            <p>LLAMADA de un sub-programa Ensamblador.</p>
            <p><code>VarDato</code> es una variable declarada en memoria central que contendr√° los par√°metros (de llamada y/o de retorno), o el principio de los par√°metros. En este caso se habr√°n declarado consecutivamente <code>VarDato</code>, <code>V2</code>, <code>V3</code>, ... que contendr√°n los diferentes par√°metros.</p>
            <p><code>VarCod</code> es el par√°metro que da la direcci√≥n del sub-programa ensamblador:</p>
            <ul>
              <li>Si <code>VarCod</code> es un num√©rico corto, el valor da la direcci√≥n del sub-programa ensamblador. En este caso una orden <code>DEFSEG</code> habr√° de inicializar el valor del DATA SEGMENT (DS del CPU) a utilizar.</li>
              <li>Si <code>VarCod</code> no es un num√©rico corto (es una cadena de caracteres por ejemplo), el sub-programa ensamblador ser√° ejecutado a partir del primer octeto de la variable <code>VarCod</code>.</li>
              </ul>

            <p><b>Al entrar en el sub-programa ensamblador se tiene:</b></p>
            <ul>
              <li>El registro AL como valor 1</li>
              <li>El registro AH debe contener el n√∫mero de interrupci√≥n PROLOGUE (110) para una llamada a un m√≥dulo de PROLOGUE</li>
              <li>La direcci√≥n del primer octeto de <code>VarDato</code> en ES:BX (Haciendo que el ejecutor pase por la direcci√≥n de VarDato en DS:BX, pero la entrada en PROLOGUE, pone ES en DS y as√≠, visto desde los m√≥dulos PROLOGUE la direcci√≥n de VarDato est√° en DS:BX)</li>
              <li>La longitud de la variable <code>VarDato</code> en el registro CX</li>
              <li>DX = 0</li>
              <li>DF = 0 (Direcci√≥n Flag)</li>
              <li>Las interrupciones est√°n autorizadas</li>
              </ul>

            <p><b>Salida del sub-programa ensamblador:</b> Se hace por un RET Far, el registro AL conteniendo el c√≥digo de retorno (status), y AH = 0. Solo se restituyen los registros SP y SS.</p>
            <p>Si el par√°metro <code>[:Etiqu,VarEr]</code> no se pone en el <code>CALL</code> llamador, se ejecuta siempre la instrucci√≥n que sigue y el c√≥digo respuesta se pierde.</p>
            <p>Si el par√°metro <code>:Etiqu,VarEr</code> se pone en el <code>CALL</code> llamador, <code>Etiqu</code> es la etiqueta de la instrucci√≥n a ejecutar si el c√≥digo de respuesta es diferente de cero, si el c√≥digo es igual a cero se ejecuta la instrucci√≥n que contin√∫a al CALL. <code>VarEr</code> es una variable num√©rica corta % que contiene el c√≥digo respuesta (cero o diferente de cero).</p>
            <h5>Ejemplo 1: Incrementar un num√©rico corto</h5>
            <pre><code>program "CALL"
dcl N1#         ; N1 es el valor a incrementar
dcl PROG$=1(3)  ; PROG contendr√° el programa
segment 0
PROG(1)=chr$(/FE)       ; Inc.Byte apuntado por BX en 16 bits
PROG(2)=chr$(/07)       ;                          en 16 bits
PROG(3)=chr$(/CB)       ; RET FAR                  en 16 bits

10  CALL N1,PROG(1) ; Incrementa el valor de N1, cero al principio
    print=1:N1," , "
    op 100          ; para abandonar
    goto 10         ; recomenzar
100 stop
eseg 0
end</code></pre>

            <h5>Ejemplo 2: Llamada de una primitiva de PROLOGUE (lectura DATE)</h5>
            <pre><code>program "Llama plg 86"  ;
dcl ASS$=8      ; C√≥digo del S/P ass en variable de tipo cadena
                ; para par√°metro por direcci√≥n del CALL
field=m,ASS     ; equivalencia num√©rica corta para leer el c√≥digo
dcl ASB#(8)     ; en hexadecimal.
field=m         ; fin de equivalencias
dcl ASP#(9)     ; zona para par√°metro de entrada/salida del S/P
dcl I0#         ; √≠ndice de bucle, lectura del c√≥digo ensamblador

segment 0
for I0= 1 to 8  ; cargar el c√≥digo del S/P ensamblador de las DATA
read=0:ASB(I0)
next I0

100 ASB(2)=1        ; Al = 1 Hora....  ; Al = 0 si a√±o .....
    ASB(4)=7        ; Ah = 7 lee la Fecha
    CALL ASP(1),ASS ; Llamada del S/P, resultado a partir de ASP(1)

    for I0 = 1 to 5 ; presentar el resultado
    print=1:ASP(I0)
    next I0
    stop
    *    MOV A1, P1 , MOV AH, P2 , INT , 110 , SAHF , RET
    DATA /B0   , 00 , /B4   , 00 , /CD , 110 , /9E  , /CB
eseg 0
end</code></pre>

            <hr />

            <h4>Sub-Programa Ensamblador: Carga en Memoria</h4>
            <p>Se puede cargar en memoria un sub-programa ensamblador contenido en un fichero de tipo objeto. Esto se hace en dos tiempos: Primero se asigna (<code>ASSIGN=</code>) a un n√∫mero l√≥gico el nombre del fichero, despu√©s el fichero se carga en memoria (<code>LOAD=</code>).</p>
            <p>Un sub-programa ensamblador puede tambi√©n cargarse y ejecutarse por <code>LOAD.GO</code>, en este caso se tiene siempre CX = 0 (longitud de la variable).</p>
            <h4>Sintaxis de la asignaci√≥n del fichero:</h4>
            <pre><code>ASSIGN=Nlog, "FICH" [:Etiqu, VarEr]</code></pre>

            <h4>Definici√≥n:</h4>
            <ul>
              <li><code>Nlog</code> es el n√∫mero l√≥gico cuyo valor debe estar comprendido entre 1 y 32. Es un num√©rico corto.</li>
              <li><code>"FICH"</code> es una cadena de caracteres, constante entre comillas, variable o expresi√≥n calculada.</li>
              <li><code>"FICH"</code> es el nombre del fichero <code>[Sup.]NOMFICH[-X][:Claves]</code>.</li>
              <li>Por defecto, el soporte impl√≠cito fichero (IF) es el utilizado.</li>
              <li>Por defecto, el tipo -X (Objeto) es el usado.</li>
              <li><code>Etiqu</code> es la etiqueta de la instrucci√≥n a ejecutar en caso de error.</li>
              <li><code>VarEr</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (error), despu√©s de la ejecuci√≥n del ASSIGN.</li>
              </ul>

            <p><code>ASSIGN</code> cierra el n√∫mero l√≥gico <code>Nlog</code> si este ya hab√≠a sido abierto, para manipular otro fichero por ejemplo. Despu√©s el sistema asocia (asigna) al n√∫mero l√≥gico <code>Nlog</code> el nombre del fichero dado por <code>"FICH"</code>.</p>
            <hr />

            <h4>Sintaxis de la carga en memoria (para m√°quinas de 16 bits):</h4>
            <pre><code>LOAD= Nlog : [Etiqu, VarEr,] VarCod [, Longitud]</code></pre>

            <h4>Definici√≥n:</h4>
            <ul>
              <li><code>Nlog</code> es el n√∫mero l√≥gico cuyo valor debe estar entre 1 y 32. Es un num√©rico corto, el mismo que se ha asignado por <code>ASSIGN=</code>.</li>
              <li><code>VarCod</code> es una variable declarada en memoria central. Es la zona de recepci√≥n de la direcci√≥n de memoria donde el sub-programa ensamblador ha sido cargado por <code>LOAD=</code>, esta zona tiene que ser de al menos 4 octetos, si no, hay un error 122.</li>
              <li>Despu√©s de ejecutar <code>LOAD=</code> los dos primeros octetos de <code>VarCod</code> contienen el n√∫mero del segmento y los dos siguientes, la direcci√≥n de lanzamiento del sub-programa assembler en notaci√≥n directa: zona fuerte, zona d√©bil.</li>
              <li><code>"Longitud"</code> es un num√©rico corto cuyo valor indica el n√∫mero de octetos a utilizar para la zona de recepci√≥n. Por defecto del par√°metro "Longitud" es el valor de la longitud declarada para la variable <code>VarCod</code> en las declaraciones (DCL) que se utilizan.</li>
              </ul>

            <p>El programa es cargado en una zona de memoria afectada din√°micamente, esta zona es independiente de la usada por vuestro programa BAL.</p>
            <p><code>Etiqu</code> es la etiqueta de la instrucci√≥n a ejecutar en caso de error. <code>VarEr</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (error), despu√©s de la ejecuci√≥n del <code>LOAD=</code>.</p>
            <p><b>Liberaci√≥n del espacio de memoria:</b> Este espacio no ser√° liberado m√°s que en ciertos casos, esto es lo que permite varias llamadas sin recarga, a saber:</p>
            <ul>
              <li><code>LOAD=NLOG</code> con el mismo valor de NLOG</li>
              <li><code>LOAD.GO=NLOG</code> con el mismo valor de NLOG</li>
              <li>Bajo cierre de este n√∫mero l√≥gico:</li>
              <ul>
                <li><code>CLOSE=NLOG</code> con el mismo valor de NLOG</li>
                <li><code>ASSIGN=NLOG</code> con el mismo valor de NLOG</li>
                <li><code>CHAIN=</code> cualquier n√∫mero l√≥gico</li>
                </ul>
              </ul>

            <ul>
              <li>Retorno al int√©rprete de PROLOGUE por STOP o ESEG o error fatal</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>program "LOAD-CALL"
dcl CONTADOR#
dcl SEG% , ADR% ; Segmento, direcci√≥n

segment 0

assign=1,"CALL" ; Nombre del fichero assembler de tipo -X
LOAD=1:SEG,4    ; Cargar
DEFSEG = SEG    ; Posiciona de n√∫mero del CS del prog. assembler

10  CALL CONTADOR , ADR     ; Incrementa el contador
    print=1:(N3Z),CONTADOR
    op 100
    goto 10

100 stop
eseg 0

end</code></pre>

            <h4>Programa ensamblador: "CALL"</h4>
            <pre><code class="language-asm">Code segment public
     assume  CS:code
     INC     ES:byte ptr [bx]       ; incrementa la variable BAL
Retf proc    far
     XOR     AX,AX                  ; Retorno correcto
     RET                            ; Retorno simple por proc far
Retf endp                           ; fin procedimiento
code ends
     end</code></pre>

            <p>Este programa es:</p>
            <ul>
              <li>Ensamblado por ASM (creaci√≥n del fichero -OBJ)</li>
              <li>Linkado por LINK (creaci√≥n del fichero -EXE)</li>
              <li>Renombrado por CP,RF (el tipo -EXE pasa a -X)</li>
              </ul>

            <hr />

            <h4>Carga y Ejecuci√≥n de un Fichero</h4>
            <p>Se pueden cargar en memoria y lanzar en ejecuci√≥n:</p>
            <ul>
              <li>Los utilitarios PROLOGUE</li>
              <li>Los programas escritos en BAL (haciendo seguir su nombre de -T). En este caso el Ejecutor no se recarga, un espacio de memoria diferente se usa para el llamador qued√°ndole tambi√©n 54 K octetos para el programa llamado. Los par√°metros del <code>LOAD.GO=</code> se resumen a un blanco obligatorio (falta de par√°metros) o a los par√°metros de ejecuci√≥n.</li>
              <li>Los sub-programas ensamblador</li>
              </ul>

            <p>Y despu√©s de su ejecuci√≥n continuar por ejecutar el programa BAL, como si se hubiera ejecutado un sub-programa.</p>
            <p>Esto se hace en dos tiempos: Lo primero asigna (<code>ASSIGN=</code>) a un n√∫mero l√≥gico el nombre del fichero, y luego se carga en memoria y se ejecuta (<code>LOAD.GO=</code>).</p>
            <h4>Sintaxis de la asignaci√≥n del utilitario:</h4>
            <pre><code>ASSIGN=Nlog, "FICH" [,EX] [:Etiqu, VarEr]</code></pre>

            <h4>Definici√≥n:</h4>
            <ul>
              <li><code>Nlog</code> es el n√∫mero l√≥gico cuyo valor tiene que estar comprendido entre 1 y 32. Es un num√©rico corto.</li>
              <li><code>"FICH"</code> es una cadena de caracteres, constante entre comillas, variable o expresi√≥n cadena calculada.</li>
              <li><code>"FICH"</code> es el nombre del fichero <code>[Sup.]NOMFICH[-X][:Claves]</code>.</li>
              <li>Por defecto de soporte, se usa el impl√≠cito fichero (IF). Como en el caso general el fichero est√° en la unidad impl√≠cita programa, si no es as√≠, es preciso dar el soporte del fichero (IP).</li>
              <li>Por defecto de tipo, el tipo -X (Objeto) es el usado.</li>
              <li><code>EX</code> es un par√°metro opcional, si est√° presente el utilitario ser√° abierto por <code>LOAD.GO=</code>, en exclusividad. Si no ser√° abierto en modo particionable.</li>
              <li><code>Etiqu</code> es la etiqueta de la instrucci√≥n a ejecutar en caso de error.</li>
              <li><code>VarEr</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (error), despu√©s de la ejecuci√≥n del <code>ASSIGN=</code>.</li>
              </ul>

            <p><code>ASSIGN=</code> cierra el n√∫mero l√≥gico <code>Nlog</code> si ya estaba abierto, para manipular otro fichero por ejemplo. Luego el sistema asocia (asigna) al n√∫mero l√≥gico <code>Nlog</code> el nombre del fichero dado por <code>"FICH"</code>.</p>
            <h4>Ejemplo:</h4>
            <pre><code>ASSIGN=1,"IP.CP"</code></pre>

            <p><b>Advertencia:</b> El uso de ASG trae algunos problemas, en efecto, en este caso, despu√©s de la desconexi√≥n del teclado, la orden BAL que sigue a <code>LOAD.GO=</code> es ejecutada y las siguientes. As√≠ el texto catalogado es tomado como respuestas del teclado por vuestro programa de aplicaci√≥n, esto permite la puesta a punto simulando una sesi√≥n r√°pida, pero demasiado r√°pida para ser le√≠da.</p>
            <hr />

            <h4>Sintaxis de la carga en memoria y de la ejecuci√≥n:</h4>
            <pre><code>LOAD.GO=Nlog, "Par√°metros" [,(R)] [:Etiqu, VarEr]</code></pre>

            <h4>Definici√≥n:</h4>
            <ul>
              <li><code>Nlog</code> es el n√∫mero l√≥gico cuyo valor est√° entre 1 y 32. Es un num√©rico corto por el que <code>ASSIGN=</code> ha asignado un nombre de fichero.</li>
              <li><code>"Par√°metros"</code> es una cadena de caracteres, constante entre comillas, variable o expresi√≥n calculada, que contienen los par√°metros de ejecuci√≥n del utilitario.</li>
              <li>Por defecto de par√°metros es preciso poner al menos un blanco.</li>
              <li>Los "Par√°metros" est√°n constituidos exactamente por todas las informaciones que se introducen por teclado en un comando del sistema, que hay despu√©s de la coma siguiente al nombre del utilitario, a excepci√≥n del car√°cter de validaci√≥n.</li>
              <li><code>(R)</code> es una opci√≥n que provoca dejar este utilitario residente en memoria para una llamada posterior, sin recargarlo de nuevo.</li>
              </ul>

            <p><b>Liberaci√≥n de memoria con opci√≥n (R):</b> La memoria ser√° liberada, y el utilitario eventualmente vuelto a cargar despu√©s de:</p>
            <ul>
              <li><code>LOAD.GO=</code> sin la opci√≥n (R)</li>
              <li>Cierre del n√∫mero l√≥gico <code>Nlog</code> por: <code>CLOSE=Nlog</code>, <code>ASSIGN=Nlog</code>, <code>STOP</code></li>
              <li>Encadenar programa, vuelta a PROLOGUE</li>
              </ul>

            <p><code>Etiqu</code> es el n√∫mero de instrucci√≥n a ejecutar en caso de error. <code>VarEr</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (error), despu√©s de la ejecuci√≥n del <code>LOAD.GO=</code>.</p>
            <ul>
              <li>El utilitario "FICH" se carga en memoria din√°micamente, detr√°s del espacio reservado por vuestro programa.</li>
              <li>La ejecuci√≥n del utilitario se lanza con los par√°metros del <code>LOAD.GO=</code>.</li>
              <li>Despu√©s de ejecutar el utilitario, la instrucci√≥n BAL siguiente al <code>LOAD.GO</code> se ejecuta, o bien hay desv√≠o en error si la opci√≥n ha sido puesta y si el c√≥digo de respuesta es diferente de cero.</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>; Copiar el fichero /-X de FL0 a FL1
; luego los ficheros PAGOS-* de FL1 a MD0
; luego ejecutar el programa PAGO-T
-
segment 0
-
ASSIGN=1,"IP.CP"
LOAD.GO=1,"DF,FL0./-X,FL1"  ,(R)    ; Dejar CP residente
print=1:"Fin de la copia de /-X",tabv(1)
LOAD.GO=1,"DF,FL1.PAGOS-*,MD0"      ; Liberar el espacio memoria de CP
print=1:"Fin de las copias",tabv(1)
*
ASSIGN=1,"PAGO-T"           ; Es un programa BAL que est√° en IF
LOAD.GO=1," "               ; Ejecuci√≥n normal
*                           ; LOAD.GO=1,"DB" ; para Ejecuci√≥n bajo Dbug
-                   ; contin√∫a el programa BAL despu√©s de ejecutar "PAGO-T"
eseg 0</code></pre>

            <hr />

            <h3>Tratamiento de Errores de Ejecuci√≥n en un Segmento</h3>

            <p>Los errores de ejecuci√≥n pueden ser gestionados:</p>
            <ul>
              <li>Bien con ciertas √≥rdenes por <code>:Etiqu,VarEr</code> esta direcci√≥n de desv√≠o es entonces prioritaria en caso de error y el c√≥digo de respuesta se pone en la variable num√©rica corta <code>VarEr</code>.</li>
              <li>Bien en un segmento, para las √≥rdenes que no tienen desv√≠o en caso de error en la instrucci√≥n, que esta posibilidad existe o no.</li>
              </ul>

            <p>La gesti√≥n del desv√≠o en caso de error ser√° operacional a partir de la ejecuci√≥n del <code>ON ERROR GOTO</code> hasta el fin del segmento en curso, o hasta la ejecuci√≥n de un <code>ON ERROR ABORT</code>.</p>
            <p>Despu√©s del tratamiento de un error de ejecuci√≥n, por <code>ON ERROR GOTO</code>, se puede reemprender el curso del programa con la orden <code>RESUME</code> o bien abandonar la ejecuci√≥n con un <code>STOP</code>.</p>
            <p>En el caso de un error de encadenamiento (<code>CHAIN=</code>) hay que ejecutar <code>CHAIN=0</code> para anular dicho encadenamiento o encadenar a otro programa BAL.</p>
            <hr />

            <h4>ON ERROR GOTO Etiqu, VarEr</h4>
            <h4>Sintaxis:</h4>
            <pre><code>ON ERROR GOTO Etiqu, VarEr</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Etiqu</code> es la etiqueta de la instrucci√≥n a ejecutar en caso de error. <code>VarEr</code> es una variable num√©rica corta que contendr√° el c√≥digo de respuesta (error), despu√©s del desv√≠o en caso de error.</p>
            <p>Esta orden es v√°lida solo para el segmento en que est√° inscrita. En caso de error de ejecuci√≥n no gestionado por una orden que provoque un desv√≠o, se ir√° la ejecuci√≥n a la instrucci√≥n <code>Etiqu</code> con el error de la variable <code>VarEr</code>.</p>
            <hr />

            <h4>RESUME [Etiqu]</h4>
            <h4>Sintaxis:</h4>
            <pre><code>RESUME [Etiqu]</code></pre>

            <h4>Definici√≥n:</h4>
            <p><code>Etiqu</code> es la etiqueta de la instrucci√≥n a ejecutar despu√©s del tratamiento del error. Es una constante.</p>
            <p>Esta orden permite, despu√©s del tratamiento de error gestionado por <code>ON ERROR GOTO</code>, ir a ejecutar la instrucci√≥n cuya etiqueta es <code>Etiqu</code>, o si la opci√≥n <code>Etiqu</code> no est√°, volver a ejecutar la instrucci√≥n que ha provocado el error.</p>
            <p>La ejecuci√≥n de <code>RESUME</code> est√° prohibida: si <code>ON ERROR GOTO</code> no ha sido ejecutado en este segmento o si no ha habido ning√∫n error.</p>
            <hr />

            <h4>ON ERROR ABORT</h4>
            <h4>Sintaxis:</h4>
            <pre><code>ON ERROR ABORT</code></pre>

            <h4>Definici√≥n:</h4>
            <p>La ejecuci√≥n de esta orden anula el tratamiento de error por <code>ON ERROR GOTO</code>, as√≠ un error no gestionado es fatal. Al lanzar la ejecuci√≥n de un segmento, esta orden est√° impl√≠citamente activada.</p>
            <hr />

            <h4>Ejemplos de Tratamiento de Errores</h4>
            <h4>Ejemplo 1: Utilizaci√≥n de fichero Virtual y gesti√≥n de error</h4>
            <pre><code>program "VIRTUAL"
dcl E0%,I0             ; cod.respuesta ( error ), √çndice
field=1                ; Declaraci√≥n en memoria virtual
dcl T0#(10)            ; tabla de 10 veces un octeto

segment 0

ON ERROR GOTO 9000,E0  ; En caso de error ir a 9000, error en E0
assign=1,"VIRTUAL",WR  ; El fichero de n√∫m.l√≥gico 1 se llama VIRTUAL
for I0=1 to 10         ; Hacer 10 veces.
T0(I0)=I0              ; Escribir 1 a 10,en caso de error ir a 9000
next I0
stop
9000 print=1:"Error n√∫mero  : ",E0,tabv(1)
RESUME                 ; Vuelta de la instrucci√≥n en error
eseg 0
end</code></pre>

            <h4>Ejemplo 2: Gesti√≥n de un time-out en la impresora</h4>
            <p>El error n√∫mero 1 (perif√©rico no preparado) se reenv√≠a si la impresora no est√° preparada para recibir un car√°cter en un tiempo de 45 segundos, si SPLO1 est√° presente en el sistema, si no, la demora es de 8 segundos aproximadamente.</p>
            <p>El programa puede gestionar este error por medio de la orden <code>ON ERROR GOTO</code>. En el caso que esta orden no sea ejecutada en el segmento en curso, el programa se bloquea hasta la puesta en marcha de la impresora.</p>
            <pre><code>program "Papel Imp"
dcl E0#,I0     ; cod.respuesta ( error ), n√∫mero
segment 0
ON ERROR GOTO 9000,E0  ; En caso de error ir a 9000, error en E0
I0=1           ; primera l√≠nea
10   print=2:"l√≠nea n√∫mero : ",I0,tabv(1) ; Edita en la impresora
I0=I0+1        ; N√∫mero de l√≠nea siguiente
op 100         ; Dar cualquier tecla para abandonar
goto 10
100  stop

9000
*           se llega aqu√≠ aproximadamente en 45 segundos
*
print=1:"Impresora No Preparada : ",E0,tabv(1)
RESUME         ; Vuelta a la instrucci√≥n que provoc√≥ el error.
eseg 0
end</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 8: Entrada/Salida Impresora Pantalla/Teclado</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <h4>Salida Pantalla / Impresora</h4>
            <ul>
              <li><code>PRINT=</code> Perif√©rico</li>
              <li><code>( Formato )</code> , Exp</li>
              <li>Tab-Lista</li>
              </ul>

            <h4>Tabulaci√≥n y Atributos</h4>
            <ul>
              <li><code>BELL</code> , <code>CLEAR</code> , <code>HOME</code></li>
              <li><code>PAGE</code> , <code>TAB( C1 [ , L1 ] )</code> , <code>TABV( L )</code></li>
              <li><code>ATB( N1 )</code></li>
              <li><code>PAINT( C1 [ , F1 ] )</code></li>
              </ul>

            <h4>Asignaci√≥n de Impresora</h4>
            <ul>
              <li><code>ASSIGN=Nlog,"Sup.",IM,WR,EX: [Etiqu,ER,] Zona [,Long]</code></li>
              <li><code>OPEN=Nlog</code> , <code>CLOSE=Nlog</code></li>
              </ul>

            <h4>Formatos</h4>
            <ul>
              <li>Reglas generales <code>( )</code> , <code>FM</code> , <code>FMT</code></li>
              <li>Formato Libre</li>
              <li>Elemento de formato</li>
              <li>C√≥digo formato</li>
              <li>Elementos de formato especiales: <code>/c</code> , <code>Xc</code> , <code>"Literal"</code></li>
              <li>Formatos definidos din√°micamente</li>
              </ul>

            <h4>M√°scara de Control</h4>
            <ul>
              <li><code>MASK N1</code></li>
              </ul>

            <h4>Entrada Teclado</h4>
            <ul>
              <li><code>ASK=1</code> : <code>=</code></li>
              <li>Lista de Desv√≠os en ASK</li>
              </ul>

            <hr />

            <h3>Salida Pantalla / Impresora</h3>

            <h4>Definici√≥n</h4>
            <p>Una orden de salida por pantalla o la impresora permite editar en el perif√©rico elegido:</p>
            <ul>
              <li>Expresiones calculadas, variables y/o constantes con formatos de edici√≥n</li>
              <li>Tabulaciones</li>
              </ul>

            <p>Permite tambi√©n seleccionar los atributos de visualizaci√≥n de la pantalla.</p>
            <h4>Sintaxis</h4>
            <pre><code>PRINT=Perif. [,Etiqu Fmt] : [ ( Formato ), ] [ Exp, ] [ Tab-Lista, ]
                            `-------------------:-------------------'
                                                !
                                             N Veces</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>PRINT=1:CLEAR,"Se√±or  : ",NOMBRE,TABV(1),"Edad : ",( NZ ),N1,tabv(1)</code></pre>

            <h4>Par√°metros</h4>
            <h4>Perif</h4>
            <p>Perif es un num√©rico corto cuyo valor define el perif√©rico de salida.</p>
            <ul>
              <li>El valor <b>1</b> designa la pantalla.</li>
              <li>El valor <b>2</b> designa la impresora impl√≠cita a priori. Sin embargo, un valor entre 2 y 32 define la impresora (local o central) asignada a este valor por un:</li>
              </ul>

            <pre><code>ASSIGN=Perif,"Sup.",IM,WR,EX [ : Etiqu,Er, ] Zona [, Long ]</code></pre>

            <p>Este <code>ASSIGN=</code> debe ejecutarse antes de la orden <code>PRINT=</code> si no, el valor 2 designa la impresora impl√≠cita.</p>
            <h4>Etiqu Fmt</h4>
            <p>Etiqu Fmt es una constante. Es la etiqueta de la instrucci√≥n <code>FMT</code> que tiene el formato a utilizar. Esta instrucci√≥n <code>FMT</code> no es ejecutable y debe ser puesta despu√©s de una instrucci√≥n de ruptura de secuencia incondicional.</p>
            <p>Por defecto de esta etiqueta, el formato usado es el formato libre, esto es hasta el encuentro de un formato, definido entre par√©ntesis en el mismo orden de <code>PRINT=</code>.</p>
            <h4>: (Dos puntos)</h4>
            <p>Despu√©s de los dos puntos de un <code>PRINT=</code> tiene que haber un par√°metro por lo menos: una expresi√≥n o una tabulaci√≥n.</p>
            <ul>
              <li>Un formato no puede nunca aparecer solo en un <code>PRINT=</code></li>
              <li>Si hay varios par√°metros en un <code>PRINT=</code> deben estar separados unos de otros por comas ","</li>
              <li>Todos los par√°metros pueden estar en cualquier orden y en cualquier n√∫mero</li>
              <li>La aparici√≥n de un formato nuevo anula el precedente</li>
              </ul>

            <p>Las expresiones, las variables, las constantes, las tabulaciones, los atributos se editan en el orden en que se escriben. Los elementos del formato en curso se usan para editar las expresiones, las variables y las constantes. Las tabulaciones y los atributos no usan elementos de formato.</p>
            <p>Los elementos especiales de formatos (<code>/c</code>, <code>Xc</code>, <code>"Literal"</code>) se editan en el momento de utilizarse el pr√≥ximo elemento de formato, en el curso de la edici√≥n de una expresi√≥n, de una variable o de una constante.</p>
            <h4>( Formato )</h4>
            <p>Pr√°cticamente los mismos formatos se usan para la entrada de datos con <code>ASK=</code>.</p>
            <p>Un formato aparece siempre entre par√©ntesis, est√° compuesto de una sucesi√≥n de elementos de formato separados por comas.</p>
            <ul>
              <li>Un elemento de formato define:</li>
              <ul>
                <li>La longitud de la zona a utilizar para la edici√≥n (o la entrada)</li>
                <li>El tipo de caracteres a editar (o teclear) en cada columna</li>
                <li>El hecho de que estos caracteres sean obligatorios o no (los ceros no significativos no se editan)</li>
                </ul>
              </ul>

            <ul>
              <li>Un nuevo formato anula y reemplaza el formato definido previamente</li>
              <li>Un formato es circular, es decir, que si todos los elementos de un formato han sido usados y que la orden <code>PRINT=</code> (o <code>ASK=</code>) no ha terminado, el sistema reutiliza el formato a partir del primer elemento de ese formato en curso</li>
              </ul>

            <h4>Exp</h4>
            <p>Exp representa una expresi√≥n calculada, una variable, una funci√≥n o una constante a editar, separadas por comas. Cada edici√≥n utiliza el pr√≥ximo elemento del formato en curso (con excepci√≥n de una constante en un <code>ASK=</code> que no utiliza elementos de formato para su edici√≥n).</p>
            <p><b>Nota:</b> Una expresi√≥n en un <code>PRINT=</code> o un <code>ASK=</code> no puede ser puesta entre par√©ntesis, puesto que ser√≠a tomada en cuenta como un formato.</p>
            <hr />

            <h3>Tab-Lista</h3>

            <h4>Definici√≥n</h4>
            <ul>
              <li>Tab-Lista es una sucesi√≥n de tabulaciones y/o de definiciones de atributos.</li>
              <li>El papel de las tabulaciones es definir la posici√≥n, en el soporte de salida, del pr√≥ximo car√°cter a editar. (Salto de p√°gina, borrado pantalla, posicionamiento columna y/o l√≠nea en absoluto o en relativo).</li>
              </ul>

            <p><b>Para impresora:</b></p>
            <p>En una impresora la edici√≥n se debe terminar por un salto de l√≠nea o un salto de p√°gina, con el fin de que la √∫ltima l√≠nea sea editada. Esto es importante para las impresoras de l√≠nea o bidireccionales.</p>
            <p>Adem√°s si el SPOOL est√° activo, la impresora debe ser liberada bien enviando un c√≥digo <code>/1A</code>, si no est√° asignada, bien por un <code>CLOSE=</code> si ya estaba asignada.</p>
            <p><b>Atributos:</b></p>
            <p>Los atributos no funcionan m√°s que en las pantallas por defecto, definen el modo de edici√≥n tal como: inverso video, subrayado, etc., seg√∫n las posibilidades de la pantalla de vuestro ordenador.</p>
            <h4>Ejemplo</h4>
            <p>La orden <code>PRINT=</code> se supone estar escrita en una sola instrucci√≥n BAL, es decir con una sola validaci√≥n en el final.</p>
            <pre><code>program "PRINT"
dcl PERIF#      ; N√∫mero del perif. de salida: 1 Pantalla, 2 Impresora
dcl CAN%        ; Cantidad
dcl MINI%       ; Stock m√≠nimo
dcl PRECIO=6    ; Valor
segment 0
-
-
PERIF=2         ; Selecci√≥n de la impresora en salida
PRINT=PERIF:PAGE,"Nueva P√°gina",tabv(2)
    ,( E,N3Z )   ,tab(10),"Cantidad : ",CAN
                 ,tab(30),"S.M√≠nimo : ",MINI
    ,( E,N4Z.N2 ),tab(50),"Precio   : ",PRECIO,TABV(1)
-
print=2:chr$(/1A)       ; Libera la impresora
stop
eseg 0
end</code></pre>

            <h4>Descripci√≥n del Ejemplo</h4>
            <p>Este edita en la impresora impl√≠cita PERIF=2, sin <code>ASSIGN=</code>:</p>
            <ol>
              <li>Hace un salto de p√°gina <code>PAGE</code></li>
              <li>Imprime "Nueva P√°gina" sin las comillas, en la primera l√≠nea y la primera columna</li>
              <li>Salta 2 l√≠neas y vuelve a principio de l√≠nea <code>TABV(2)</code></li>
              <li>Imprime en la columna 10 <code>TAB(10)</code> "Cantidad : " con formato libre <code>E</code></li>
              <li>Imprime el valor de CAN cuadrado a derecha con 4 columnas con 1 cifra como m√≠nimo <code>N3Z</code></li>
              <li>Imprime en la columna 30 <code>TAB(30)</code> "S.M√≠nimo : " con formato libre <code>E</code></li>
              <li>Imprime el valor de MINI cuadrado a derecha con 4 columnas y 1 cifra como m√≠nimo <code>N3Z</code>. El formato <code>( E , N3Z )</code> ha sido usado dos veces, el nuevo formato <code>( E,N4Z.N2 )</code> anula el precedente</li>
              <li>Imprime en la columna 50 <code>TAB(50)</code> "Precio : " con formato libre <code>E</code></li>
              <li>Imprime el valor de PRECIO cuadrado a la derecha con 8 columnas y con 1 a 5 cifras delante de la coma y:</li>
            </ol>

            <p>   - Bien 3 espacios si el valor decimal es nulo</p>
            <p>   - Bien la coma y 1 √≥ 2 cifras seg√∫n el n√∫mero de cifras significativas</p>
            <p>PRECIO es editado con el formato N4Z.N2</p>
            <ol>
              <li>Luego el sistema hace un salto de l√≠nea en la impresora, la √∫ltima l√≠nea se edita entonces y el sistema est√° preparado para imprimir en la primera columna <code>TABV(1)</code></li>
            </ol>

            <hr />

            <h3>Tabulaci√≥n y Atributos</h3>

            <p>Las Tabulaciones y los atributos est√°n prohibidos en la funci√≥n <code>PRINT</code>, s√≥lo se utilizan en las √≥rdenes <code>PRINT=</code> y <code>ASK=</code>.</p>
            <h4>Tab-Lista para Pantalla y/o Impresora</h4>
            <table>
              <thead>
                <tr>
                  <th>Tabulaci√≥n</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>CLEAR</code> o <code>PAGE</code></td>
                  <td>Estas palabras claves tienen id√©ntico significado, y se usan tanto para la pantalla como para la impresora. Borran la pantalla o env√≠an un salto de p√°gina a una impresora, el pr√≥ximo car√°cter ser√° escrito en la primera l√≠nea arriba y en la primera columna.</td>
                </tr>
                <tr>
                  <td><code>TABV( L1 )</code></td>
                  <td>Tabulaci√≥n vertical en relativo de L1 l√≠neas, a partir de la posici√≥n activa, y posicionamiento a la izquierda de la l√≠nea (L1 CR luego LF). L1 es un num√©rico corto positivo.</td>
                </tr>
                <tr>
                  <td><code>TAB( C1 )</code></td>
                  <td>Tabulaci√≥n horizontal absoluta, en columna C1. Ning√∫n car√°cter es borrado si la pantalla no est√° llena. Es posible volver atr√°s en una misma l√≠nea en la pantalla o la impresora. En una impresora el sistema env√≠a un retorno de carro (CR,ENTER) y el n√∫mero de blancos necesarios. La primera columna lleva el n√∫mero 1.</td>
                </tr>
              </tbody>
            </table>

            <h4>Tab-Lista Reservadas para Pantalla</h4>
            <table>
              <thead>
                <tr>
                  <th>Tabulaci√≥n</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>HOME</code></td>
                  <td>Posiciona el cursor arriba y a la izquierda de la pantalla, sin borrarla.</td>
                </tr>
                <tr>
                  <td><code>TAB( C1,L1 )</code></td>
                  <td>Posiciona el cursor en pantalla: en columna C1 de la l√≠nea L1. La primera l√≠nea lleva el n√∫mero 1. C1 y L1 son num√©ricas cortas positivas.</td>
                </tr>
                <tr>
                  <td><code>BELL</code></td>
                  <td>Hace sonar la pantalla (o la impresora si tiene este dispositivo).</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo de Tabulaciones</h4>
            <pre><code>PRINT=1:CLEAR,tab(10),"Comandos  :",tab(30),(N3),K0,tabv(1),N0,tabv(1)</code></pre>

            <ul>
              <li>La edici√≥n se hace en pantalla <code>PRINT=1</code></li>
              <li>El sistema borra la pantalla <code>CLEAR</code></li>
              <li>Escribe en columna 10 "Comandos :"</li>
              <li>Luego en columna 30 el valor de K0 con 0 a 3 cifras cuadradas a la derecha</li>
              <li>Luego en columna 1 de la l√≠nea siguiente escribe el valor de N0 con el mismo formato que se us√≥ para K0</li>
              <li>Luego pasa a la l√≠nea siguiente a la primera columna</li>
              </ul>

            <hr />

            <h3>Atributos</h3>

            <p>La selecci√≥n de atributos de edici√≥n se ponen en los mismos entornos que las tabulaciones, es decir, en una orden <code>PRINT=</code> o <code>ASK=</code>.</p>
            <p>Los atributos son eficaces a partir de su ejecuci√≥n hasta su anulaci√≥n (vuelta al modo normal).</p>
            <p>Los atributos son acumulativos salvo si el material lo proh√≠be. Pueden ser enviados a la impresora y ser√°n en la mayor parte de los casos ignorados.</p>
            <p>Los atributos dependen realmente del material disponible.</p>
            <h4>ATB( N1 )</h4>
            <p>N1 es un num√©rico corto. Su valor selecciona un atributo:</p>
            <table>
              <thead>
                <tr>
                  <th>N1</th>
                  <th>Atributo</th>
                  <th>90-50/90-20 Pant.</th>
                  <th>IMP 31NLQ</th>
                  <th>IMP DY311</th>
                  <th>Micral 30 Pant.</th>
                  <th>IMP 32Icq</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>0</td>
                  <td>Retorno video normal</td>
                  <td>SI</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>(5)</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>1</td>
                  <td>Atributo preferencial</td>
                  <td>(2)</td>
                  <td>(4)</td>
                  <td>no</td>
                  <td>(6)</td>
                  <td>(1)</td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>Inverso video</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>Parpadeo</td>
                  <td>no</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>Subrayado</td>
                  <td>SI</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>Baja Intensidad</td>
                  <td>no</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>Alta Intensidad</td>
                  <td>no</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>Letra May√∫scula</td>
                  <td>SI</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>Letra Min√∫scula</td>
                  <td>SI</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>9</td>
                  <td>Hard-Copy alfanum√©rico</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>Escritura inclinada</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>11</td>
                  <td>Escritura grande</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>20</td>
                  <td>Hard-Copy Gr√°fico (cf SYS)</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>21</td>
                  <td>Borrado fin de l√≠nea</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>22</td>
                  <td>Borrado fin de p√°gina</td>
                  <td>SI</td>
                  <td>no</td>
                  <td>no</td>
                  <td>SI</td>
                  <td>no</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo de Atributos</h4>
            <pre><code>Print=1:ATB(2),"INVERSO VIDEO",ATB(0),"Normal",ATB(4),"Subrayado",atb(0)</code></pre>

            <ul>
              <li>Escribe en la pantalla "INVERSO VIDEO" en inverso video</li>
              <li>Luego "Normal" en modo normal</li>
              <li>Luego "Subrayado" en subrayado, lo siguiente ser√° escrito en modo normal</li>
              </ul>

            <h4>Advertencia sobre Secuencias ESCape</h4>
            <p>PROLOGUE filtra las secuencias ESCape que no reconoce, esto permite enviar cualquier atributo a la pantalla o la impresora sin ocurrir un error de ejecuci√≥n.</p>
            <p>Esto puede dar problemas para activar las secuencias de ESCape reconocidas por los perif√©ricos pero no por PROLOGUE.</p>
            <p>Para resolver este problema, existe el modo transparente que viene a decir a PROLOGUE: env√≠a los N caracteres siguientes sin filtrarlos.</p>
            <p><b>Secuencia a enviar:</b></p>
            <pre><code>ESC   T    Lgf  LGF
/1B  /54   longitud en notaci√≥n invertida</code></pre>

            <p><b>Ejemplo de modo transparente:</b></p>
            <pre><code>; Enviar Esc "C" para escribir en 16.66 cpi en una LINA 31
; Luego Esc "A" para escribir en 10 cpi (caracteres por pulgada)

print=2:chr$(/1B)+"T"+ chr$( 2 )+ chr$( 0 )     ; pasar a modo transparente
*                                               ; para 2 caracteres
print=2:chr$(/1B)+"C","texto",tabv(1)           ; 16.66 cpi

print=2:chr$(/1B)+"T"+ chr$( 2 )+ chr$( 0 )     ; Transparente
print=2:chr$(/1B)+"A"                           ; 10 cpi</code></pre>

            <hr />

            <h3>PAINT - Atributo de Color</h3>

            <h4>Definici√≥n</h4>
            <p>Este atributo s√≥lo es activo si el material dispone de una pantalla color y un sistema PROLOGUE que gestione color (Nsys &gt;= 2.2c). Si no, puede ser utilizado, pero sin efecto.</p>
            <p>Permite definir, para los caracteres que siguen a √©l:</p>
            <ul>
              <li>El color de cada car√°cter</li>
              <li>El color del fondo d√≥nde se editan</li>
              </ul>

            <p>Los colores as√≠ seleccionados son activos hasta el pr√≥ximo atributo <code>PAINT</code>.</p>
            <h4>Sintaxis</h4>
            <pre><code>PAINT ( N1 [ , N2 ] )</code></pre>

            <ul>
              <li>N1 y N2 son num√©ricos cortos</li>
              <li>N1 designa el color del car√°cter y est√° comprendido entre 0 y 15</li>
              <li>N2 designa el color del fondo y est√° comprendido entre 0 y 7. Por defecto de N2 el color del fondo no se modifica</li>
              </ul>

            <h4>Tabla de Colores</h4>
            <p><b>Fondo y/o car√°cter (0-7):</b></p>
            <table>
              <thead>
                <tr>
                  <th>Valor</th>
                  <th>Color</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>0</td>
                  <td>Negro</td>
                </tr>
                <tr>
                  <td>1</td>
                  <td>Rojo</td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>Verde</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>Marr√≥n</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>Azul</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>Magenta</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>Cyan</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>Gris claro</td>
                </tr>
              </tbody>
            </table>

            <p><b>Car√°cter √∫nicamente (8-15):</b></p>
            <table>
              <thead>
                <tr>
                  <th>Valor</th>
                  <th>Color</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>8</td>
                  <td>Gris oscuro</td>
                </tr>
                <tr>
                  <td>9</td>
                  <td>Rojo claro</td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>Verde claro</td>
                </tr>
                <tr>
                  <td>11</td>
                  <td>Amarillo</td>
                </tr>
                <tr>
                  <td>12</td>
                  <td>Azul claro</td>
                </tr>
                <tr>
                  <td>13</td>
                  <td>Magenta claro</td>
                </tr>
                <tr>
                  <td>14</td>
                  <td>Cyan claro</td>
                </tr>
                <tr>
                  <td>15</td>
                  <td>Blanco</td>
                </tr>
              </tbody>
            </table>

            <p><b>Advertencia:</b> Seg√∫n el material, todas las combinaciones no est√°n siempre autorizadas.</p>
            <hr />

            <h3>Asignaci√≥n de Impresora</h3>

            <h4>Definici√≥n</h4>
            <p>La asignaci√≥n de una impresora con un n√∫mero l√≥gico es opcional.</p>
            <p>Para ser factible, la impresora debe ser declarada en el sistema de ficheros (esto es standard en las m√°quinas de 16 bits).</p>
            <p>Por defecto, un <code>PRINT=2</code> provoca la impresi√≥n en la impresora impl√≠cita.</p>
            <p>La asignaci√≥n de una impresora permite:</p>
            <ul>
              <li>Elegir una impresora entre varias, bien en local o bien en el central en el caso de un S.P.R.</li>
              <li>Poder reservar y liberar una impresora, en el caso de un multipuesto (e incluso para un monopuesto para tener la misma versi√≥n de aplicaci√≥n tanto en el monopuesto como en un multipuesto)</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>ASSIGN=Nlog,"Sup.",IM,WR,EX : [ Etiqu , VarEr , ] Zona [ ,Long ]</code></pre>

            <p>o</p>
            <pre><code>ASSIGN=Nlog,"Sup.",IM,WR,EX [ : Etiqu , VarEr ]</code></pre>

            <h4>Par√°metros</h4>
            <table>
              <thead>
                <tr>
                  <th>Par√°metro</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Nlog</td>
                  <td>Num√©rico corto cuyo valor est√° comprendido entre 2 y 32 y que corresponde al valor de PERIF utilizado en el <code>PRINT=PERIF</code></td>
                </tr>
                <tr>
                  <td>Sup.</td>
                  <td>Cadena de caracteres que contiene el nombre del soporte impresora seguido de un punto: 2 caracteres IM o IX (mnem√≥nico del soporte), una cifra que indica el n√∫mero de la unidad, un punto obligatorio. Ejemplo: "IM0."</td>
                </tr>
                <tr>
                  <td>IM</td>
                  <td>Significa que este n√∫mero l√≥gico ser√° usado por un <code>PRINT=</code></td>
                </tr>
                <tr>
                  <td>WR</td>
                  <td>Escritura autorizada (¬°es OBLIGATORIO!)</td>
                </tr>
                <tr>
                  <td>EX</td>
                  <td>El soporte ser√° abierto en exclusividad (¬°es OBLIGATORIO!)</td>
                </tr>
                <tr>
                  <td>Etiqu</td>
                  <td>Direcci√≥n de desv√≠o en caso de error en la orden <code>ASSIGN=</code></td>
                </tr>
                <tr>
                  <td>VarEr</td>
                  <td>Variable num√©rica corta que contendr√° el c√≥digo de respuesta de la orden <code>ASSIGN=</code></td>
                </tr>
                <tr>
                  <td>Zona</td>
                  <td>Variable cadena de caracteres declarada en memoria que servir√° de zona de transferencia para la impresora. Esto permite optimizar la velocidad de transferencia. La longitud de la zona debe ser igual al n√∫mero de caracteres por l√≠nea m√°s 2 para obtener la velocidad m√°xima, es decir, 134 para una impresora de 132 caracteres por l√≠nea. Si se usan varios n√∫meros l√≥gicos es necesaria una zona por n√∫mero l√≥gico. Esta zona s√≥lo debe ser utilizada por un programa BAL antes del cierre del n√∫mero l√≥gico.</td>
                </tr>
                <tr>
                  <td>Long</td>
                  <td>Num√©rico corto cuyo valor indica la longitud de la zona de transferencia. Por defecto la longitud utilizada por el sistema es la longitud declarada para la variable Zona.</td>
                </tr>
              </tbody>
            </table>

            <h4>Funcionamiento de ASSIGN=</h4>
            <ul>
              <li>Cierra el n√∫mero l√≥gico PERIF si estaba abierto. Si correspond√≠a a una impresora reservada por nosotros, es liberada.</li>
              <li>Asocia al n√∫mero l√≥gico Nlog, entre 2 y 32, la impresora designada por "Sup."</li>
              </ul>

            <p>El pr√≥ximo <code>PRINT=</code> u <code>OPEN=</code> sobre este n√∫mero l√≥gico reservar√° la impresora.</p>
            <p>La liberaci√≥n de la impresora se har√° en el curso del cierre de este n√∫mero l√≥gico, es decir:</p>
            <ul>
              <li>Por <code>CLOSE=Nlog</code> del mismo n√∫mero l√≥gico, o</li>
              <li>Por <code>STOP</code> (que cierra todos los n√∫meros l√≥gicos), o</li>
              <li>Por <code>ASSIGN=Nlog</code> o por <code>OPEN=Nlog</code> del mismo n√∫mero l√≥gico, o</li>
              <li>Enviando a la impresora el c√≥digo hexadecimal <code>/1A</code>, por un <code>CHR$(/1A)</code>, o</li>
              <li>Por un retorno al sistema operativo, por un error fatal por ejemplo</li>
              </ul>

            <h4>Ejemplo de Asignaci√≥n</h4>
            <pre><code>program "ASSIGN IMP"
dcl ZONA$=134  ; para la zona de transferencia impresora
dcl E%         ; C√≥digo respuesta
-
segment 0
-
ASSIGN=2,"IM1.",IM,WR,EX:ZONA
OPEN=2:1000,E  ; Reservar la impresora
goto 1100      ; Ok
1000 if E&lt;&gt;44 goto 9000     ; 9000 salida por error
print=1:"Esta impresora est√° ocupada "
goto 9900      ; abandonar
1100 PRINT=2:"Segunda impresora",tabv(1)    ; Esta impresora est√° reservada
-
CLOSE=2        ; para liberar la impresora sin volver al sistema
-
goto 9900      ; Fin del programa
9000 print=1:tab(22,1),"Error  : ",E
9900 stop      ; El sistema cerrar√° los n√∫m. l√≥gicos abiertos
eseg 0
end</code></pre>

            <h4>Errores Posibles</h4>
            <table>
              <thead>
                <tr>
                  <th>Orden</th>
                  <th>C√≥digos de Error</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>ASSIGN=</code></td>
                  <td>31</td>
                </tr>
                <tr>
                  <td><code>OPEN=</code></td>
                  <td>40, 44, 56</td>
                </tr>
                <tr>
                  <td><code>PRINT=</code></td>
                  <td>01, 40, 44, 56</td>
                </tr>
              </tbody>
            </table>

            <p><b>Significado:</b></p>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>01</td>
                  <td>Impresora No Dispuesta (aprox. en 45 segundos si SPLO1 est√° presente, si no, alrededor de 8 segundos). Si ning√∫n <code>ON ERROR GOTO</code> ha sido ejecutado en este segmento, el sistema pasa indefinidamente por la instrucci√≥n <code>PRINT=</code> hasta que este error aparece. Esto puede permitir cuadrar el papel.</td>
                </tr>
                <tr>
                  <td>31</td>
                  <td>Este n√∫mero de impresora es desconocido.</td>
                </tr>
                <tr>
                  <td>40</td>
                  <td>Este nombre de impresora es desconocido.</td>
                </tr>
                <tr>
                  <td>44</td>
                  <td>Esta impresora est√° ya reservada por otro puesto u n√∫mero.</td>
                </tr>
                <tr>
                  <td>56</td>
                  <td>Las impresoras no est√°n conectadas al sistema de ficheros.</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Los Formatos</h3>

            <h4>Reglas Generales</h4>
            <ul>
              <li>Si no se especifica formato en entrada/salida, mientras ning√∫n formato se especifique, se utiliza el formato libre.</li>
              <li>Un formato est√° delimitado por par√©ntesis <code>( )</code></li>
              <li>Un formato puede tener varios elementos de formato separados por comas.</li>
              <li>Cada elemento de un formato, incluso el primero, puede estar seguido o precedido de una serie de saltos de l√≠neas (<code>/c</code>), de escritura de blancos (<code>Xc</code>) o de escritura de literales (<code>"Hola"</code>). Pero s√≥lo se editan cuando el elemento siguiente del formato es usado, por tanto, no pueden estar solos en un formato.</li>
              </ul>

            <h4>Ubicaci√≥n de Formatos</h4>
            <p><b>En una orden PRINT= o ASK=:</b></p>
            <p>Un formato aparece 0 a n veces.</p>
            <p><b>En la orden FMT:</b></p>
            <p>Un formato aparece 1 vez en la orden <code>FMT ( )</code>, d√≥nde el n√∫mero es puesto en un <code>PRINT=</code>. Esta orden <code>FMT</code> no es ejecutable y tiene que ponerse antes de una orden de ruptura de secuencia incondicional (<code>STOP</code>, <code>GOTO</code>, etc.).</p>
            <pre><code>PRINT=1:( E , N4Z.N2 ) , "Precio : ",P1,tabv(1)
*
*   o bien, y es equivalente
*
PRINT=1,9950: "Precio : ",P1,tabv(1)
-
stop
9950 FMT ( E , N4Z.N2 )</code></pre>

            <p>Se tiene: Edici√≥n de "Precio : " en formato E libre. Edici√≥n de P1 con formato N4Z.N2 (1 a 5 cifras antes de la coma, 0 a 2 cifras despu√©s de la coma). 1 salto de l√≠nea y el cursor al principio de ella.</p>
            <p><b>En la orden FM:</b></p>
            <p>Un formato aparece 1 a n veces en una orden <code>A1= FM ( )</code>, donde A1 es una variable cadena que contendr√° el formato definido en <code>FM ( )</code>. Entonces A1 ser√° puesto entre par√©ntesis y usado como elemento de formato de un <code>PRINT=</code> o <code>ASK=</code>.</p>
            <pre><code>dcl A1$
-
segment 0
A1=FM ( NZ , U2 )
print=1:I0,tabv(2),(  ( A1 ) , Z3 ) , V1,V2,V3
*
*   o bien, y es equivalente
*
print=1:I0,tabv(2),( NZ , U2 , Z3 ) , V1,V2,V3</code></pre>

            <p>Donde:</p>
            <ul>
              <li>Edici√≥n de I0 en formato libre, 2 saltos de l√≠nea y principio</li>
              <li>Edici√≥n de V1 con el formato NZ</li>
              <li>Edici√≥n de V2 con el formato U2</li>
              <li>Edici√≥n de V3 con el formato Z3</li>
              </ul>

            <h4>Circularidad de Formatos</h4>
            <p>En las √≥rdenes <code>PRINT=</code> y <code>ASK=</code>, la aparici√≥n de un nuevo formato anula autom√°ticamente el precedente, incluso si no hab√≠a sido usado.</p>
            <p>El formato es circular, es decir que antes del uso de su √∫ltimo elemento, se comenzar√° por el primero para la utilizaci√≥n siguiente, salvo que se active un nuevo formato entre par√©ntesis <code>( )</code> en la misma orden <code>PRINT=</code> o <code>ASK=</code>.</p>
            <pre><code>PRINT=1:( E , N4Z.N2 ) , "Precio : ",P1,tab(50),"Total : ",T1,tabv(1)</code></pre>

            <p>Donde:</p>
            <ul>
              <li>Edici√≥n de "Precio : " con formato E libre</li>
              <li>Edici√≥n de P1 con formato N4Z.N2 (1 a 5 cifras antes de la coma y 0 a 2 cifras despu√©s de la coma)</li>
              <li>Despu√©s en la columna 50 <code>tab(50)</code></li>
              <li>Edici√≥n de "Total : " con formato E de nuevo</li>
              <li>Edici√≥n de T1 con formato N4Z.N2 de nuevo</li>
              <li>1 salto de l√≠nea y el cursor al principio</li>
              </ul>

            <h4>Formatos en ASK=</h4>
            <p>En el <code>ASK=</code>, el mismo formato puede servir tanto para la salida como para la entrada de informaciones.</p>
            <p>En una orden <code>ASK=</code> las constantes a editar (por ej: "Cantidad : ") salen en formato libre sin usar elementos de formatos. Por contra en una orden <code>PRINT=</code> las constantes a editar (por ej: "Cantidad : ") usan el elemento siguiente del formato en curso, si este ha sido definido.</p>
            <hr />

            <h3>Formato Libre</h3>

            <p>Si no se define un formato en un <code>PRINT=</code> o <code>ASK=</code> el sistema utiliza el formato libre. Despu√©s de definir un formato se puede seleccionar el formato libre por el c√≥digo formato <code>E</code>, es pr√°ctico para editar una constante en un <code>PRINT=</code>.</p>
            <h4>Comportamiento del Formato Libre</h4>
            <table>
              <thead>
                <tr>
                  <th>Tipo</th>
                  <th>Comportamiento</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Constante</td>
                  <td>Se edita tal cual como es presentada, el n√∫mero de columnas utilizadas es igual al n√∫mero de caracteres a editar.</td>
                </tr>
                <tr>
                  <td>Expresi√≥n cadena (salvo SHL)</td>
                  <td>Los espacios a la derecha no se editan.</td>
                </tr>
                <tr>
                  <td>Variable cadena</td>
                  <td>El n√∫mero de caracteres editados es igual a la longitud declarada para esta variable.</td>
                </tr>
                <tr>
                  <td>Num√©rico corto</td>
                  <td>El sistema utiliza 6 columnas, los ceros no significativos se reemplazan por espacios, el signo + es reemplazado por un espacio, el signo menos est√° en la primera columna, el n√∫mero es cuadrado a la derecha.</td>
                </tr>
                <tr>
                  <td>Num√©rico largo</td>
                  <td>El sistema utiliza 30 columnas, los ceros no significativos se reemplazan por espacios, el signo + es reemplazado por un espacio, el signo menos est√° en la primera columna, las unidades est√°n siempre en 15¬™ columna. Se tiene pues: 1 signo, 14 cifras, la coma, 14 cifras.</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Elemento de Formato</h3>

            <h4>Definici√≥n</h4>
            <p>Un formato es una sucesi√≥n de elementos de formato separados por comas.</p>
            <ul>
              <li>En un <code>PRINT=</code> un elemento de formato define la edici√≥n de una expresi√≥n, de una variable o de una constante.</li>
              <li>En un <code>ASK=</code> un elemento de formato define la edici√≥n de una expresi√≥n o de una variable, o la entrada de una variable.</li>
              <li>En un <code>ASK=</code> la edici√≥n de una constante no usa elementos de formato.</li>
              </ul>

            <h4>Composici√≥n</h4>
            <p>Un elemento de formato est√° constituido por una sucesi√≥n de "C√≥digos Formatos" (<code>A</code>, <code>U</code>, <code>N</code>, <code>Z</code>, ...) puesto sucesivamente.</p>
            <p>Cada c√≥digo formato define a priori para cada car√°cter (o una columna):</p>
            <ul>
              <li>El tipo de car√°cter v√°lido (letra, cifra, signo, ...)</li>
              <li>La presencia obligatoria u opcional de este car√°cter, en entrada o en edici√≥n</li>
              </ul>

            <p>Los "C√≥d. Formato" obligatorios definen el n√∫mero m√≠nimo de caracteres a introducir.</p>
            <p>Los "C√≥d. Formato" definen tambi√©n el n√∫mero m√°ximo de caracteres a editar y/o introducir.</p>
            <p>Despu√©s de edici√≥n si el n√∫mero m√°ximo de caracteres es de N, el cursor est√° siempre en la posici√≥n N+1.</p>
            <p>En un <code>ASK=</code> si el n√∫mero de caracteres m√°ximo es de N, despu√©s de la introducci√≥n, el cursor estar√° en la posici√≥n N+1 salvo si el c√≥digo formato <code>F</code> sea utilizado. Para ir a la posici√≥n N+1 el sistema, despu√©s de la validaci√≥n, env√≠a blancos si el n√∫mero de caracteres m√°ximo no han sido grabados.</p>
            <p><b>Nota:</b> En un elemento de formato, la repetici√≥n del mismo c√≥digo formato puede reemplazarse por este c√≥digo m√°s una cifra. Por ejemplo <code>( NNNN )</code> es <code>( N4 )</code>.</p>
            <hr />

            <h3>C√≥digos de Formato</h3>

            <h4>Caracteres</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Definici√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>U</code></td>
                  <td>1 car√°cter CUALQUIERA OBLIGATORIO</td>
                </tr>
                <tr>
                  <td><code>W</code></td>
                  <td>1 car√°cter CUALQUIERA NO OBLIGATORIO. Ej: <code>( UW9 )</code> significa introducir o editar 1 a 10 caracteres cualquiera.</td>
                </tr>
                <tr>
                  <td><code>A</code></td>
                  <td>1 car√°cter ALFAB√âTICO OBLIGATORIO</td>
                </tr>
                <tr>
                  <td><code>D</code></td>
                  <td>1 car√°cter ALFAB√âTICO NO OBLIGATORIO. Ej: <code>( AD14 )</code> significa introducir o editar 1 a 15 caracteres alfab√©ticos.</td>
                </tr>
                <tr>
                  <td><code>E</code></td>
                  <td>Formato Libre y/o el fin de la cadena en c√≥digo W. Ej: <code>( E )</code> significa formato libre. <code>( AD2E )</code> significa 1 a 3 caracteres Alfab√©ticos y el fin de la cadena con cualquier car√°cter.</td>
                </tr>
                <tr>
                  <td><code>B</code></td>
                  <td>1 car√°cter ALFANUM√âRICO OBLIGATORIO</td>
                </tr>
                <tr>
                  <td><code>C</code></td>
                  <td>1 car√°cter ALFANUM√âRICO NO OBLIGATORIO. Ej: <code>( B3C4 )</code> significa 3 a 7 caracteres Alfanum√©ricos.</td>
                </tr>
                <tr>
                  <td><code>F</code></td>
                  <td>Se pone al final de un elemento de formato de entrada. Despu√©s de la validaci√≥n, si s√≥lo restan caracteres no obligatorios, el sistema dejar√° el cursor d√≥nde est√° en lugar de enviar blancos hasta el fin de la zona de entrada. Ej: <code>( AD14F )</code> si se pone PEPITO, despu√©s de la entrada el cursor estar√° detr√°s de la O de PEPITO y el sistema no env√≠a 9 blancos para poner el cursor en la 16¬™ posici√≥n.</td>
                </tr>
              </tbody>
            </table>

            <h4>Num√©ricos</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Definici√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>Z</code></td>
                  <td>1 CIFRA OBLIGATORIA</td>
                </tr>
                <tr>
                  <td><code>N</code></td>
                  <td>1 CIFRA NO OBLIGATORIA. Ej: <code>( N3Z )</code> significa 1 a 4 cifras sin signo.</td>
                </tr>
                <tr>
                  <td><code>+</code></td>
                  <td>Signo + y - OBLIGATORIOS, continuaci√≥n din√°mica. Ej: <code>( +Z2 )</code> 2 cifras, el signo se edita o se pide siempre.</td>
                </tr>
                <tr>
                  <td><code>-</code></td>
                  <td>Signo + y - AUTORIZADOS, continuaci√≥n din√°mica. Ej: <code>( -N3Z )</code> 1 a 4 cifras con signo, el signo + se reemplaza por un blanco en la edici√≥n, en entrada el + es opcional.</td>
                </tr>
              </tbody>
            </table>

            <h4>Signos Din√°micos</h4>
            <p><code>( +4Z )</code> es equivalente a un formato <code>( +N3Z )</code> por el signo.</p>
            <p><code>( -4Z )</code> es equivalente a un formato <code>( -N3Z )</code> por el signo.</p>
            <p>Es decir, que el signo no ser√° puesto en la primera columna de la izquierda, pero en alguna de las cuatro primeras <code>(+4..)</code>, la de la derecha es la que debe estar a blancos.</p>
            <p>Suponiendo que la escritura comienza despu√©s de los dos puntos con el formato <code>( +4Z )</code>:</p>
            <ul>
              <li>El valor 1234 se escribe: <code>+1234</code></li>
              <li>El valor -0123 se escribe: <code> -123</code></li>
              <li>El valor +0012 se escribe: <code>  +12</code></li>
              <li>El valor -0005 se escribe: <code>   -5</code></li>
              </ul>

            <p>Con el formato <code>( +3NZ )</code> el valor -0005 se escribe: <code>  - 5</code></p>
            <h4>Coma y Separadores</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Definici√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>V</code></td>
                  <td>Coma interna. Posici√≥n de la coma en los c√°lculos.</td>
                </tr>
                <tr>
                  <td><code>.</code></td>
                  <td>Coma externa. Posici√≥n de la coma pedida o editada. Si no existe c√≥digo V la coma est√° en el mismo sitio tanto si es interna como externa. En la entrada el operador puede cambiar la coma por el punto. En la edici√≥n el car√°cter editado depende de la lengua elegida durante la configuraci√≥n del sistema PROLOGUE. En Franc√©s la coma se usa como separador. Ej: <code>( N3Z.N2 )</code> permite grabar o editar 1 a 4 cifras antes de la coma, despu√©s la coma y luego 0 a 2 cifras. Usar un formato <code>( N3Z.N2V )</code> permite por ejemplo: grabar y/o editar un n√∫mero en francos con dos cifras despu√©s de la coma y tratarlo en c√©ntimos, as√≠ pues, la entrada de 1,25 (francos) dar√° el valor 125 (c√©ntimos) en forma interna (para los c√°lculos).</td>
                </tr>
                <tr>
                  <td><code>S</code> o <code>S( c )</code></td>
                  <td>Un separador "c" (c siendo el car√°cter definido entre par√©ntesis), o por defecto de (c) el punto "." o la coma "," se editar√°n para separar un grupo de 3 cifras cuando se edite el n√∫mero. Si est√° puesto el separador, este es siempre diferente del separador de las unidades y las d√©cimas. Ej: <code>( S( )N7Z.N2 )</code> edita el valor 12345678.91 como: <code>12 345 678,91</code></td>
                </tr>
              </tbody>
            </table>

            <h4>Otros C√≥digos</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Definici√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>L</code></td>
                  <td>El signo se pondr√° despu√©s de las unidades. Se pone al principio del formato delante del + o - y despu√©s de la S (si existe). Ej: <code>( L+N3Z )</code> edita el valor +12 como: <code>12+</code>. <code>( S( )L+N9Z.N2 )</code> edita 1234567890.12 como: <code>1 234 567 890,12+</code></td>
                </tr>
                <tr>
                  <td><code>*</code></td>
                  <td>Certificaci√≥n: Los ceros de la izquierda no significativos se reemplazan por asteriscos. Este c√≥d. formato s√≥lo se puede usar para los n√∫meros sin signo. Se pone al principio del formato. Ej: <code>( <i>N4Z )</code> edita el valor 12 como: <code></i>**12</code></td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Elementos de Formato Especiales</h3>

            <p>Estos elementos no pueden estar solos en un formato. Se editan al mismo tiempo que la pr√≥xima expresi√≥n, variable o constante, que usar√° el formato siguiente. Las tabulaciones que les preceden no ser√°n eficaces si hay una tabulaci√≥n entre el final del formato y la expresi√≥n, la variable o la constante a editar.</p>
            <table>
              <thead>
                <tr>
                  <th>Forma</th>
                  <th>Definici√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>/c</code></td>
                  <td>Hacer c saltos de l√≠nea e ir al principio de ella. c es una constante positiva. Ej: <code>( /2,E),"HOLA"</code> hace 2 saltos de l√≠nea y escribe HOLA en principio de esa l√≠nea.</td>
                </tr>
                <tr>
                  <td><code>Xc</code></td>
                  <td>Editar c blancos. c es una constante. Ej: <code>( E,X5,E),"HOLA",NOMBRE</code> habr√° entonces 5 blancos entre la A de HOLA y el principio del nombre.</td>
                </tr>
                <tr>
                  <td><code>"Literal"</code></td>
                  <td>Edita el texto "Literal" que est√° entre comillas. Ej: <code>( "HOLA     ",E) , NOMBRE</code> da el mismo resultado que el ejemplo de arriba, puesto que hay 5 blancos en el literal y no hay tabulaci√≥n entre el formato y la variable NOMBRE.</td>
                </tr>
              </tbody>
            </table>

            <h4>Tabla Resumen de C√≥digos</h4>
            <table>
              <thead>
                <tr>
                  <th></th>
                  <th>CUALQUIERA</th>
                  <th>ALFAB√âTICOS</th>
                  <th>ALFANUM√âRICO</th>
                  <th>CIFRAS</th>
                  <th>SIGNO</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>OBLIGATORIO</b></td>
                  <td>U</td>
                  <td>A</td>
                  <td>B</td>
                  <td>Z</td>
                  <td>+</td>
                </tr>
                <tr>
                  <td><b>OPCIONALES</b></td>
                  <td>W</td>
                  <td>D</td>
                  <td>C</td>
                  <td>N</td>
                  <td>-</td>
                </tr>
              </tbody>
            </table>

            <p><b>Otros c√≥digos:</b></p>
            <ul>
              <li><code>E</code> - Formato libre</li>
              <li><code>F</code> - No pone el cursor al final de la zona de entrada de una cadena</li>
              <li><code>L</code> - Signo a la derecha</li>
              <li><code>*</code> - Rellenar un n√∫mero sin signo por asteriscos</li>
              <li><code>.</code> - Coma para entrada o edici√≥n e interna por defecto de V</li>
              <li><code>V</code> - Coma interna (para c√°lculos), si es diferente de la posici√≥n en que se ha grabado</li>
              <li><code>S</code> - El separador de num√©ricos es "." a priori o "," si el separador de decimales es el punto</li>
              <li><code>S(c)</code> - El separador de num√©ricos es c donde c es una constante</li>
              </ul>

            <hr />

            <h3>Formatos Definidos Din√°micamente</h3>

            <p>Los formatos pueden estar definidos din√°micamente. Para esto es preciso utilizar los formatos contenidos en una cadena de caracteres <code>( A1 )</code>, y declarando esta cadena en equivalencia por num√©ricos cortos de 1 octeto, se puede inicializar el formato din√°micamente con un valor num√©rico.</p>
            <h4>Estructura de un Formato Din√°mico</h4>
            <p>Un formato est√° entonces constituido:</p>
            <ul>
              <li>De N octetos correspondientes a los c√≥digos formatos de un elemento de formato</li>
              <li>Opcionalmente de un separador de elementos despu√©s de otro elemento de formato, esto N veces</li>
              <li>De un c√≥digo de fin de formato</li>
              </ul>

            <h4>Tabla de Correspondencia</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>U</th>
                  <th>A</th>
                  <th>N</th>
                  <th>Z</th>
                  <th>.</th>
                  <th>+</th>
                  <th>-</th>
                  <th>E</th>
                  <th>/</th>
                  <th>X</th>
                  <th>L</th>
                  <th>,</th>
                  <th>"LITERAL"</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Valor decimal</td>
                  <td>0</td>
                  <td>1</td>
                  <td>2</td>
                  <td>3</td>
                  <td>5</td>
                  <td>6</td>
                  <td>7</td>
                  <td>8</td>
                  <td>9</td>
                  <td>10</td>
                  <td>11</td>
                  <td>13</td>
                  <td>12,Long,Literal</td>
                </tr>
              </tbody>
            </table>

            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>W</th>
                  <th>B</th>
                  <th>C</th>
                  <th>D</th>
                  <th>*</th>
                  <th>Finalizador</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Valor decimal</td>
                  <td>14</td>
                  <td>15</td>
                  <td>16</td>
                  <td>17</td>
                  <td>18</td>
                  <td>255</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplos</h4>
            <pre><code>A1=FM ( N3.Z4 )
; A1 contiene: 02 03 05 03 04 255
;              N  3  .  Z  4  Terminal

A1=FM ( A10, /3, X7, B3, N6 )
; A1 contiene: 01 10 13 09 03 13 10 07 13 15 03 13 02 06 255
;              A  10 ,  /  3  ,  X  7  ,  B  3  ,  N  6  Terminal

A1=FM ( A10, "ABC" )
; A1 contiene: 01 10 13 12 03 65 66 67 255
;              A  10 ,  " long A  B  C  Terminal</code></pre>

            <hr />

            <h3>MASK - M√°scara de Control</h3>

            <p>Dos √≥rdenes permiten programar la entrada de informaciones a partir del teclado:</p>
            <ul>
              <li>La orden <code>MASK</code> que define los par√°metros de ejecuci√≥n de la orden <code>ASK=</code></li>
              <li>La orden <code>ASK=</code> que define la entrada, a partir de la pantalla-teclado</li>
              </ul>

            <h4>Definici√≥n de MASK</h4>
            <p>La orden <code>MASK</code> define:</p>
            <ul>
              <li>La reacci√≥n del sistema en caso de error de entrada (el car√°cter tecleado no est√° conforme con el formato en curso)</li>
              <li>Si la validaci√≥n al final de la entrada es obligatoria o no</li>
              <li>Si el operador puede no tener que grabar nueva informaci√≥n (el primer car√°cter tecleado debe ser entonces la validaci√≥n). Por ejemplo: el valor actual es correcto, es validado y no tecleado de nuevo</li>
              <li>Si la informaci√≥n tecleada no tiene que verse en pantalla (sin eco), para poner una palabra de paso o una clave de seguridad</li>
              <li>Si el empleo de la tecla Interrupci√≥n (ESCape o SALIDA) est√° permitido o no</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>MASK N1</code></pre>

            <p>N1 es un num√©rico corto.</p>
            <h4>Funcionamiento</h4>
            <p>Cuando se ejecuta esta orden, la m√°scara se memoriza. Estar√° activa en todo el programa, hasta la ejecuci√≥n de una nueva orden <code>MASK</code>. Por defecto se utiliza la m√°scara 3 (<code>MASK 3</code>).</p>
            <h4>Valores de MASK</h4>
            <p>El valor a utilizar para N1 se obtiene haciendo la suma de uno o varios de los valores siguientes:</p>
            <table>
              <thead>
                <tr>
                  <th>Valor</th>
                  <th>Funci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>1</td>
                  <td>Filtro. Los caracteres err√≥neos no se muestran.</td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>Suena un pitido en caso de error de entrada.</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>En caso de error, borra la zona de entrada, y posiciona el cursor al principio de la zona. Es preciso empezar la entrada de la variable desde el principio.</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>No es necesaria validaci√≥n al final de la zona de entrada, cuando el n√∫mero m√°ximo de caracteres se han tecleado. No obstante, si el formato lo permite (todos los caracteres no son obligatorios) el operador puede validar despu√©s de grabar el n√∫mero m√≠nimo de caracteres y antes de grabar el n√∫mero m√°ximo de caracteres.</td>
                </tr>
                <tr>
                  <td>16</td>
                  <td>Autorizaci√≥n de desv√≠o, en caso de error de entrada, con <code>E=EtiquE</code>. (<code>E=EtiquE</code> es un par√°metro de la "Lista-Desv√≠o" del <code>ASK=</code>).</td>
                </tr>
                <tr>
                  <td>32</td>
                  <td>Si el primer car√°cter tecleado es la validaci√≥n: Ir a ejecutar la instrucci√≥n siguiente, sin modificar la variable de entrada del <code>ASK=</code>.</td>
                </tr>
                <tr>
                  <td>64</td>
                  <td>No Eco: los caracteres tecleados no son mostrados por pantalla. El cursor no se desplaza durante la entrada. Esto permite introducir claves de seguridad.</td>
                </tr>
                <tr>
                  <td>128</td>
                  <td>Prohibici√≥n de desv√≠o en caso de interrupci√≥n (ESCape o SALIDA) con <code>I=EtiquI</code> (<code>I=EtiquI</code> es un par√°metro de la "Lista-Desv√≠o" del <code>ASK=</code>).</td>
                </tr>
              </tbody>
            </table>

            <h4>M√°scaras m√°s Usadas</h4>
            <table>
              <thead>
                <tr>
                  <th>M√°scara</th>
                  <th>Comportamiento</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>3</td>
                  <td>En caso de error: Sonar y no mostrar los caracteres err√≥neos y continuar la entrada.</td>
                </tr>
                <tr>
                  <td>11</td>
                  <td>Como el 3 y adem√°s no validar al final de la zona de entrada.</td>
                </tr>
                <tr>
                  <td>35</td>
                  <td>Como el 3 y adem√°s autorizaci√≥n de validaci√≥n en principio de zona, para no modificar la variable de entrada.</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo</h4>
            <pre><code>segment 0
-
MASK 11 ; Filtro + Pitido si hay error y no validar al final de entrada
ASK=1 : = V</code></pre>

            <hr />

            <h3>ASK= - Entrada por Teclado</h3>

            <h4>Funcionalidad</h4>
            <p>La orden <code>ASK=</code> permite:</p>
            <ul>
              <li>Desv√≠os condicionales (por una "Lista-Desv√≠os") a ciertas direcciones sea seg√∫n el primer car√°cter tecleado, sea en caso de error</li>
              <li>Editar en pantalla:</li>
              <ul>
                <li>Expresiones y variables usando elementos de formato</li>
                <li>Constantes sin usar elementos de formato, al contrario que <code>PRINT=</code></li>
                <li>Tabular y seleccionar atributos</li>
                </ul>
              </ul>

            <ul>
              <li>Introducir el valor de una variable por teclado, bajo el control de un formato y de una m√°scara de entrada</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>ASK=1[,List-Desv√≠o]:[(Format),][Tab-Lista,][Exp]=[(Format),][Tab-Lista,]Var
     `-----v------' `------------v-------------' `------------v-----------'
           !                     !                            !
      Ruptura de          N veces # Print=1               Entrada
      secuencia</code></pre>

            <h4>Par√°metros</h4>
            <table>
              <thead>
                <tr>
                  <th>Par√°metro</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>ASK=1</code></td>
                  <td>1 es el n√∫mero de la pantalla-teclado que ejecuta el programa, tanto en monopuesto como en multipuesto.</td>
                </tr>
                <tr>
                  <td><code>List-Desv√≠o</code></td>
                  <td>Lista de par√°metros de desv√≠o bien sea seg√∫n el primer car√°cter tecleado, bien sea en caso de error. Cada par√°metro est√° separado del siguiente por una coma.</td>
                </tr>
                <tr>
                  <td><code>: =</code></td>
                  <td>Todo lo comprendido entre dos puntos ":" e igual "=" corresponde a un <code>PRINT=1</code> (edici√≥n en pantalla). Las constantes a editar no usan elementos de formato. Puede no haber ning√∫n par√°metro entre : y =</td>
                </tr>
                <tr>
                  <td><code>=[ ,]Var</code></td>
                  <td>Corresponde a la entrada. Var es la variable de recepci√≥n de la informaci√≥n grabada por teclado. Todos los tipos de variables est√°n autorizados. Las tabulaciones y los atributos pueden estar antes o despu√©s del car√°cter igual =. El pr√≥ximo elemento del formato en curso, usado para la edici√≥n entre : y =, puede ser usado para la entrada de la variable Var. En este caso no hay que poner formato despu√©s del car√°cter igual =</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejecuci√≥n de ASK=</h4>
            <p>En el curso de la ejecuci√≥n de <code>ASK=</code>:</p>
            <ol>
              <li>Hay acceso a edici√≥n por pantalla de todo lo comprendido entre los dos puntos : y el car√°cter igual = (# <code>PRINT=1</code>).</li>
            </ol>

            <ol>
              <li>Despu√©s el sistema espera:</li>
            </ol>

            <p>   - Bien el primer car√°cter tecleado, para un desv√≠o de la "List-Desv√≠o". Despu√©s de haber grabado varios caracteres se puede volver al primer car√°cter utilizando las flechas. Si un desv√≠o se produce en este momento, los caracteres ya tecleados permanecen en pantalla, pero no afectan a la variable de entrada "Var". Conviene reeditar el contenido de la variable "Var" por un <code>PRINT=1</code>, despu√©s de cada introducci√≥n, por si acaso el <code>MASK 32</code> y/o un desv√≠o ha sido autorizado seg√∫n el primer car√°cter tecleado.</p>
            <p>   - O bien la entrada de la variable "Var" seg√∫n el formato en curso, o el formato libre. Despu√©s de la entrada el cursor estar√°, a priori, en la columna correspondiente a la longitud m√°xima definida por el formato, sea cual sea el n√∫mero de caracteres realmente tecleados. La parte de zona no tecleada es puesta a blancos, salvo si el c√≥digo formato "F" ha sido utilizado. En este caso: el cursor queda en la columna d√≥nde se encuentra en el curso de la validaci√≥n.</p>
            <ol>
              <li>En la entrada de datos:</li>
            </ol>

            <p>   - El control de formato se hace car√°cter a car√°cter. El sistema reacciona seg√∫n la m√°scara (<code>MASK</code>). Si no hay m√°scara, y en caso de error, la pantalla emite un pitido, el car√°cter err√≥neo no se edita y la entrada prosigue (<code>MASK 3</code>).</p>
            <p>   - El operador puede modificar la informaci√≥n que est√° grabando:</p>
            <p>     - Bien tecleando Anulaci√≥n (Tecla CTRL y C simult√°neamente). La informaci√≥n tecleada se borra de la pantalla y la entrada retorna al primer car√°cter, al principio de la zona de entrada.</p>
            <p>     - O desplazando el cursor con las teclas "Flecha izquierda" y "Flecha derecha", y despu√©s corregir uno o varios caracteres ya tecleados.</p>
            <p>   - Si, y s√≥lo si, la zona a teclear es una cadena, el operador puede visualizar y modificar el antiguo campo sin volver a introducirlo dando a la tecla "Flecha a derecha".</p>
            <ol>
              <li>Al terminar la entrada de una variable:</li>
            </ol>

            <p>   - Antes de validar es necesario llevar el cursor a fin de campo, s√≥lo los caracteres precedentes a la validaci√≥n son tenidos en cuenta.</p>
            <hr />

            <h3>Lista de Desv√≠os en ASK</h3>

            <p>La "List-Desv√≠os" se pone en un <code>ASK=</code>, entre el <code>ASK=1</code> y los dos puntos ":". La "List-Desv√≠os" es optativa.</p>
            <p>Cada elemento de la Lista-Desv√≠os est√° separado del anterior por una coma, el orden de ellos es indiferente.</p>
            <p>Un elemento de la Lista-Desv√≠os tiene la siguiente forma:</p>
            <pre><code>C√≥digo-Desv√≠o = Etiqueta de Desv√≠o (constante)</code></pre>

            <h4>Elementos de Lista-Desv√≠os</h4>
            <pre><code>[,E=Eerr][,I=Einter][,U=Eup][,D=Edown][,L=Eleft][,"Car"=Ecar][,/HH=Ehh]
                                                `----------v----------'
                                                         N Veces</code></pre>

            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>E=Eerr</code></td>
                  <td>En caso de error y si la m√°scara 16 est√° seleccionada, ir a ejecutar la instrucci√≥n cuya etiqueta es Eerr.</td>
                </tr>
                <tr>
                  <td><code>I=Einter</code></td>
                  <td>Si el primer car√°cter tecleado es la tecla "Interrupci√≥n" (ESCape o SALIDA), y si la m√°scara 128 no est√° seleccionada, ir a ejecutar la instrucci√≥n cuya etiqueta es Einter.</td>
                </tr>
                <tr>
                  <td><code>U=Eup</code></td>
                  <td>Si el primer car√°cter tecleado es la tecla "Up" (Flecha arriba) ir a ejecutar la instrucci√≥n cuya etiqueta es Eup.</td>
                </tr>
                <tr>
                  <td><code>D=EDown</code></td>
                  <td>Si el primer car√°cter tecleado es la tecla "Down" (Flecha Abajo), ir a ejecutar la instrucci√≥n cuya etiqueta es Edown.</td>
                </tr>
                <tr>
                  <td><code>L=Eleft</code></td>
                  <td>Si el primer car√°cter tecleado es la tecla "Left" (Flecha a la Izquierda), ir a ejecutar la instrucci√≥n cuya etiqueta es Eleft.</td>
                </tr>
                <tr>
                  <td><code>"Car"=Ecar</code></td>
                  <td>"Car" es una constante o una variable de tipo cadena que contiene uno o varios caracteres editables. Si el primer car√°cter tecleado est√° en "Car": Este se edita en pantalla despu√©s el sistema va a ejecutar la instrucci√≥n cuya etiqueta es Ecar. El car√°cter no es puesto en la variable de recepci√≥n.</td>
                </tr>
                <tr>
                  <td><code>/HH=Ehh</code></td>
                  <td>Si el primer car√°cter tecleado es en forma hexadecimal de valor HH, no se edita este car√°cter en pantalla y luego se va a ejecutar la instrucci√≥n cuya etiqueta es Ehh. /HH puede tomar cualquier valor comprendido entre /00 y /EF. El valor /0D est√° autorizado, corresponde a la validaci√≥n y es prioritario en la m√°scara 32 (<code>MASK 32</code> ir a la instrucci√≥n siguiente si el primer car√°cter es la validaci√≥n).</td>
                </tr>
              </tbody>
            </table>

            <p><b>Nota:</b> Todos los c√≥digos de desv√≠o (excepto E=Eerr) corresponden obligatoriamente al car√°cter tecleado en la primera columna de entrada. Si un car√°cter (o m√°s) ya se ha grabado, e incluso en caso de error, es preciso Anular el campo para poder accionar uno de los c√≥digos de desv√≠o.</p>
            <h4>Teclas de Funci√≥n por Defecto (90-50)</h4>
            <table>
              <thead>
                <tr>
                  <th>Tecla</th>
                  <th>Valor</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>F1</td>
                  <td>/80</td>
                </tr>
                <tr>
                  <td>F2</td>
                  <td>/81</td>
                </tr>
                <tr>
                  <td>F3</td>
                  <td>/82</td>
                </tr>
                <tr>
                  <td>F4</td>
                  <td>/83</td>
                </tr>
                <tr>
                  <td>F5</td>
                  <td>/84</td>
                </tr>
                <tr>
                  <td>F6</td>
                  <td>/85</td>
                </tr>
                <tr>
                  <td>F7</td>
                  <td>/86</td>
                </tr>
                <tr>
                  <td>F8</td>
                  <td>/87</td>
                </tr>
                <tr>
                  <td>F9</td>
                  <td>/88</td>
                </tr>
                <tr>
                  <td>F10</td>
                  <td>/89</td>
                </tr>
                <tr>
                  <td>F11</td>
                  <td>/8A</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Ejemplo Completo: Di√°logo de Entrada</h3>

            <pre><code>program "Di√°logo"
dcl  REP#                   ; Respuesta 0 = Ok, 1 = Interrupci√≥n
-
dcl  NOM$=10                ; Nombre del producto. Cadena de 10 caracteres
dcl  CANT%                  ; Cantidad. N√∫m. Corta Dos Octetos
dcl  PREC                   ; Precio. N√∫m. larga 8 Octetos: 14 cifras
-

     SEGMENT 0
     -
100  -                      ; Men√∫ principal
     -
     gosub 5000             ; S/P Di√°logo
     if REP&lt;&gt;0 goto 9990    ; Abandono operador
     -
     -
*
***         S/P de ENTRADA
*
*   ATENCION las √≥rdenes ASK= se escriben en una sola instrucci√≥n
*
5000 REP=0                  ; Ok a priori
     MASK 35                ; Suena + Filtro + si 1er Car. es Valid ir a la
                            ; instrucci√≥n siguiente
*
5010 ASK=1,I=5098,D=5012 : tab(10,5) , "Nombre" , ( UW9 ) , tab(30) , NOM
     , tab(50) , gener(10,".") = tab(50) , NOM      ; 1 a 10 caracteres
5012 print=1:( UW9 ) , tab(30) , NOM , atb(21)      ; Edici√≥n correcta
*                           atb(21) borra el fin de la l√≠nea
5020 ASK=1,I=5098,U=5010,D=5022:tab(10,5),"Cantidad",(N3Z,U4),tab(30),CANT
     ,tab(50),gener(4,".")=tab(50),CANT ; entero 1 a 4 cifras sin signo
5022 print=1:(   N3Z ),tab(30),CANT,atb(21)         ; Edici√≥n correcta
*
5030 ASK=1,I=5098,U=5020,D=5032:tab(10,9),"Prec",(N4Z.N2,U8),tab(30),PREC
     ,tab(50),gener(8,".")=tab(50),PREC     ; La Entrada se hace en Francos
*                           ; 1 a 5 cifras coma 0 a 2 decimales
*
5032 fix=fix(PREC,2)        ; Cuadra para Clave de Acceso eventualmente
     print=1:(N4Z.N2 ),tab(30),PREC,atb(21)
*
*
     goto 5099              ; Fin Ok
5098 REP=1                  ; Salida si hay Interrupci√≥n
5099 RETURN                 ; Vuelta del sub-programa
*
9990 stop
     eseg 0
     end</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 9: Los M√©todos de Acceso</h2>

            <p><b>Directo, Relativo, Secuencial, Secuencial Indexado</b></p>
            <h3>Contenido del Cap√≠tulo</h3>

            <ul>
              <li>M√©todos de acceso</li>
              <li>Generalidades, las informaciones transferidas</li>
              <li>Asignaciones: <code>ASSIGN=</code></li>
              <li>Atributo de asignaci√≥n: <code>ATB=</code></li>
              <li>Acceso directo a un soporte: <code>IO=</code>, <code>VOLUME=</code>, <code>CATALOG=</code></li>
              <li>√ìrdenes Generales: <code>CFILE=</code>, <code>DFILE=</code>, <code>RENAME=</code>, <code>EXTEND=</code>, <code>OPEN=</code>, <code>CLOSE=</code></li>
              <li>Acceso Relativo: <code>READ=</code>, <code>WRITE=</code></li>
              <li>Acceso Secuencial: <code>READ=</code>, <code>BACKSPACE=</code>, <code>MODIF=</code>, <code>WRITE=</code></li>
              <li>Acceso Secuencial Indexado: <code>INSERT=</code>, <code>DELETE=</code>, <code>SEARCH=</code>, <code>SEARCH.L=</code>, <code>SEARCH.M=</code>, <code>SEARCH.ML=</code>, <code>MODIF=</code>, <code>DOWN=</code>, <code>UP=</code>, <code>DOWN.L=</code>, <code>UP.L=</code>, <code>DOWN.M=</code>, <code>UP.M=</code>, <code>DOWN.ML=</code>, <code>UP.ML=</code></li>
              </ul>

            <hr />

            <h3>M√©todos de Acceso</h3>

            <p>En un soporte magn√©tico las informaciones pueden tener diferentes m√©todos de organizaci√≥n. Se puede siempre acceder a una informaci√≥n, para consultarla, con un m√©todo de acceso menos evolucionado que el m√©todo de organizaci√≥n. Por ejemplo un fichero secuencial podr√° ser duplicado con la ayuda del acceso relativo.</p>
            <p>Los m√©todos de acceso se presentan en orden creciente de su evoluci√≥n, los menos evolucionados se presentan los primeros.</p>
            <hr />

            <h4>Acceso Directo al Soporte</h4>
            <p><code>IO=</code> y Variable Memoria Virtual, <code>VOLUME=</code>, <code>CATALOG=</code></p>
            <p>Es el m√©todo de acceso menos evolucionado.</p>
            <p><code>IO=</code> permite pasar a otra forma la organizaci√≥n del sistema de explotaci√≥n.</p>
            <p>En un soporte sectorizado el programa debe suministrar la direcci√≥n real f√≠sica del primer sector a transferir. El primer sector de un soporte tiene el n√∫mero cero, el siguiente el n√∫mero 1, etc.</p>
            <p>El traspaso de datos se modula por sectores (256 octetos). En un disco flexible la velocidad √≥ptima de transferencia se tiene leyendo/escribiendo 16 sectores (4096 octetos) a la vez.</p>
            <p>En una banda magn√©tica la transferencia se hace por bloques cuya longitud m√°xima es de 4096 octetos.</p>
            <p><code>VOLUME=</code> permite leer las caracter√≠sticas generales de un volumen PROLOGUE.</p>
            <p><code>CATALOG=</code> permite acceder al cat√°logo de un volumen y leer las caracter√≠sticas de un fichero.</p>
            <hr />

            <h4>Acceso Relativo de un Fichero</h4>
            <p><code>READ=</code>, <code>WRITE=</code>, Variable Memoria Virtual</p>
            <p>Este modo de acceso es el m√°s elemental de los que tratan de la organizaci√≥n del sistema de explotaci√≥n (N.G.F.: N√∫cleo Gesti√≥n del sistema de Ficheros). El programa utiliza las √≥rdenes <code>READ=</code>, <code>WRITE=</code> o declara las variables en memoria virtual.</p>
            <h4>El uso de READ= y WRITE= permite:</h4>
            <ul>
              <li>El acceso relativo a un fichero</li>
              <li>El acceso a los recursos del sistema de ficheros por un descriptor. Esto permite llamar a los recursos de teletransmisi√≥n, o cualquier otro recurso que el usuario haya creado y puesto en el sistema PROLOGUE</li>
              </ul>

            <h4>El uso de variables en memoria virtual tiene varios aspectos interesantes:</h4>
            <ul>
              <li>Permite usar tablas (variables) que ocupar√≠an demasiada memoria central.</li>
              <li>Permite almacenar informaciones que no son inicializadas al lanzar la ejecuci√≥n de programas, e incluso pasar par√°metros en programas encadenados.</li>
              <li>Este modo de acceso es m√°s r√°pido que los m√©todos S.I. o M.C. (Secuencial Indexado o Multi-Criterio), sin embargo el programa debe gestionar la organizaci√≥n de sus tablas.</li>
              </ul>

            <p>El √≥ptimo tiempo de acceso en memoria virtual se obtiene declarando las tablas en cadenas de caracteres de 256 octetos, y haciendo despu√©s la equivalencia en memoria central, para descomponer la informaci√≥n.</p>
            <p>En cada referencia a una variable memoria virtual el sistema hace un acceso al fichero para leer o escribir, y ocupa 256 octetos en memoria durante el tiempo de ejecuci√≥n de esta instrucci√≥n.</p>
            <hr />

            <h4>Acceso Secuencial (SQ)</h4>
            <p><code>READ=</code>, <code>WRITE=</code>, <code>BACKSPACE=</code>, <code>MODIF=</code></p>
            <p>Es el modo de acceso de tipo banda magn√©tica, se puede usar tambi√©n en soportes sectorizados (disco duro, disquete...).</p>
            <p>Un fichero se lee registro por registro desde el principio hasta su final, la escritura se hace siempre en fin de fichero. En un soporte sectorizado se puede modificar un registro. En un fichero todos los registros son de la misma longitud. La longitud m√°xima de un registro es de 32767 octetos en un disco.</p>
            <p>Con este m√©todo de acceso la puesta al d√≠a del fin del fichero se hace cuando se cierra dicho fichero y en el curso de la alocaci√≥n de gr√°nulos. Conviene siempre cerrar el fichero (<code>CLOSE=</code>) para no perder registros en el caso de un corte intempestivo del sector.</p>
            <hr />

            <h4>Acceso Secuencial Indexado (S.I.)</h4>
            <p>Este modo de acceso (S.I.) necesita la presencia en el sistema PROLOGUE del m√≥dulo SI.</p>
            <p>Un fichero es un conjunto de registros (o art√≠culos) descompuesto en dos ficheros en el disco:</p>
            <ul>
              <li>Un fichero de tipo <code>-I</code> contiene las claves y los √≠ndices</li>
              <li>Un fichero de tipo <code>-D</code> contiene los datos</li>
              </ul>

            <p>Estos ficheros son de tipo relativo y no se puede acceder a ellos por el m√©todo secuencial, pero hay un acceso secuencial en el m√©todo secuencial indexado.</p>
            <p>1 n√∫mero l√≥gico del programa usa 2 n√∫meros l√≥gicos del BAL. El n√∫mero de n√∫meros l√≥gicos BAL est√° limitado a 32 para un puesto de trabajo.</p>
            <h4>Cada art√≠culo (o registro) se descompone en:</h4>
            <p><b>Una CLAVE</b> que permite designar el art√≠culo que nos interesa.</p>
            <ul>
              <li>Cada art√≠culo s√≥lo posee una clave.</li>
              <li>Cada valor de clave tiene que ser √∫nico en la organizaci√≥n del fichero.</li>
              <li>La longitud de la clave est√° comprendida entre 2 y 51 octetos (standard). Tiene que estar limitada a 40 octetos si se va a transformar este fichero en multicriterio o se le va a incluir en una base de datos.</li>
              <li>La clave puede ser de tipo:</li>
              <ul>
                <li>Cadena (LK o RK) e inicializada en cadena</li>
                <li>Num√©rica (K)</li>
                </ul>
              </ul>

            <p>En un fichero de tipo <b>LK</b>, el sistema cuadra autom√°ticamente las claves a la izquierda, los espacios que est√°n a la izquierda pasan a la derecha.</p>
            <p>En un fichero de tipo <b>RK</b>, el sistema cuadra autom√°ticamente las claves a la derecha, los espacios que est√°n a la derecha pasan a la izquierda.</p>
            <p>En un fichero de tipo <b>K</b>, el sistema no hace cuadre de claves.</p>
            <p>Si la clave est√° compuesta por num√©ricas largas, es preciso hacer la funci√≥n <code>FIX</code> (por ej.: <code>X=fix(X,2)</code>) en cada una de las num√©ricas que componen esta clave, y para cada vez que la clave es un par√°metro de llamada en: <code>INSERT=</code>, <code>SEARCH=</code>, <code>MODIF=</code>, <code>DELETE=</code>. Despu√©s de modificar la clave no son precisos los FIX. Si se quiere poner variables num√©ricas en una clave, por equivalencia, el fichero debe ser creado con el tipo K.</p>
            <hr />

            <h4>Un √çndice</h4>
            <p>(num√©rico corto un octeto <code>#</code>) cuya declaraci√≥n es obligatoria entre la clave y los datos, aunque su uso es opcional.</p>
            <p>El √≠ndice permite definir 8 subniveles en el fichero (1 por bit del octeto del √≠ndice). Un art√≠culo pertenece a un subnivel cuando su bit index correspondiente es un 1. El valor cero est√° prohibido para el √≠ndice, puesto que la clave no pertenece a ning√∫n subnivel.</p>
            <p>Cuando varios bits index, de un mismo art√≠culo, est√°n a 1 simult√°neamente el art√≠culo pertenecer√° a la intersecci√≥n de estos subniveles. Hay hasta 255 intersecciones de subniveles.</p>
            <p>Por defecto, el sistema toma como √≠ndice el valor 1.</p>
            <ul>
              <li>Cuando se graba un art√≠culo (<code>INSERT=</code>) se puede indicar el valor elegido para el √≠ndice.</li>
              <li>Se pueden suprimir uno o varios bits index de un art√≠culo (<code>DELETE=</code>)</li>
              <li>Si se suprimen todos los bits index de un art√≠culo, √©ste es suprimido del fichero (<code>DELETE= ... ,/FF</code>)</li>
              <li>Se puede modificar el valor del √≠ndice de un art√≠culo (<code>MODIF=</code>)</li>
              <li>En una orden de lectura (aleatoria o secuencial) el sistema lee la uni√≥n de subniveles definida por el valor del √≠ndice. Los art√≠culos le√≠dos pueden permanecer simult√°neamente en varios subniveles, una operaci√≥n l√≥gica nos permitir√° volver a la intersecci√≥n que nos convenga.</li>
              </ul>

            <hr />

            <h4>Una zona de datos</h4>
            <p>De longitud fija o variable cuya longitud puede estar comprendida entre 0 y 32767. En longitud variable, se puede elegir en la creaci√≥n del fichero (<code>CFILE=</code>) la longitud m√≠nima de huecos a recuperar. (Ver CFILE=)</p>
            <p>En cada puesta al d√≠a del fichero, es clasificado, reorganizado, y opcionalmente los huecos son recuperados. En todo instante las claves son clasificadas en orden l√≥gico. La clasificaci√≥n es siempre l√≥gica y no f√≠sica, el tiempo de puesta al d√≠a es m√≠nimo.</p>
            <p>Un puntero, para lectura secuencial, puntea siempre la √∫ltima clave referenciada, si existe, o el lugar que tendr√≠a si existiera. Por ejemplo una b√∫squeda (<code>SEARCH=</code>) de la clave "HOL", suponiendo que no exista, dar√° error 78 "Clave inexistente" y una lectura del art√≠culo siguiente dar√° "HOLA".</p>
            <h4>El acceso al fichero es:</h4>
            <ul>
              <li>Bien aleatorio dando la clave y, opcionalmente, el valor del √≠ndice</li>
              <li>O secuencial en el orden de las claves no considerando m√°s que la reuni√≥n de 1 (o m√°s) sub-nivel(s), esto sea a partir del principio del fichero o a partir de la √∫ltima clave referenciada.</li>
              </ul>

            <hr />

            <h4>Declaraci√≥n de Variables para un Registro S.I.</h4>
            <p>La declaraci√≥n debe ser hecha en memoria, despu√©s de <code>FIELD=M</code>, y en orden correlativo obligatoriamente. Las equivalencias est√°n autorizadas, incluso para la clave si es de tipo cadena para los ficheros de tipo LK y RK.</p>
            <ol>
              <li><b>Eventualmente un num√©rico corto 2 octetos (%)</b>, que contendr√° la longitud real de datos del registro que se pueden leer en <code>DOWN.L=</code>, <code>UP.L=</code>, <code>DOWN.ML=</code> y <code>UP.ML=</code>. Esta longitud es la de los datos definidos en el <code>INSERT=</code> o desde el √∫ltimo <code>MODIF=</code> ejecutado y no la longitud de datos que se acaba de leer. Puede ocurrir que s√≥lo se lea el principio del registro, por ej. un error "P√©rdida de informaci√≥n en lectura" se√±ala que no se ha le√≠do m√°s que el principio del registro.</li>
            </ol>

            <ol>
              <li><b>La clave</b> cuya longitud declarada debe ser la que se indica en la creaci√≥n del fichero. (Para todos los DOWN.. y UP..)</li>
            </ol>

            <ol>
              <li><b>El √≠ndice num√©rico corto un octeto (#)</b>. Su declaraci√≥n es obligatoria incluso si no se usa. (Para SEARCH.M= los DOWN y los UP)</li>
            </ol>

            <ol>
              <li><b>Los datos</b> asociados a la clave. (Para INSERT= MODIF= los SEARCH los DOWN y los UP)</li>
            </ol>

            <p>Para <code>SEARCH.L=</code> es preciso declarar: Un num√©rico corto 2 octetos para la longitud, despu√©s de los datos.</p>
            <p>Para <code>SEARCH.ML=</code> es preciso declarar: Un num√©rico corto 2 octetos para la longitud, un num√©rico corto 1 octeto para el √≠ndice, despu√©s de los datos.</p>
            <h4>Ejemplo:</h4>
            <pre><code>FIELD=M         ; Clave C1 de 10; principio datos D1-longitud total=30
dcl L1%         ; Longitud real de datos
dcl C1$=10      ; Clave cadena de 10 caracteres u octetos
dcl I1#         ; Index dcl obligatorio entre clave y datos
dcl D1%         ; Principio de datos: Cantidad 2 octetos
dcl M1%         ; Stock M√≠nimo
dcl P1=8        ; Precio Num√©rico Largo
dcl F1$=18      ; Proveedor     ; FIN de DATOS de un registro
dcl E0%         ; c√≥digo de error
dcl I0#         ; index de llamada para los SEARCH.M los DOWN y los UP
dcl C2$=10      ; Clave para SEARCH.L= o SEARCH.ML= (optativo)
field=m,C1
dcl FILLER=8    ; 8 + 2 = 10 = long. clave
dcl L2%         ; para SEARCH.ML= se tendr√° Longitud, √≠ndice, datos
field=m,C1
dcl FILLER=9    ; 9 + 2 = 11 = long. clave + √≠ndice
dcl L3%         ; para SEARCH.L= se tendr√° Longitud, datos
field=m         ; Fin de equivalencias</code></pre>

            <hr />

            <h4>Diagrama de Declaraci√≥n de Art√≠culo S.I. o M.C.</h4>
            <pre><code>Nombre Programa: ________  Nombre Fichero: STOCK         Fecha: __/__/__

Nombre de CLAVE: C1        Tipo de clave: LK   Longitud de clave:   10

Nombre 1er.dato: D1        Longitud (total M√°ximo) de datos:        30

:-------------------------------------------------------------------------:
! Longitud Real   !     CLAVE     !   INDEX    !         DATOS            !
!   de datos      !               !            !                          !
! 2 octetos  %    ! 2 a 51 octetos! 1 octeto # !     0 a 32767 octetos    !
`-------------------------------------------------------------------------'
FIELD=M
dcl     L1%       ,    C1$=10     ,    I1#     , D1% , M1% , P1=8 , F1$=18;
!                 !               !            !                          !
!                 !               !            ! INSERT=1,C1,I1 : D1,30   !
V                 V               V            V SEARCH=1,C1,I1 : D1,30   !
!                 !               !            !  MODIF=1,C1,I1 : D1,30   !
!                 !               !            `--------&gt;----------------&gt;!
!                 !               ! SEARCH.M=1,C1,I1 : I1,31              !
!                 !               `-----&gt;---------------&gt;----------------&gt;!
!                 !   DOWN=1,I1 : C1,41                                   !
V                 V     UP=1,I1 : C1,41                                   !
!                 ! DOWN.M=1,I1 : C1,41                                   !
!                 !   UP.M=1,I1 : C1,41                                   !
!                 `-----&gt;---------------&gt;---------------&gt;----------------&gt;!
!  DOWN.L=1,I1 : L1,43                                                    !
V    UP.L=1,I1 : L1,43                                                    !
! DOWN.ML=1,I1 : L1,43                                                    !
!   UP.ML=1,I1 : L1,43                                                    !
`-------&gt;---------------&gt;---------------&gt;---------------&gt;----------------&gt;!

                :---------------------------------------------------------:
                ! Longitud Real   !   INDEX    !         DATOS            !
                !   de datos      !            !                          !
                ! 2 octetos  %    ! 1 octeto # !     0 a 32767 octetos    !
FIELD=M,C1      `---------------------------------------------------------'
dcl  FILLER=8   ,      L2%        ;                                       !
field=m         !                                                         !
                V  SEARCH.ML=1,C2,I1 : L2, 33                             !
                `-------&gt;--------------&gt;----------------&gt;----------------&gt;!
dcl C2$=10 ; Clave para SEARCH.ML= y SEARCH.L=
                             :--------------------------------------------:
                             ! Longitud Real   !         DATOS            !
                             !   de datos      !                          !
                             ! 2 octetos  %    !     0 a 32767 octetos    !
FIELD=M,C1                   `--------------------------------------------'
dcl  FILLER=9                ,      L3%        ;                          !
field=m                      !                                            !
dcl C0$=10  ; Doble Clave    V  SEARCH.L=1,C2,I0 : L3, 32                 !
dcl I0#,E%  ; Index,Error    `---------&gt;----------------&gt;----------------&gt;!</code></pre>

            <hr />

            <h4>Acceso Multicriterio (M.C.)</h4>
            <p>Este modo de acceso necesita la presencia en el sistema PROLOGUE, del m√≥dulo MC, y los programas deben ser ejecutados con el Ejecutor (EX) que tenga la opci√≥n MC.</p>
            <p>Este modo de acceso es una evoluci√≥n del m√©todo secuencial indexado (S.I.).</p>
            <ul>
              <li>El m√©todo S.I. permite el acceso o clasificaci√≥n seg√∫n el valor de la clave.</li>
              <li>El m√©todo M.C. (Multi-Criterios) permite el acceso o la clasificaci√≥n seg√∫n el valor de ciertas zonas de datos o de sus combinaciones.</li>
              </ul>

            <p>La longitud m√°xima de la clave es de 40 octetos, la de los datos de 1024 octetos. El n√∫mero de ficheros abiertos simult√°neamente es definido por un par√°metro de configuraci√≥n.</p>
            <p>1 n√∫mero l√≥gico M.C. del programa utiliza:</p>
            <ul>
              <li>4 n√∫meros l√≥gicos del BAL</li>
              <li>3 n√∫meros l√≥gicos S.I.</li>
              <li>4 n√∫meros l√≥gicos NGF</li>
              </ul>

            <p>Los n√∫meros l√≥gicos BAL est√°n limitados a 32 para un puesto de trabajo. El n√∫mero de aperturas M.C. en el mismo programa BAL est√° limitado a 8 como m√°ximo.</p>
            <h4>Declaraci√≥n de variables para un registro M.C.:</h4>
            <p>Es preciso hacer las mismas declaraciones que para un registro S.I. y adem√°s:</p>
            <pre><code>dcl ZONAMC$=20(4) ; Zona de trabajo M.C. cuya longitud es de:
;     20 * N√∫mero de r√∫bricas
;     20 * 4      = 80
dcl Q1(2)       ; Q1(1) = n√∫mero de respuestas para COUNT=
*               ; Q1(2) = n√∫mero de respuestas para POSIT[.D]=
dcl Q$=60       ; Para la pregunta multicriterio.</code></pre>

            <p>Otras declaraciones son necesarias para utilizar la orden <code>STAT=</code></p>
            <hr />

            <h3>Generalidades</h3>

            <h4>Las Informaciones Transferidas: V [, L]</h4>
            <p>Las zonas de transferencia de datos (o informaciones) a menudo se definen de la siguiente forma:</p>
            <pre><code>: [ EtiquErr , E0 , ]  Var [ , Long ]</code></pre>

            <p>Es decir, siempre detr√°s de los dos puntos <code>":"</code></p>
            <ul>
              <li>Estos dos puntos se contin√∫an opcionalmente por:</li>
              <ul>
                <li>Una direcci√≥n (<code>EtiquErr</code>) de desv√≠o en caso de error (c√≥digo de respuesta diferente de cero) y</li>
                <li>Una variable num√©rica corta que contendr√° el c√≥digo respuesta despu√©s de la ejecuci√≥n de la instrucci√≥n.</li>
                </ul>
              </ul>

            <ul>
              <li><code>Var</code> es una variable declarada en memoria. El primer octeto de Var contiene el primer octeto de datos (informaci√≥n) a transferir, los octetos siguientes declarados en memoria contienen los octetos siguientes de los datos a transferir.</li>
              <li><code>Long</code> es un num√©rico corto cuyo valor define el n√∫mero de octetos a transferir, debe ser inicializado antes de llamar al sistema de ficheros. Long es opcional, por defecto la longitud transferida es la definida por la declaraci√≥n de la variable Var. Entonces es el contenido de la variable Var el que es transferido.</li>
              </ul>

            <p>Si se ha declarado en memoria y consecutivamente: <code>Var, V1 ... , VN</code> y si el valor de Long es igual a la suma de las longitudes de estas variables (Var a VN), entonces Long permite transferir <code>Var, V1 ... , VN</code></p>
            <p>En una orden de lectura o escritura, normalmente la longitud pedida <code>[, Long]</code> es igual a la longitud total a transferir. Si la longitud a transferir es m√°s peque√±a que la que se pide <code>[, Long]</code>, el fin de la zona de usuario es puesta a blancos, y no hay error del sistema. Si la longitud a transferir es m√°s grande que la pedida, el sistema no da m√°s que el n√∫mero de octetos pedido y reenv√≠a el error "P√©rdida de informaci√≥n en Lectura" (cuando s√≥lo se puede leer el principio de un registro por ejemplo).</p>
            <h4>Ejemplo:</h4>
            <pre><code>field=m
dcl CANT%           ; Primer dato, num√©rico corto 2 octetos
dcl PRECIO=7        ;              num√©rico largo 7 octetos
dcl PROV$=11        ;   Cadena de        11 octetos : total = 20 octetos
dcl E%              ; Variable para c√≥d. de respuesta
_
* Estas variables ( CANT , PRECIO , PROV ) son inicializadas
*     bien por afectaci√≥n ( c√°lculo... )
*     bien por entradas desde teclado por ASK= , etc ...
* En una instrucci√≥n de transferencia de informaci√≥n, para transferir
*     CANT , PRECIO , PROV  se har√° por ejemplo :
INSERT= ...   :CANT,20     ;   o   INSERT= ...   :9000,E,CANT,20</code></pre>

            <hr />

            <h3>Asignaci√≥n: ASSIGN=</h3>

            <p>Antes de acceder a un soporte o a un fichero es necesario asignarle un n√∫mero l√≥gico. Cuando hay varios par√°metros opcionales en una instrucci√≥n, pueden estar en cualquier orden.</p>
            <h4>Asignaci√≥n de un soporte en acceso directo:</h4>
            <pre><code>ASSIGN=Nlog,"Sup" [ , N√∫mero de sector ][ , WR ][ : EtiquErr,Eo ]</code></pre>

            <ul>
              <li><code>N√∫mero de sector</code>: En memoria virtual √∫nicamente, n√∫mero del primer sector utilizado, cero por defecto.</li>
              </ul>

            <p>Este n√∫mero l√≥gico no puede abrirse por <code>OPEN=</code>, ni cerrarse por <code>CLOSE=</code></p>
            <h4>Asignaci√≥n de un soporte IMpresora (opcional):</h4>
            <pre><code>ASSIGN=Nlog,"Sup.",IM,WR,EX [ : EtiquErr,Eo ]
ASSIGN=Nlog,"Sup.",IM,WR,EX   : [ EtiquErr,Eo, ] ZONAIM [ ,Long ]</code></pre>

            <ul>
              <li>La opci√≥n ZONAIM permite optimizar la velocidad de transferencia en S.P.R.</li>
              <li>La longitud debe ser igual al n√∫mero de caracteres por l√≠nea m√°s 2.</li>
              <li><code>"Sup."</code> es una cadena que contiene el nombre y el n√∫mero de la impresora seguido de un punto: por ejemplo <code>"IM0."</code></li>
              <li><code>Nlog</code> es un num√©rico corto entre 2 y 32 para una impresora.</li>
              <li><code>WR,EX</code> pide la apertura en escritura y en exclusividad.</li>
              </ul>

            <h4>Asignaci√≥n de un fichero relativo o secuencial:</h4>
            <pre><code>ASSIGN=Nlog,"Fich" [,WR][,EX] [ , SQ ] [ , C ] [ : EtiquErr,Eo ]</code></pre>

            <ul>
              <li><code>SQ</code> pide la asignaci√≥n de un fichero secuencial, si no est√° este par√°metro el fichero es asignado en acceso relativo.</li>
              <li>La opci√≥n <code>C</code> pide la apertura en modo copia, los accesos son m√°s r√°pidos, pero las puestas al d√≠a (del descriptor) s√≥lo se hacen al cerrar el fichero.</li>
              <li>Si la opci√≥n C no se usa, el descriptor se pone al d√≠a en cada extensi√≥n del fichero.</li>
              </ul>

            <h4>Asignaci√≥n de un fichero S.I.:</h4>
            <pre><code>ASSIGN=Nlog,"Fich" [,WR][,EX][,C] , SI [ : EtiquErr,Eo ]</code></pre>

            <h4>Asignaci√≥n de un fichero M.C.:</h4>
            <pre><code>ASSIGN=Nlog,"Fich" [,WR][,EX][,C] , MC  : [EtiquErr,Eo,] ZONAMC [ , Long ]</code></pre>

            <p><code>ZONAMC</code> es la zona de trabajo para multicriterio.</p>
            <hr />

            <h4>Definici√≥n de Par√°metros ASSIGN=</h4>
            <p><b>NLOG</b>: es un num√©rico corto entre 1 y 32 en general salvo:</p>
            <ul>
              <li>Para una impresora entonces entre 2 y 32</li>
              <li>En memoria virtual entonces entre 1 y 15</li>
              </ul>

            <p>Se llama n√∫mero l√≥gico, permite un modo de acceso a un soporte o a un fichero, por cambio en el valor de NLOG. Se puede asignar a un mismo soporte o fichero varios n√∫meros l√≥gicos distintos, o pertenecientes a puestos de trabajo diferentes, si la EXclusividad (EX) no se ha pedido. Se puede, opcionalmente, reservar el uso del n√∫mero l√≥gico 2 para las IMpresoras.</p>
            <p><b>"Sup","Sup.","Fich"</b>: Estos par√°metros son cadenas de caracteres. Sup designa un soporte y Fich designa un fichero.</p>
            <p><b>WR</b>: Pide el acceso en escritura. Si falta WR s√≥lo se podr√° leer el soporte o el fichero.</p>
            <p><b>EX</b>: Selecciona el acceso en exclusiva, ser√° pedido en el curso de la apertura (por OPEN= por ejemplo). En este caso el fichero o soporte ser√° abierto en exclusiva como si no hubiera sido abierto por otro n√∫mero l√≥gico o por otro puesto, a continuaci√≥n nadie podr√° abrir este fichero en tanto en cuanto no se cierre o que nuestro puesto de trabajo no retorne al sistema de explotaci√≥n.</p>
            <p>Si no existe el par√°metro EX varios n√∫meros l√≥gicos de un mismo programa o de puestos de trabajo diferentes podr√°n acceder al mismo tiempo al mismo soporte o fichero.</p>
            <h4>En el curso de la ejecuci√≥n de ASSIGN= el sistema:</h4>
            <ul>
              <li>Cierra el n√∫mero l√≥gico si estaba ya abierto por nosotros en este puesto</li>
              <li>Asigna este n√∫mero l√≥gico al soporte o fichero definido.</li>
              <li>El sistema verifica que el nombre es sint√°cticamente correcto. La presencia de "Fich" no se verifica, en efecto, si se desea puede ser creado (<code>CFILE=</code>) el fichero.</li>
              <li>La apertura del fichero o la reserva del soporte s√≥lo ser√° hecha por la orden <code>OPEN=</code> o por la ejecuci√≥n de la primera orden de acceso a este soporte o este fichero.</li>
              </ul>

            <h4>Ejemplo:</h4>
            <pre><code>ASSIGN=1,"FL0.STOCK",WR,SI</code></pre>

            <hr />

            <h3>Atributo de Asignaci√≥n: ATB=</h3>

            <h4>Definici√≥n</h4>
            <p>Los atributos de asignaci√≥n son:</p>
            <p><b>EX</b>: Apertura en exclusividad, un n√∫mero l√≥gico abierto en exclusiva asegura poder leer y/o escribir nosotros solos en este fichero. Esta opci√≥n es obligatoria para las √≥rdenes:</p>
            <ul>
              <li><code>EXTEND=</code> y <code>RENAME=</code> de todos los m√©todos de acceso.</li>
              <li><code>CKEY=</code> y <code>NKEY=</code> de M.C. y de Base de Datos</li>
              <li><code>CFILE=</code>, <code>DFILE=</code>, <code>JOIN=</code>, <code>CJOIN=</code>, <code>RJOIN=</code>, <code>DJOIN=</code> de la Base de Datos</li>
              </ul>

            <p><b>C</b>: Apertura en modo copia. Si un fichero es abierto en modo copia la puesta al d√≠a de su descriptor, en el cat√°logo, s√≥lo se har√° en el cierre del fichero. El modo copia mejora el rendimiento en detrimento de la seguridad. Si despu√©s de seleccionar el modo copia se le suprime, entonces el descriptor se reescribe.</p>
            <p>Estos atributos est√°n disponibles para todos los m√©todos de acceso de PROLOGUE.</p>
            <p>Los atributos de asignaci√≥n pueden ser modificados sin cerrar el fichero por <code>ATB=</code></p>
            <h4>Sintaxis</h4>
            <pre><code>ATB=Nlog [ , EX ] [ , C ] [ : EtiquErr, VarEr ]</code></pre>

            <ul>
              <li><b>Nlog</b>: es un num√©rico corto cuyo valor es el n√∫mero l√≥gico asociado al fichero por <code>ASSIGN=</code></li>
              <li><b>EX</b>: pide la EXclusividad (por defecto en modo particionable)</li>
              <li><b>C</b>: pide el modo Copia (por defecto en modo inmediato)</li>
              <li><b>EtiquErr</b>: es la etiqueta de desv√≠o en caso de error</li>
              <li><b>VarEr</b>: es una variable num√©rica corta que recibir√° el c√≥digo error.</li>
              </ul>

            <p>El orden de opciones no tiene importancia en el fuente BAL, pero en la ejecuci√≥n la opci√≥n EX se posiciona siempre la primera.</p>
            <p>Para seleccionar el modo exclusivo para un fichero abierto en modo partici√≥n, es preciso que el peticionario haya pedido √©l solo la apertura del fichero anteriormente.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl ZONA$=256(4)                ; zona a escribir de 1024 octetos
segment 0
....
ASSIGN=3,"CLIENT",EX,C,WR       ; el fichero CLIENT es asignado en modo
                                ; exclusivo y copia
                                ; es secuencial abierto en lectura/escr
OPEN=3
....
WRITE=3:ZONA(1),1024            ; Escribe, el descriptor no se pone al
                                ; d√≠a
....

ATB=3,C         ; pasa a modo particionable conservando el modo Copia

....

ATB=3           ; pasa a modo inmediato, el descriptor del fichero es
                ; puesto al d√≠a en el cat√°logo.
                ; el puntero de fin de fichero est√° correcto.</code></pre>

            <h4>Errores posibles</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>56</td>
                  <td>Funci√≥n NO SOPORTADA por la configuraci√≥n (PROLOGUE &lt; 2.2)</td>
                </tr>
                <tr>
                  <td>57</td>
                  <td>El fichero no puede asignarse en exclusividad por este n¬∫. l√≥gico, est√° YA ABIERTO en exclusividad.</td>
                </tr>
                <tr>
                  <td>44</td>
                  <td>El fichero no puede asignarse en exclusividad por este n¬∫. l√≥gico, est√° YA ABIERTO en exclusividad. Este c√≥d. de error se da en una apertura siguiente a un ASSIGN=</td>
                </tr>
              </tbody>
            </table>

            <h4>Advertencia</h4>
            <p>Aunque sint√°cticamente es correcto, el modo copia para un fichero usado en lectura solamente es inoperante.</p>
            <hr />

            <h3>Acceso Directo a un Soporte</h3>

            <h4>IO=</h4>
            <p>La ejecuci√≥n de esta orden (<code>IO=</code>) provoca un acceso directo al soporte por llamada a ES: Entrada/Salida general, sin pasar por las estructura de los ficheros de PROLOGUE.</p>
            <h4>Sintaxis</h4>
            <pre><code>IO=Nlog,Funci√≥n [, N√∫mero de sector ] : [ EtiquErr,E0, ] V [ , L ]
                                      [ : EtiquErr,E0  ]</code></pre>

            <h4>Definici√≥n</h4>
            <ul>
              <li>Abre el n√∫mero l√≥gico Nlog (num√©rico corto) si estaba cerrado.</li>
              <li>Ejecuta la funci√≥n pedida seg√∫n el valor del par√°metro Funci√≥n.</li>
              </ul>

            <p><b>Funci√≥n</b>: es un num√©rico corto cuyo valor da el n√∫mero del comando a ejecutar.</p>
            <p><b>N√∫mero de sector</b>: es un num√©rico corto o largo. Su valor da el n√∫mero del primer sector a transferir. El primer sector de un soporte tiene el n√∫mero cero. Por defecto de este par√°metro el valor cero es el utilizado.</p>
            <p><b>V [, L]</b>: Define los datos a transferir. La longitud es igual a K veces 256 octetos, para los accesos a soportes sectorizados.</p>
            <h4>Las principales funciones en un disco son:</h4>
            <table>
              <thead>
                <tr>
                  <th>Funci√≥n</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>/40</code></td>
                  <td>leer 1 o varios sector(es)</td>
                </tr>
                <tr>
                  <td><code>/80</code></td>
                  <td>escribir 1 o varios sector(es)</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo: Copia del disco flexible FL0 en FL1</h4>
            <pre><code>program "COPIA con IO"         ; El disquette FL1 ya est√° premarcado
dcl SECTOR%                    ; N√∫mero del 1er.sector a transferir
dcl ZONA$=256(16)              ; Zona de una pista (4096 octetos)
dcl E%                         ; C√≥d. respuesta ( error )
segment 0
on error goto 9000,E           ; en caso de error FIN
assign=1,"FL0"
assign=3,"FL1",WR
SECTOR=0
100 IO=1,/40,SECTOR:ZONA(1),4096   ; LEER
IO=3,/80,SECTOR:ZONA(1),4096   ; ESCRIBIR
SECTOR=SECTOR+16
goto 100                       ; continuar

9000 print=1:"Error..: ",E,tabv(1)  ; fin si error fin del soporte
stop
eseg 0
end</code></pre>

            <hr />

            <h4>VOLUME=</h4>
            <p>Se pueden leer las caracter√≠sticas generales de un volumen PROLOGUE.</p>
            <h4>Sintaxis</h4>
            <pre><code>VOLUME= Nlog : [ EtiquErr, VarEr , ] VarRecep [ , Long ]</code></pre>

            <ul>
              <li><b>Nlog</b>: es un num√©rico corto, es el n√∫mero l√≥gico al cual se le asigna un soporte.</li>
              <li><b>EtiquErr</b>: es la etiqueta de desv√≠o en caso de error.</li>
              <li><b>VarEr</b>: es una variable num√©rica corta que recibir√° el c√≥digo de error.</li>
              <li><b>VarRecep [, Long]</b>: Define la zona de recepci√≥n de datos y la longitud de los datos a leer. El primer octeto transferido es almacenado en el primer octeto de VarRecep, los siguientes se almacenan consecutivamente. Long es un num√©rico corto que indica el n√∫mero de octetos a leer, si no existe este par√°metro, la longitud le√≠da es la declarada para la variable VarRecep. Esta longitud es normalmente de 25 octetos.</li>
              </ul>

            <h4>Estructura de Datos le√≠dos</h4>
            <table>
              <thead>
                <tr>
                  <th>Tipo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>$=8</code></td>
                  <td>Nombre del volumen cuadrado a izquierda.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>Capacidad del volumen en gr√°nulos.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>Capacidad de los gr√°nulos en sectores.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>N√∫mero m√°ximo de ficheros (vac√≠os) que se pueden crear.</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>= 0 si el volumen es m√≥vil. (*) = 1 si el volumen es fijo.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>A√±o de creaci√≥n del volumen. (*)</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>Mes de creaci√≥n del volumen. (*)</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>D√≠a de creaci√≥n del volumen. (*)</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>N√∫mero de gr√°nulos ocupados.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>N√∫mero de ficheros existentes.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>Reservado para extensiones.</td>
                </tr>
              </tbody>
            </table>

            <p>(*) Para vol√∫menes creados y gestionados por versiones anteriores a PROLOGUE 2.2, estas informaciones est√°n a cero. Se vuelven efectivas al usar las nuevas versiones de los utilitarios.</p>
            <h4>Errores posibles</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>56</td>
                  <td>Funci√≥n no soportada por la configuraci√≥n (PROLOGUE &lt; 2.2)</td>
                </tr>
                <tr>
                  <td>122</td>
                  <td>Zona de recepci√≥n demasiado corta, p√©rdida de informaciones.</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo</h4>
            <pre><code>program "bles1"
dcl VOL$=8,TVOL%,TGR%,MAXF%,TYP#,AN%,MES#,DIA#,OCUP%,EXIST%,RES%
dcl E%
segment 0

assign=1,"MD0"

VOLUME=1:VOL,25

print=1:tabv(1),"Vol: "  ,VOL
print=1:tab(15),"fecha:" ,( NZ,E),DIA,"/",MES ,"/",(N3Z),AN
print=1:tab(35),"Nbfic: ",(N2Z,E),MAXF,"/",EXIST
print=1:tab(52),"Lg.Gr:" ,(N2Z)  ,TGR
print=1:tab(64),"Ocup.: ",(N3Z,E),TVOL,"/",OCUP,tabv(1)
print=1:        "Tipo.: ",(  Z)  ,TYP          ,tabv(1)

stop
eseg 0

end</code></pre>

            <h4>Resultado</h4>
            <pre><code>Vol: aaa   fecha: 10/12/1986   Nbfic: 895/311   Lg.Gr: 16   Ocup.: 1216/113
Tipo.: 0</code></pre>

            <hr />

            <h4>CATALOG=</h4>
            <p>Para leer las caracter√≠sticas generales de un fichero PROLOGUE.</p>
            <h4>Sintaxis</h4>
            <pre><code>                   [ , Numero ]
CATALOG=Nlog [ , "Fich" ] : [ EtiquErr, VarEr , ] VarRecep [ , Long ]</code></pre>

            <ul>
              <li><b>Nlog</b>: es un num√©rico corto, es el n√∫mero l√≥gico al cual se le asigna un soporte.</li>
              <li><b>"Fich"</b>: Es una cadena de caracteres que contiene el nombre del fichero y el tipo del fichero a buscar. Cada car√°cter de "NomFich-Tipo" puede ser reemplazado por una interrogaci√≥n, para indicar cualquier car√°cter (Joker). "????????-???" significa cualquier nombre.</li>
              <li><b>Numero</b>: Es un num√©rico corto. Indica el n√∫mero de entrada en el cat√°logo a partir del cual empezar√° la b√∫squeda. Por defecto de Numero y de "Fich", el sistema leer√° las caracter√≠sticas del primer nombre de fichero. Si Numero es cero el sistema comienza por el primer fichero. Si Numero es "I" el sistema comienza por el fichero "I+1".</li>
              <li><b>EtiquErr</b>: es la etiqueta de desv√≠o en caso de error</li>
              <li><b>VarEr</b>: es una variable num√©rica corta que recibir√° el c√≥digo de error.</li>
              <li><b>VarRecep [, Long]</b>: Define la zona de recepci√≥n de datos y la longitud de los datos a leer. Esta longitud es normalmente de 79 octetos.</li>
              </ul>

            <h4>Estructura de datos le√≠dos</h4>
            <table>
              <thead>
                <tr>
                  <th>Tipo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>$=8</code></td>
                  <td>Nombre del fichero en 8 caracteres cuadrados a izquierda.</td>
                </tr>
                <tr>
                  <td><code>$=3</code></td>
                  <td>Tipo del fichero en 3 caracteres cuadrados a izquierda.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>N√∫mero de entrada en el cat√°logo.</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>M√©todos de organizaci√≥n utilizadas: 0=Acceso relativo/Bloque/N.G.F., 1=Acceso secuencial, 2=Acceso secuencial indexado (registro de longitud fija), 18=Acceso secuencial indexado (registro de long. variable).</td>
                </tr>
                <tr>
                  <td>5 Octetos</td>
                  <td>Zona descriptiva de la gesti√≥n del fichero, copia de octetos 4,5,6, 62 y 63 del descriptor disco N.G.F.</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>Reservar para extensiones.</td>
                </tr>
                <tr>
                  <td><code>%</code></td>
                  <td>A√±o de creaci√≥n o de la √∫ltima modificaci√≥n del fichero.</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>Mes de creaci√≥n o de la √∫ltima modificaci√≥n del fichero.</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>D√≠a de creaci√≥n o de la √∫ltima modificaci√≥n del fichero.</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>N√∫mero de extensiones ocupadas por el fichero.</td>
                </tr>
                <tr>
                  <td>54 Octetos</td>
                  <td>Copia de los octetos 7 a 60 del descriptor disco N.G.F.</td>
                </tr>
              </tbody>
            </table>

            <h4>Errores posibles</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥digo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>40</td>
                  <td>Fichero inexistente en este volumen.</td>
                </tr>
                <tr>
                  <td>56</td>
                  <td>Funci√≥n No Soportada por la configuraci√≥n (PROLOGUE &lt; 2.2)</td>
                </tr>
                <tr>
                  <td>112</td>
                  <td>Incoherencia en la designaci√≥n del volumen entre las √≥rdenes ASSIGN= y CATALOG=</td>
                </tr>
                <tr>
                  <td>122</td>
                  <td>Zona de recepci√≥n demasiado corta, p√©rdida de informaciones.</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo</h4>
            <pre><code>program "bles1"
dcl FICH$=21
dcl NOM$=8,TYP$=3,NUM%,MA#,Z1#(5),RES#,AN%,MES#,DIA#,Z2#(54)
dcl L1%
segment 0
assign=1,"MD0"
FICH="BLES1-S"
CATALOG=1,FICH:NOM,79
L1=len$(NOM)
print=1:tabv(1),"Nombre : "   ,left(NOM,L1),"-",TYP
print=1:tab(25),"Numero : ",NUM,"   M.A. : ",MA
print=1:tab(60),"Fecha  : ",(NZ,E),DIA,"/",MES,"/",(N3Z),AN,tabv(1)
stop
eseg 0
end</code></pre>

            <h4>Resultado</h4>
            <pre><code>Nombre : BLES1-S        Numero :    157   M.A. :    0     fecha: 17/12/1986</code></pre>

            <hr />

            <h3>√ìrdenes Generales</h3>

            <h4>CFILE= Creaci√≥n de Fichero</h4>
            <p>Antes de esta orden el fichero no tiene que existir, despu√©s est√° vac√≠o y abierto.</p>
            <h4>Sintaxis</h4>
            <pre><code>CFILE=Nlog [, VD [=Long huecos] ] [ , LK= Long clave ] [ : EtiquErr,E ]
           [,  D = Long Datos ]   [ , RK= Long clave ]
                                  [ ,  K= Long clave ]</code></pre>

            <h4>Definici√≥n</h4>
            <ul>
              <li>Cierra Nlog si este n√∫mero l√≥gico est√° abierto por vuestro puesto</li>
              <li>Crea el fichero seg√∫n ASSIGN= y CFILE=</li>
              <ul>
                <li>En S.I. el fichero de claves se crea con el tipo -I a priori; el fichero de datos se crea con el tipo -D si la longitud de sus datos es diferente de cero.</li>
                <li>En M.C. los ficheros S.I. (-I y -D) se crean si no exist√≠an ya, los ficheros de Valores y de Referencias son creados (-V y -R)</li>
                </ul>
              </ul>

            <p><b>D=Long.Datos</b>: permite crear un fichero secuencial, secuencial indexado o multicriterio seg√∫n ASSIGN=, siendo los datos de longitud fija.</p>
            <p><b>Long.Datos</b>: es un num√©rico corto cuyo valor es la longitud de los datos del fichero.</p>
            <p><b>VD</b>: permite crear un fichero secuencial indexado cuyos datos son de longitud variable.</p>
            <p><b>Long Hueco</b>: es un num√©rico corto cuyo valor es la longitud m√≠nima de los huecos a recuperar. Los huecos son los espacios de disco liberados por supresi√≥n de registros o por modificaci√≥n de la longitud de datos de un registro. Los huecos m√°s peque√±os que "Long Hueco" se perder√°n, esto permite al sistema no perder tiempo en buscar una plaza (de 100 octetos por ejemplo) en una multitud huecos (de longitud media de 10 octetos por ejemplo). Por defecto todos los huecos se recuperan y el espacio se optimiza en detrimento del tiempo de acceso. Una salvaguardia seguida de una restauraci√≥n permite recuperar estos huecos, bien por SVSI y RTSI, o por DOWN.L= e INSERT=</p>
            <p><b>LK</b>: Para un S.I. o un M.C. √∫nicamente, las claves son de tipo cadena, el sistema las cuadrar√° a la izquierda autom√°ticamente.</p>
            <p><b>RK</b>: Para un S.I. o un M.C. √∫nicamente, las claves son de tipo cadena, el sistema las cuadrar√° a la derecha autom√°ticamente.</p>
            <p><b>K</b>: Para un S.I. o un M.C. √∫nicamente, las claves son de cualquier tipo, el sistema no las cuadrar√° por lo que son v√°lidas las claves num√©ricas.</p>
            <p><b>Long clave</b>: Es un num√©rico corto, su valor es la longitud de la clave a usar: 2 a 51 octetos en S.I. o 2 a 40 en multicriterio. A clave m√°s peque√±a el sistema ahorra m√°s espacio y tiempo. En multicriterios se aconseja manejar claves lo m√°s cortas posibles.</p>
            <h4>Ejemplos</h4>
            <p><b>Creaci√≥n de un fichero S.I. Datos=60 Clave=10, Cadena cuadrar a izda.:</b></p>
            <pre><code>ASSIGN=1,"STOCK",WR,SI
CFILE=1,D=60,LK=10</code></pre>

            <p><b>Creaci√≥n de un fichero S.I. Datos de longitud variable, recuperar los huecos de m√°s de 55 octetos. La clave es num√©rica de 4 octetos (sin cuadrar):</b></p>
            <pre><code>ASSIGN=1,"TOTO",WR,SI
CFILE=1,VD=55,K=4</code></pre>

            <p><b>Creaci√≥n de un fichero SEQ. Datos=128 octetos:</b></p>
            <pre><code>ASSIGN=1,"FSEQU",WR,SQ
CFILE=1,D=128</code></pre>

            <hr />

            <h4>DFILE= Destruir un Fichero</h4>
            <h4>Sintaxis</h4>
            <pre><code>DFILE=Nlog [ : EtiquErr,E ]</code></pre>

            <ul>
              <li>Cierra Nlog si este n√∫mero l√≥gico est√° abierto por vuestro puesto</li>
              <li>Destruye el fichero.</li>
              <ul>
                <li>Para una asignaci√≥n en M.C. s√≥lo los ficheros -V y -R se destruyen</li>
                <li>Para una asignaci√≥n en S.I. los ficheros -I y -D se destruyen</li>
                </ul>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>ASSIGN=1,"STOCK",WR,SI
DFILE=1</code></pre>

            <hr />

            <h4>RENAME= Renombrar un Fichero</h4>
            <h4>Sintaxis</h4>
            <pre><code>RENAME=Nlog,"Fich" [ : EtiquErr,E ]</code></pre>

            <ul>
              <li>El fichero debe estar asignado en exclusividad (EX)</li>
              <li>El n√∫mero l√≥gico Nlog se abre si estaba cerrado.</li>
              <li>"Fich" es una cadena de caracteres que contienen los nuevos nombre, tipo y claves de acceso del fichero, √©ste queda abierto despu√©s de ejecutar RENAME=</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>ASSIGN=1,"STOCK",WR,SI,EX
RENAME=1,"ALMACEN"</code></pre>

            <hr />

            <h4>EXTEND= Agrandar un Fichero</h4>
            <h4>Sintaxis</h4>
            <pre><code>EXTEND=Nlog [,N¬∫.de sectores ] [ : EtiquErr,E ]</code></pre>

            <p>Esta orden permite alocar por adelantado el espacio de un fichero.</p>
            <ul>
              <li>El fichero debe ser asignado en exclusividad (EX).</li>
              <li>El n√∫mero l√≥gico Nlog es abierto si estaba cerrado.</li>
              <li>N¬∫ de sectores es un num√©rico corto.</li>
              <li>El espacio del fichero se extiende en el n√∫mero de sectores pedidos en gr√°nulos. Por defecto 1 gr√°nulo suplementario es alocado.</li>
              <li>Si el fichero es asignado bien en S.I. bien en M.C. s√≥lo el fichero de claves -I es extendido. Para agrandar los ficheros de tipo -D, -V o -R √©stos deben ser asignados en relativo.</li>
              </ul>

            <p>Por defecto de usar esta orden, la extensi√≥n de los ficheros se hace de forma autom√°tica.</p>
            <h4>Ejemplo: Extender el fichero de datos del S.I. "ALMACEN"</h4>
            <pre><code>ASSIGN=1,"ALMACEN-D",WR,EX  ; en relativo
EXTEND=1,8          ; 8 sectores de m√°s ( 8*256 = 2 K octetos ) como m√≠nimo</code></pre>

            <hr />

            <h4>OPEN= Abrir un Fichero</h4>
            <h4>Sintaxis</h4>
            <pre><code>OPEN=Nlog [ : EtiquErr,E ]</code></pre>

            <ul>
              <li>Cierra Nlog si este n√∫mero l√≥gico est√° abierto por vuestro puesto</li>
              <li>Abre el n√∫mero l√≥gico Nlog, seg√∫n ASSIGN=</li>
              <ul>
                <li>Para un fichero asignado en S.I. o en M.C. el puntero de lectura secuencial (para DOWN..) se coloca en principio del fichero (en una clave cuyo valor binario ser√° cero).</li>
                <li>Para un fichero asignado en SEQ, el puntero del registro se coloca:</li>
                <ul>
                  <li>En el primer registro para una apertura en lectura</li>
                  <li>En el √∫ltimo registro para una apertura en escritura.</li>
                <li>Para un soporte impresora asignada en IM,WR,EX, √©sta es reservada.</li>
                  </ul>
                </ul>
              </ul>

            <ul>
              <li>Si no se usa esta orden, el primer acceso a este n√∫mero l√≥gico lo abrir√° si es necesario.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>ASSIGN=1,"STOCK",WR,SI
OPEN=1</code></pre>

            <hr />

            <h4>CLOSE= Cerrar un Fichero</h4>
            <h4>Sintaxis</h4>
            <pre><code>CLOSE=Nlog [ : EtiquErr,E ]</code></pre>

            <ul>
              <li>Cierra Nlog si este n√∫mero l√≥gico est√° abierto por vuestro puesto.</li>
              <ul>
                <li>Para un soporte impresora asignada en IM,WR,EX, √©sta es liberada, y podr√° ser reservada de nuevo por otro puesto (o por otro n√∫mero l√≥gico de vuestro puesto).</li>
                </ul>
              </ul>

            <p>Si Nlog = 0 (<code>CLOSE=0</code>) es el fichero que contiene el programa en curso de ejecuci√≥n (-T) el cerrado. √âste se abrir√° autom√°ticamente, si es necesario, para cargar otro segmento.</p>
            <p>Si no se ejecuta un <code>CLOSE=</code> en un programa, la vuelta al interpretador de comandos del sistema (La flecha -&gt;) por un STOP, o un error de ejecuci√≥n o cualquier otro medio provoca el cierre de todos los ficheros de este puesto y libera la impresora.</p>
            <h4>Ejemplo</h4>
            <pre><code>ASSIGN=1,"STOCK",WR,SI
-
-
CLOSE=1</code></pre>

            <hr />

            <h3>Acceso Relativo a un Fichero o Acceso a un Recurso SGF</h3>

            <h4>Sintaxis</h4>
            <pre><code>READ=Nlog,Funci√≥n [, N√∫mero de sector ] : [ EtiquErr,E, ] V [ , L ]
                                        [ : EtiquErr,E  ]

WRITE=Nlog,Funci√≥n [, N√∫mero de sector ] : [ EtiquErr,E, ] V [ , L ]
                                         [ : EtiquErr,E  ]</code></pre>

            <h4>Definici√≥n</h4>
            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Ejecuta la funci√≥n pedida seg√∫n el valor del par√°metro Funci√≥n.</li>
              <li>Se reserva READ= para leer y WRITE para escribir.</li>
              </ul>

            <p><b>Funci√≥n</b>: es un num√©rico corto cuyo valor da el n√∫mero del comando a ejecutar.</p>
            <p><b>N√∫mero de sector</b>: es un num√©rico corto o largo y su valor da el n√∫mero del primer sector a transferir. El primer sector de un fichero lleva el n√∫mero cero. Si no est√° este par√°metro se usa el valor cero.</p>
            <p><b>V [, L]</b>: Define los datos a transferir. La longitud es igual a K veces 256 octetos, para los accesos a soportes sectorizados.</p>
            <h4>Las principales funciones en un Fichero son:</h4>
            <table>
              <thead>
                <tr>
                  <th>Funci√≥n</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>/60</code></td>
                  <td>leer 1 o varios sector(es) en relativo</td>
                </tr>
                <tr>
                  <td><code>/A0</code></td>
                  <td>escribir 1 o varios sector(es) en relativo</td>
                </tr>
              </tbody>
            </table>

            <p>Seg√∫n el valor de "Funci√≥n" se pueden hacer accesos con m√©todos m√°s evolucionados que el acceso relativo.</p>
            <p>Todos los recursos de SGF (Generalizaci√≥n de accesos a Ficheros) pueden hacerse por READ= y WRITE=, por ejemplo una teletransmisi√≥n entre varios.</p>
            <p>De hecho, el sistema transfiere un descriptor al recurso llamado.</p>
            <h4>Estructura del descriptor transmitido en la llamada (en 16 bits)</h4>
            <pre><code>            Direcci√≥n del descriptor en  DS : BX
                                          Octeto

            :------------------------:
Nlog   --&gt;  ! N√∫mero L√≥gico Sistema  !      0
            !------------------------!
            !    Direcci√≥n de V   *  !      1
V      --&gt;  !-                      -!
            !      ( offset )        !      2
            !------------------------!
            !    Direcci√≥n de V   *  !      3
            !-                      -!
            !     ( segment )        !      4
            !------------------------!
            !       Longitud      *  !      5
[, L ] --&gt;  !-                      -!
            !      Transferida       !      6
            !------------------------!
N√∫mero      !    Num. de Sector   *  !      7
  de   --&gt;  !-                      -!
Sector      !    Cero por defecto    !      8
            '------------------------'</code></pre>

            <h4>Ejemplo: Copia de un fichero "ORIGEN-S" a "COPIA-S"</h4>
            <p>Se supone que ambos ficheros existen en el soporte.</p>
            <pre><code>program "COPIA Fichero"
dcl SECTOR%                    ; N√∫mero del 1er.sector a transferir
dcl ZONA$=256(16)              ; Zona de una pista 4096 octetos
dcl E%                         ; C√≥d. respuesta ( error )
segment 0
on error goto 9000,E           ; en caso de error FIN
assign=1,"FL0.ORIGEN-S"
assign=3,"FL1.COPIA-S",WR
SECTOR=0
100 READ=1,/60,SECTOR:ZONA(1),4096         ; Leer
WRITE=3,/A0,SECTOR:ZONA(1),4096        ; Escribir
SECTOR=SECTOR+16
goto 100                       ; continuar

9000 print=1:"Error .: ",E,tabv(1)  ; fin si da error de fin de Fichero
stop
eseg 0
end</code></pre>

            <hr />

            <h3>Acceso Secuencial a un Fichero</h3>

            <h4>READ= Lectura</h4>
            <pre><code>READ=Nlog : [ EtiquErr,E, ] V [ , L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado, el puntero de registros se posiciona en el primer registro.</li>
              <li>El registro punteado se lee si la longitud pedida para la transferencia es correcta.</li>
              <li>El puntero de registros se coloca en el registro siguiente.</li>
              <li>Si el √∫ltimo registro ha sido ya le√≠do, el error "Fin de fichero" (48) se reenv√≠a.</li>
              </ul>

            <hr />

            <h4>BACKSPACE= Salto Atr√°s</h4>
            <pre><code>BACKSPACE=Nlog [ : EtiquErr,E ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>El puntero de registro salta al registro anterior (hacia el principio de fichero), este registro NO SE LEE.</li>
              <li>Si el puntero llega al primer registro del fichero, un error "Principio de Fichero" (64) se reenv√≠a como c√≥digo de respuesta.</li>
              </ul>

            <hr />

            <h4>MODIF= Modificar</h4>
            <pre><code>MODIF=Nlog : [ EtiquErr,E, ] V [ , L ]</code></pre>

            <ul>
              <li>Esta orden no funciona en las bandas magn√©ticas (cintas)</li>
              <li>El fichero debe estar asignado en escritura (WR).</li>
              <li>El registro es reemplazado por el contenido de la zona V [, L]. La longitud de la zona debe ser la declarada en la creaci√≥n del fichero.</li>
              <li>Despu√©s de la modificaci√≥n el puntero se coloca siempre en el mismo registro (el que acaba de ser escrito).</li>
              </ul>

            <hr />

            <h4>WRITE= Escritura</h4>
            <pre><code>WRITE=Nlog : [ EtiquErr,E, ] V [ , L ]</code></pre>

            <ul>
              <li>En una banda magn√©tica este fichero debe ser el √∫ltimo de esta banda.</li>
              <li>El fichero debe estar asignado en escritura (WR).</li>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado, el puntero de registro se coloca en el √∫ltimo registro escrito.</li>
              <li>El contenido de la zona V [, L] se escribe en fin de fichero, si la longitud pedida para la transferencia es correcta.</li>
              <li>El puntero de registro se coloca en el √∫ltimo registro escrito.</li>
              </ul>

            <hr />

            <h4>Ejemplo: Modificar el registro 25, escribir al final</h4>
            <pre><code>ASSIGN=1,"FSEQU",WR,SQ
-
for I=1 to 25
READ=1:V,L          ; Lee el registro I , y Coloca el I + 1
next I

; se coloca en el registro 26, V [ , L ] contiene los datos del Num. 25

V= ...              ; Modif.de la zona V [ , L ]

BACKSPACE=1         ; coloca  el n√∫mero 25
MODIF=1:V,L         ; Modifica el N√∫mero 25, se coloca siempre en el 25
-
V=...               ; Datos a escribir al final en V [ , L ]
WRITE=1:V,L         ; Escribe al fin del fichero.</code></pre>

            <h4>Advertencia</h4>
            <p>El cierre del fichero, as√≠ como la alocaci√≥n autom√°tica de un gr√°nulo suplementario pone al d√≠a el puntero de fin de fichero secuencial si la opci√≥n modo Copia (C en ASSIGN=) no se ha pedido. El hecho de quitar el modo copia (por ATB=) pone al d√≠a el puntero de fin de fichero.</p>
            <p>Estos ficheros tienen que cerrarse cuando la sesi√≥n de trabajo finaliza.</p>
            <hr />

            <h3>Acceso Secuencial Indexado</h3>

            <h4>INSERT= A√±adir un Art√≠culo</h4>
            <pre><code>INSERT=Nlog,Clave[,Index]:[EtiquErr,E,] D1 [,L]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Inserta en el fichero la clave, el √≠ndice y los datos (D1 [,L]) asociados a la clave. La longitud de los datos puede ser nula.</li>
              <li>El valor del par√°metro Index se atribuye a la clave como √≠ndice, por defecto, al √≠ndice se le atribuye el valor 1.</li>
              <li>La clave se clasifica autom√°ticamente en orden alfanum√©rico o binario.</li>
              <li>Despu√©s del INSERT= el puntero coloca la clave insertada.</li>
              </ul>

            <h4>Ejemplo: Con c√°lculo de √≠ndice</h4>
            <pre><code>ASSIGN=1,"STOCK",WR,SI
10   ask=1,i=9999:tab(5,2),"Nombre.... : "=C1 ; Clave
ask=1,i=9999:tab(5,4),"Cantidad . : "=D1 ; Index=1 Bit 0=1 para todos
ask=1,i=9999:tab(5,5),"Stock Mini : "=M1 ; Index=. + 2 si M1 &lt; D1
ask=1,i=9999:tab(5,6),"Precio     : "=P1 ; si precio&lt;=100 Bit 2=1
ask=1,i=9999:tab(5,7),"Proveedor  : "=F1 ; Proveedor
I0=1                   ; EXISTE     Bit 0 a 1 ( 2**0= 1 )
if D1 &gt;= M1 goto 100   ; no hay en stock
I0=I0 or 2             ; en stock mini Bit 1 a 1 ( 2**1= 2 )
100  if P1 &gt; 100 goto 200   ; Es caro
I0=I0 or 4             ; No es caro Bit 2 a 1 ( 2**2= 4 )
200  -
1100 INSERT=1,C1,I0:1110,E0,D1,30
goto 1200              ; Ok
1110 if E0 &lt;&gt; 81 goto 9900  ; error general
print=1:"El producto: ",C1 ," est√° YA en stock",tabv(1)
wait 3
goto 10
1200</code></pre>

            <hr />

            <h4>DELETE= Supresi√≥n de 1 o m√°s bits de index de una clave o 1 art√≠culo</h4>
            <pre><code>DELETE=Nlog,Clave [,Index] [ : EtiquErr,E0 ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>La clave tiene que existir, y no estar bloqueada por otro puesto.</li>
              <li>Cada bit a 1 del par√°metro Index, de la orden DELETE=, provoca la puesta a cero del bit correspondiente del index asociado a la clave en el fichero.</li>
              <li>Por defecto de Index el valor 1 es el usado (Bit de fuerza 0).</li>
              <li>Se tiene: <code>IndexRESULTADO = IndexANTERIOR AND ( NOT IndexDELETE )</code>.</li>
              <li>Si despu√©s de esta operaci√≥n el valor del index es nulo: el registro es suprimido del fichero y su plaza se recupera (se provoca un hueco).</li>
              <li>Para estar seguro de suprimir un registro el valor del index ser√° 255 (o /FF) en la orden DELETE=</li>
              <li>Despu√©s del DELETE=, el puntero se coloca en la clave referenciada.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>DELETE=1,C1,/FF:9000,E0     ; Suprime el registro C1 del fichero</code></pre>

            <hr />

            <h4>SEARCH= B√∫squeda y Lectura de Datos de un Registro</h4>
            <pre><code>SEARCH=Nlog,Clave [,Index] : [ EtiquErr,E0, ] D1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lectura de datos asociados a la clave, si la clave pertenece a la reuni√≥n de subniveles definida por el valor del √≠ndice del SEARCH=.</li>
              <li>Por defecto Index = 1</li>
              <li>Despu√©s del SEARCH=, el puntero se coloca en la clave buscada.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>SEARCH=1,C1:D1,30   ; Busca a partir de D1, los datos asociados a C1
; ( 30 octetos ), si el bit index de fuerza cero de C1 est√° a 1.</code></pre>

            <hr />

            <h4>SEARCH.L= Lectura de la Longitud de Datos y de Datos de un Registro</h4>
            <pre><code>SEARCH.L=Nlog,Clave [,Index] : [ EtiquErr,E0,] L3 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lectura de la longitud de datos y de esos datos asociados a la clave, si la clave pertenece a la uni√≥n de subniveles definido por el valor del √≠ndice del SEARCH.L=</li>
              <li>Por defecto Index = 1</li>
              <li>L debe indicar la longitud total m√°xima a transferir, es decir la Longitud m√°xima de datos m√°s 2.</li>
              <li>Despu√©s de SEARCH.L=, el puntero se coloca en la clave buscada.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>SEARCH.L=1,C1:L3,32 ; Se recibe la longitud de datos en 2 octetos
; luego los datos, si el bit index de fuerza cero de C1 es un 1.</code></pre>

            <hr />

            <h4>SEARCH.M= Lectura del √çndice y Datos de un Registro para Modificaci√≥n</h4>
            <pre><code>SEARCH.M=Nlog,Clave [,Index] : [EtiquErr,E0,] I1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lectura del √≠ndice y de datos asociados a la clave, si dicha clave pertenece a la reuni√≥n de subniveles definidos por el valor del √≠ndice del SEARCH.M=, y si no est√° ya bloqueada por otro puesto.</li>
              <li>Por defecto Index = 1</li>
              <li>Despu√©s de SEARCH.M=, la clave se bloquea para los dem√°s puestos, y para los dem√°s n√∫meros l√≥gicos de vuestro programa. Se desbloquear√°, para el puesto que la bloque√≥ cuando se ejecute una orden sobre el mismo n√∫mero l√≥gico.</li>
              <li>Despu√©s de SEARCH.M=, el puntero se coloca en la clave buscada.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>SEARCH.M=1,C1:I1,31 ; Index 1 octeto y datos asociados a C1= 31 octetos,
; si el bit index de fuerza cero de C1 es un 1.</code></pre>

            <hr />

            <h4>SEARCH.ML= Lectura de la Longitud de Datos, el √çndice, los Datos para Modificaci√≥n</h4>
            <pre><code>SEARCH.ML=Nlog,Clave [,Index] : [ EtiquErr,E0,] L2 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lectura de la longitud de datos, del √≠ndice y de los datos asociados a la clave, si la clave pertenece a la reuni√≥n de subniveles definidos por el valor del √≠ndice del SEARCH.ML=, y si no ha sido bloqueada por otro puesto de trabajo.</li>
              <li>Por defecto Index = 1</li>
              <li>Despu√©s del SEARCH.ML=, la clave se bloquea para los dem√°s puestos y los dem√°s n√∫meros l√≥gicos de vuestro programa. Se desbloquear√°, por el puesto que la bloque√≥, cuando se ejecute una orden sobre el mismo n√∫mero l√≥gico.</li>
              <li>Despu√©s del SEARCH.ML=, el puntero se coloca en la clave buscada.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>SEARCH.ML=1,C1:L2,33        ; Longitud 2 octetos, Index 1 octeto, datos
; asociados a C1 30 octetos, si el bit index de fuerza cero de C1 es un 1.</code></pre>

            <hr />

            <h4>MODIF= Modificaci√≥n del √çndice y de Datos de un Registro</h4>
            <pre><code>MODIF=Nlog,Clave [,Index] : [ EtiquErr,E0,] D1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Los datos viejos de la clave C1 son reemplazados por D1 [, L] la longitud puede cambiar si el fichero se cre√≥ en longitud variable.</li>
              <li>El viejo index se anula y reemplaza por el valor del par√°metro Index</li>
              <li>Por defecto Index = 1</li>
              <li>La clave es desbloqueada.</li>
              <li>Despu√©s del MODIF=, el puntero se coloca en la clave modificada.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>MODIF=1,C1,I0:D1,30 ; el nuevo √≠ndice es I0
; los nuevos datos son los 30 octetos a partir del primer octeto de D1.</code></pre>

            <hr />

            <h4>DOWN= Lectura Secuencial de: La Clave, el Index y los Datos</h4>
            <pre><code>DOWN=Nlog [,Index] : [ EtiquErr,E0,] C1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Se coloca en la clave siguiente perteneciente a la reuni√≥n de subniveles definidos por el valor del par√°metro Index. Por defecto Index = 1</li>
              <li>Despu√©s lee a partir de la variable C1: La clave, el index y los datos del registro colocado en memoria.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>DOWN=1,2:C1,41      ; Leer el registro siguiente del subnivel 2.
; Por ejemplo art√≠culos cuya cantidad sea inferior al stock m√≠nimo.
; 41 = 10 ( Clave ) + 1 ( Index ) + 30 ( datos )</code></pre>

            <hr />

            <h4>UP= Lectura Secuencial Anterior</h4>
            <pre><code>UP=Nlog [,Index] : [ EtiquErr,E0,] C1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Se coloca en la clave precedente perteneciente a la reuni√≥n de subniveles definidos por el valor de Index. Por defecto Index = 1</li>
              <li>Despu√©s lee a partir de la variable C1: La clave, el index y los datos del registro colocado en memoria.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>UP=1,4:C1,41        ; Leer el art√≠culo precedente del subnivel 4.
; Por ejemplo los art√≠culos cuyo precio sea &lt;= a 100.</code></pre>

            <hr />

            <h4>DOWN.L= y UP.L= Lectura Secuencial con Longitud de Datos</h4>
            <p>La lectura secuencial de un fichero secuencial indexado puede hacerse con lectura de la longitud real de datos de un registro (longitud definida en INSERT= o en curso del √∫ltimo MODIF=).</p>
            <p>As√≠, se tiene:</p>
            <ul>
              <li><code>DOWN=</code> equivalente a <code>DOWN.L=</code> ; Siguiente</li>
              <li><code>UP=</code> equivalente a <code>UP.L=</code> ; Precedente</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>DOWN.L=Nlog [,Index] : [ EtiquErr,E,] L1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Se posiciona en la siguiente clave perteneciente a la uni√≥n de subniveles definidos por el valor de Index. Por defecto Index = 1</li>
              <li>Luego poner a partir de la variable L1: La longitud de datos (%), la clave, el index y los datos del art√≠culo.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>DOWN.L=1,2:L1,43    ; Leer el reg. siguiente de subnivel 2.</code></pre>

            <hr />

            <pre><code>UP.L=Nlog [,Index] : [ EtiquErr,E,] L1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Posiciona la clave anterior perteneciente a la uni√≥n de subniveles definidos por el valor del Index. Por defecto Index = 1</li>
              <li>Luego poner a partir de la variable L1: La longitud de datos (%), la clave, el index y los datos del registro posicionado.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>UP.L=1,4:L1,43      ; Leer el art√≠culo precedente de subnivel 4.</code></pre>

            <hr />

            <h4>DOWN.M= y UP.M= Lectura Secuencial para Modificaci√≥n</h4>
            <p>La lectura secuencial de un fichero secuencial indexado puede hacerse con intenci√≥n de modificaci√≥n. Es decir, que el registro le√≠do ser√° bloqueado como por un SEARCH.M=, si no lo estaba ya, y ser√° desbloqueado por el puesto que lo bloque√≥ ejecutando una orden con el mismo n√∫mero l√≥gico.</p>
            <p>As√≠, se tiene:</p>
            <ul>
              <li><code>DOWN.M=</code> equivalente a <code>DOWN=</code> ; Siguiente</li>
              <li><code>UP.M=</code> equivalente a <code>UP=</code> ; Precedente</li>
              <li><code>DOWN.ML=</code> equivalente a <code>DOWN.L=</code> ; Siguiente con longitud</li>
              <li><code>UP.ML=</code> equivalente a <code>UP.L=</code> ; Precedente con longitud</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>DOWN.M=Nlog [,Index] : [ EtiquErr,E,] C1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lee la clave siguiente perteneciente a la uni√≥n de subniveles definidos por el valor del par√°metro Index. Por defecto Index = 1</li>
              <li>La clave es bloqueada si no lo ha sido ya (ver SEARCH.M=)</li>
              <li>Luego poner a partir de la variable C1: La clave, el index y los datos del registro a leer.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>DOWN.M=1:C1,41      ; Bloquear y leer el registro siguiente del subnivel 1</code></pre>

            <hr />

            <pre><code>UP.M=Nlog [,Index] : [ EtiquErr,E,] C1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lee la clave precedente perteneciente a la uni√≥n de subniveles definidos por el valor del par√°metro Index. Por defecto Index = 1</li>
              <li>La clave es bloqueada si no lo estaba ya (ver SEARCH.M=)</li>
              <li>Luego poner a partir de la variable C1: La clave, el index y los datos del registro le√≠do.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>UP.M=1:C1,41  ; Bloquear y leer el registro precedente de subnivel 1.</code></pre>

            <hr />

            <h4>DOWN.ML= y UP.ML= Lectura Secuencial con Longitud para Modificaci√≥n</h4>
            <pre><code>DOWN.ML=Nlog [,Index] : [ EtiquErr,E,] L1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lee la clave siguiente perteneciente a la uni√≥n de subniveles definidos por el valor del par√°metro Index. Por defecto Index = 1</li>
              <li>La clave se bloquea si no lo estaba ya (ver SEARCH.M=)</li>
              <li>Luego poner a partir de la variable C1: La longitud de datos (%), la clave, el index y los datos del registro a leer.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>DOWN.ML=1:L1,43     ; Bloquear y leer la longitud de datos (%) , la clave
;el index y los datos del registro de la clave siguiente de subnivel 1.</code></pre>

            <hr />

            <pre><code>UP.ML=Nlog [,Index] : [ EtiquErr,E,] L1 [, L ]</code></pre>

            <ul>
              <li>Abre el n√∫mero l√≥gico si estaba cerrado.</li>
              <li>Lee la clave precedente perteneciente a la reuni√≥n de subniveles definidos por el valor del par√°metro Index. Por defecto Index = 1</li>
              <li>La clave se bloquea si no lo estaba ya (ver SEARCH.M=)</li>
              <li>Luego poner a partir de la variable C1: La longitud de datos (%), la clave, el index y los datos del registro a leer.</li>
              <li>L da el n√∫mero de octetos (la longitud) total a transferir.</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>UP.ML=1:L1,43       ; Bloquear y leer la longitud de datos (%) , la clave
;el index y los datos del registro precedente del subnivel 1.</code></pre>

            <hr />

            <h3>Ejemplo Completo: Listado de un Fichero con Index</h3>

            <p>Se supone que se usa un fichero creado seg√∫n el ejemplo dado en la orden INSERT=</p>
            <p>La selecci√≥n (por entrada ASK=) dar√°:</p>
            <ul>
              <li>Si la respuesta es 1, 3, 5 o 7 todo el fichero, puesto que el bit de fuerza Cero est√° a 1, y este bit est√° a 1 para todos los registros del fichero.</li>
              <li>Si la respuesta es 2: solamente los registros cuyo stock m√≠nimo es menor a la cantidad.</li>
              <li>Si la respuesta es 4: solamente los registros cuyo precio sea menor o igual a 100.</li>
              <li>Si la respuesta es 6: los registros cuyo stock m√≠nimo es menor a la cantidad y todos los que el precio sea inferior o igual a 100.</li>
              </ul>

            <p>En todos los casos los registros se editar√°n en el orden de las claves.</p>
            <p>Las √≥rdenes ASK= y PRINT= est√°n escritas en una sola instrucci√≥n.</p>
            <pre><code>program "Lista"
dcl C1$=10                     ; Clave de 10 octetos
dcl I1#                        ; Index LEIDO
dcl D1%                        ; Cantidad      de 30 octetos
dcl M1%                        ; Stock mini Cla+Index+Datos=41 octetos
dcl P1                         ; Precio
dcl F1$=18                     ; Proveedor
dcl I2#                        ; Index de llamada diferente de I1
*                              ;   para poder elegir
*                              ;   en el DOWN=
dcl E%                         ; c√≥d. error
segment 0
ASSIGN=1,"STOCK",SI,WR         ; WR no sirve aqu√≠ para nada.
100  ask=1,i=9900:"Selecci√≥n index 1=todo, 2=stock mini, 4=Solo &lt;100 : "=
(Z),I2
if I2=0 goto 100               ; Index Nulo Prohibido
if I2&gt;7 goto 100               ; Respuesta Prohibida
open=1                         ; Posici√≥n puntero en principio fichero
print=1:clear,tab(25),"Listado del fichero",tabv(2)
1000 down=1, I2 :1010,E,C1,41       ; Leer el siguiente
print=1:C1,(N3Z),tab(15),D1,tab(25),M1,(N4Z.N2,E),tab(35),P1,
tab(45),F1,tabv(1)     ; Fin por tabv(1) para imprimir el √∫ltimo
op 9900                ; Abandono en el curso de la edici√≥n
goto 1000
1010 if E&lt;&gt;48 goto 9000     ; Error general
print=1:tab(5),"Fin del fichero",tabv(1)
goto 100               ; retorno al men√∫ de selecci√≥n
9000 print=1:tab(5,22),"Error .: ", E
9900 stop
eseg 0
end</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Cap√≠tulo 10: M√©todo de Acceso Multicriterio</h2>

            <h3>Contenido del Cap√≠tulo</h3>

            <h4>Presentaci√≥n y Generalidades</h4>
            <ul>
              <li>Presentaci√≥n</li>
              <li>Descripci√≥n de un registro (art√≠culo)</li>
              </ul>

            <h4>Las √ìrdenes</h4>
            <ul>
              <li><code>ASSIGN=</code></li>
              <li><code>CFILE=</code></li>
              <li><code>DFILE=</code></li>
              </ul>

            <h4>Rubricas</h4>
            <ul>
              <li><code>KEY=</code> - Declaraci√≥n de rubrica</li>
              <li><code>CKEY=</code> - Creaci√≥n de rubricas</li>
              <li><code>RKEY=</code> - Supresi√≥n de declaraciones</li>
              <li><code>NKEY=</code> - Renombrar rubrica</li>
              <li><code>FKEY=</code> - Redefinici√≥n de rubrica</li>
              <li><code>LKEY=</code> - Lista de rubricas</li>
              </ul>

            <h4>Enlaces</h4>
            <ul>
              <li><code>LINK=</code> - Declaraci√≥n de enlace</li>
              <li><code>CLINK=</code> - Creaci√≥n de enlaces</li>
              <li><code>LLINK=</code> - Lista de enlaces</li>
              </ul>

            <h4>Cuesti√≥n M.C.</h4>
            <ul>
              <li><code>COUNT=</code> - Contar respuestas</li>
              <li><code>POSIT=</code> - Posicionamiento antes del primero</li>
              <li><code>POSIT.D=</code> - Posicionamiento despu√©s del √∫ltimo</li>
              </ul>

            <h4>Lectura Secuencial</h4>
            <ul>
              <li><code>DOWN=</code> , <code>UP=</code></li>
              <li><code>DOWN.L=</code> , <code>UP.L=</code></li>
              <li><code>DOWN.M=</code> , <code>UP.M=</code></li>
              <li><code>DOWN.ML=</code> , <code>UP.ML=</code></li>
              </ul>

            <h4>Informaciones de Estado</h4>
            <ul>
              <li><code>STAT=</code></li>
              </ul>

            <hr />

            <h3>Presentaci√≥n</h3>

            <h4>Definici√≥n</h4>
            <p>El Multi-criterio (M.C.) es una generalizaci√≥n del m√©todo de acceso secuencial indexado (S.I.). Necesita grandes vol√∫menes de discos.</p>
            <p>Este m√©todo permite el acceso a los art√≠culos (registros) conociendo el (o los) valor(es) de ciertas zonas de datos o conociendo los valores de ciertas combinaciones de zonas de datos.</p>
            <p>El multi-criterio trabaja en un solo conjunto de ficheros a la vez, por esta raz√≥n, este m√©todo de acceso no conforma una base de datos.</p>
            <h4>Ejemplo</h4>
            <p>Sea el fichero siguiente:</p>
            <table>
              <thead>
                <tr>
                  <th>Clave</th>
                  <th>Index</th>
                  <th>CAN</th>
                  <th>MINI</th>
                  <th>PROV</th>
                  <th>Precio</th>
                  <th>...</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>RADIADOR</td>
                  <td>1</td>
                  <td>200</td>
                  <td>10</td>
                  <td>SUMINISTROS AVENCA</td>
                  <td></td>
                  <td></td>
                </tr>
                <tr>
                  <td>CALDERA</td>
                  <td>3</td>
                  <td>50</td>
                  <td>80</td>
                  <td>SUMINISTROS AVENCA</td>
                  <td></td>
                  <td></td>
                </tr>
                <tr>
                  <td>LAVABO</td>
                  <td>3</td>
                  <td>100</td>
                  <td>200</td>
                  <td>SUMINISTROS AVENCA</td>
                  <td></td>
                  <td></td>
                </tr>
                <tr>
                  <td>BA√ëERA</td>
                  <td>1</td>
                  <td>50</td>
                  <td>15</td>
                  <td>SUMINISTROS AVENCA</td>
                  <td></td>
                  <td></td>
                </tr>
              </tbody>
            </table>

            <p>Suponiendo las tres uniones siguientes: 1) CAN 2) MINI 3) PROV</p>
            <p>Se tendr√°n las siguientes posibilidades:</p>
            <p><b>Contar:</b> <code>PROV = SUMINISTROS AVENCA</code></p>
            <ul>
              <li>Respuesta: 2</li>
              </ul>

            <p><b>Posicionamiento y lectura:</b> <code>CAN &gt; 60</code></p>
            <ul>
              <li>Respuesta: LAVABO (100), RADIADOR (200)</li>
              </ul>

            <p><b>Posicionamiento y lectura:</b> <code>MINI &lt; 16</code></p>
            <ul>
              <li>Respuesta: RADIADOR (10), BA√ëERA (15)</li>
              </ul>

            <hr />

            <h3>Generalidades</h3>

            <h4>Un fichero multicriterio:</h4>
            <ul>
              <li>Est√° organizado de forma m√°s evolucionada que un fichero secuencial indexado</li>
              <li>Utiliza el m√©todo de acceso secuencial indexado</li>
              <li>Est√° compuesto de cuatro ficheros contenidos en el mismo volumen:</li>
              <ul>
                <li><b>Fichero -I</b> (S.I.)</li>
                <li><b>Fichero -D</b> (S.I.)</li>
                <li><b>Fichero -V</b> : Fichero de Valores de Uniones</li>
                <li><b>Fichero -R</b> : Fichero de Referencias de claves</li>
                </ul>
              </ul>

            <p>Los ficheros -I, -V, -R, est√°n organizados como los ficheros de tipo secuencial indexado.</p>
            <p>Los ficheros -V y -R tienen datos de longitud NULA (no datos).</p>
            <hr />

            <h3>Descripci√≥n de un Registro</h3>

            <h4>Estructura del Registro</h4>
            <table>
              <thead>
                <tr>
                  <th>Clave</th>
                  <th>Index</th>
                  <th>Datos</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>2 a 40 octetos</td>
                  <td>1 octeto</td>
                  <td>Rubrica 1, Rubrica 2, ..., Rubrica N (max 255)</td>
                </tr>
              </tbody>
            </table>

            <ul>
              <li>Longitud m√°xima para rubricas: 2700 octetos</li>
              <li>N√∫mero m√°ximo de rubricas: 255</li>
              </ul>

            <h4>Clave</h4>
            <ul>
              <li>Como en S.I., pero es preciso elegir la m√°s corta posible</li>
              <li>Las claves de longitud superior a 40 octetos est√°n prohibidas</li>
              </ul>

            <h4>Index</h4>
            <ul>
              <li>Como en S.I.</li>
              </ul>

            <h4>Datos</h4>
            <ul>
              <li>Longitud m√°xima como en S.I., pero las rubricas (zonas de datos interrogables) est√°n siempre en los 2700 primeros octetos</li>
              <li>Longitud m√≠nima: aquella en la que todas las rubricas est√°n incluidas estando siempre en la zona de datos</li>
              </ul>

            <h4>Rubrica</h4>
            <p>Es una zona de datos especial que permitir√°:</p>
            <ul>
              <li>Encontrar o contar r√°pidamente los art√≠culos que responden a la cuesti√≥n pedida seg√∫n el valor de las uniones creadas con esta rubrica</li>
              <li>Encontrar secuencialmente los art√≠culos que responden a la cuesti√≥n pedida aunque no exista ninguna uni√≥n que responda a esta cuesti√≥n</li>
              </ul>

            <h4>Valor de una Rubrica</h4>
            <ul>
              <li>El valor de una rubrica es el valor de la informaci√≥n contenida en esa zona de datos</li>
              <li>El valor puede ser:</li>
              <ul>
                <li>Una cadena de caracteres: el sistema la cuadrar√° a la izquierda para sus necesidades, pero la rubrica no es modificada</li>
                <li>Un num√©rico: el sistema no hace ning√∫n cuadre</li>
                <li>Si la rubrica es un num√©rico largo (de tipo B como B.C.D.), el usuario debe hacer una funci√≥n FIX en esta zona antes de toda inserci√≥n y/o modificaci√≥n de este registro (INSERT o MODIF)</li>
                </ul>
              </ul>

            <h4>Tama√±o de una Rubrica</h4>
            <p>Es el n√∫mero de octetos declarados para esa rubrica, puede ser de tama√±o inferior a la zona de datos, en este caso s√≥lo el principio de la zona es tomada en consideraci√≥n.</p>
            <h4>Uniones/Enlaces</h4>
            <ul>
              <li>Es una rubrica (o una combinaci√≥n de 2 a 10 rubricas) que permite(n) encontrar o contar r√°pidamente el(los) art√≠culo(s) seg√∫n el valor de este enlace</li>
              <li>El n√∫mero m√°ximo de enlaces es de 255</li>
              <li>La suma de tama√±os de rubricas que componen un enlace no puede ser mayor de 40 octetos</li>
              </ul>

            <h4>Valor de un Enlace</h4>
            <p>Es la concatenaci√≥n de los valores de las rubricas que componen el enlace.</p>
            <hr />

            <h3>Las √ìrdenes</h3>

            <h4>√ìrdenes id√©nticas a S.I.</h4>
            <pre><code>OPEN=
CLOSE=
RENAME=     (Ficheros asignados en exclusividad)
EXTEND=     (Ficheros asignados en exclusividad)
ATB=

INSERT=     DELETE=     MODIF=

SEARCH=     SEARCH.M=   SEARCH.ML=  SEARCH.L=</code></pre>

            <h4>√ìrdenes que han evolucionado</h4>
            <pre><code>ASSIGN=     CFILE=      DFILE=

DOWN=       DOWN.M=     DOWN.ML=    DOWN.L=

UP=         UP.M=       UP.ML=      UP.L=</code></pre>

            <h4>√ìrdenes nuevas</h4>
            <table>
              <thead>
                <tr>
                  <th>Orden</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>KEY=</code></td>
                  <td>Declara una rubrica</td>
                </tr>
                <tr>
                  <td><code>CKEY=</code></td>
                  <td>Crea las rubricas</td>
                </tr>
                <tr>
                  <td><code>NKEY=</code></td>
                  <td>Renombra una rubrica</td>
                </tr>
                <tr>
                  <td><code>FKEY=</code></td>
                  <td>Redefine una rubrica</td>
                </tr>
                <tr>
                  <td><code>RKEY=</code></td>
                  <td>Anula la declaraci√≥n de las rubricas, permanecen creadas</td>
                </tr>
                <tr>
                  <td><code>LKEY=</code></td>
                  <td>Leer las declaraciones de rubricas</td>
                </tr>
                <tr>
                  <td><code>LINK=</code></td>
                  <td>Declara un enlace</td>
                </tr>
                <tr>
                  <td><code>CLINK=</code></td>
                  <td>Crea los enlaces</td>
                </tr>
                <tr>
                  <td><code>LLINK=</code></td>
                  <td>Leer las declaraciones de los enlaces</td>
                </tr>
                <tr>
                  <td><code>COUNT=</code></td>
                  <td>Cuenta el n√∫mero de art√≠culos que concuerdan con la cuesti√≥n</td>
                </tr>
                <tr>
                  <td><code>POSIT=</code></td>
                  <td>Posicionamiento antes del primer registro que concuerda</td>
                </tr>
                <tr>
                  <td><code>POSIT.D=</code></td>
                  <td>Posicionamiento despu√©s del √∫ltimo registro que concuerda</td>
                </tr>
                <tr>
                  <td><code>STAT=</code></td>
                  <td>Da informaciones de estado</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Ejemplo de Declaraciones</h3>

            <pre><code>*
***     Para todos los ejemplos se supondr√°n las declaraciones siguientes.
***     Fichero Clave(LK) C1 de 10 octetos, Datos D1 de 30 octetos
*
FIELD=M
DCL L1%     ; Tama√±o a leer de datos
DCL C1$=10  ; Nombre del art√≠culo (clave)
DCL I1#     ; Index declaraci√≥n obligatoria 1 octeto
DCL D1%     ; Cantidad     (CAN) num√©rica corta
DCL M1%     ; Stock m√≠nimo (MINI) num√©rica corta
DCL P1=8    ; Precio (PRECIO) Es B.C.D. tiene dos decimales
*           ; Se har√° P1=FIX(P1,2) antes de todo INSERT= o MODIF=
*
DCL F1$=18  ; Proveedor (PROV) Cadena de 18 caracteres
*
***     Fin del art√≠culo
*
DCL E%      ; C√≥d. respuesta (error)
*
dcl I2#     ; Variable de index para llamar por DOWN= UP= o SEARCH.M[L]=
*
DCL Q$=60   ; Cuesti√≥n multi-criterio
DCL Q1(2)   ; Q1(1) N√∫mero de respuestas en COUNT=
*           ; Q1(2) N√∫mero de respuestas en POSIT[.D]=
*
DCL Z7$=20(4)   ; Zona de trabajo M.C. para 4 rubricas (4*20=80)</code></pre>

            <hr />

            <h3>ASSIGN= - Orden de Asignaci√≥n</h3>

            <h4>Sintaxis</h4>
            <pre><code>ASSIGN=Nlog,"Fich",MC [,DF] [,WR] [,EX] [,C] : [Etiqu,E,] ZONA [,Longitud]</code></pre>

            <h4>Par√°metros</h4>
            <table>
              <thead>
                <tr>
                  <th>Par√°metro</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>Nlog</code></td>
                  <td>Num√©rico corto comprendido entre 1 y 32. Es el n√∫mero l√≥gico de acceso al fichero M.C. PROLOGUE soporta hasta N aperturas M.C. simult√°neas para el conjunto de puestos de trabajo (seg√∫n la configuraci√≥n).</td>
                </tr>
                <tr>
                  <td><code>"Fich"</code></td>
                  <td>Cadena de caracteres que define: eventualmente el soporte de vuestro fichero (por defecto el impl√≠cito fichero utilizador IF se usa), el nombre del fichero, el tipo no tiene que ser indicado, eventualmente las claves de acceso del fichero (por defecto est√°n a blancos).</td>
                </tr>
                <tr>
                  <td><code>MC</code></td>
                  <td>Pide el acceso en multicriterio. Se puede acceder a un fichero M.C. en acceso secuencial indexado, es necesario entonces poner SI en ASSIGN= en lugar de MC, y s√≥lo √∫nicamente para consultas.</td>
                </tr>
                <tr>
                  <td><code>DF</code></td>
                  <td>Pide el tratamiento en modo diferido. Por defecto el tratamiento se har√° en tiempo real. En diferido, los enlaces se crear√°n en el curso de la ejecuci√≥n de la orden CLINK= (Crear enlaces). El tiempo de creaci√≥n es muy largo (1 seg/registro/enlace en un disco duro).</td>
                </tr>
                <tr>
                  <td><code>WR</code></td>
                  <td>Autoriza la escritura en este fichero.</td>
                </tr>
                <tr>
                  <td><code>EX</code></td>
                  <td>Autoriza la exclusividad de acceso a este fichero.</td>
                </tr>
                <tr>
                  <td><code>C</code></td>
                  <td>Autoriza el acceso en modo copia, los tiempos de ejecuci√≥n son m√°s cortos, pero la cohesi√≥n del fichero s√≥lo se asegura con el cierre de este fichero por CLOSE= o STOP, o la supresi√≥n del modo Copia por ATB=</td>
                </tr>
                <tr>
                  <td><code>Etiqu</code></td>
                  <td>Etiqueta de desv√≠o en caso de error diferente de cero.</td>
                </tr>
                <tr>
                  <td><code>E</code></td>
                  <td>Variable num√©rica corta conteniendo el error.</td>
                </tr>
                <tr>
                  <td><code>ZONA</code></td>
                  <td>Variable principio de zona de trabajo para M.C. El tama√±o de esta zona es la suma de 20 por el n√∫mero de rubricas declaradas.</td>
                </tr>
                <tr>
                  <td><code>Longitud</code></td>
                  <td>Tama√±o de la zona de trabajo. Por defecto el sistema toma el tama√±o declarado en la variable ZONA. La longitud de esta zona de trabajo debe ser de (20 * N√∫mero de rubricas).</td>
                </tr>
              </tbody>
            </table>

            <h4>Opciones de DF (Diferido)</h4>
            <p>Esta opci√≥n permite:</p>
            <ul>
              <li>Partir de un fichero S.I. para pasarlo a M.C. A continuaci√≥n ser√° siempre asignado en M.C., y eventualmente en tiempo diferido para las puestas al d√≠a.</li>
              <li>Diferir en el tiempo los tratamientos m√°s largos (creaci√≥n de enlaces), para optimizar los tiempos de puesta al d√≠a del fichero.</li>
              </ul>

            <p>El fichero estando asignado en diferido, es incluso consultable pero en este caso el sistema ignora los enlaces que han sido creados en la sesi√≥n.</p>
            <p>Un mismo fichero puede ser asignado:</p>
            <ul>
              <li>En tiempo real</li>
              <li>Como en tiempo diferido</li>
              </ul>

            <p>En un multipuesto, puede asignarse en tiempo real en un puesto y en diferido para otro puesto.</p>
            <h4>Ejemplo</h4>
            <pre><code>dcl Z7$=20(4)

8500 ASSIGN=1,"STOCK",MC,WR:Z7(1),80    ; Assign= en M.C.
     RETURN
8510 ASSIGN=1,"STOCK",SI,WR             ; en SI para DFILE=
     RETURN</code></pre>

            <p>Asignar el n√∫mero l√≥gico 1 al fichero "STOCK", en multicriterio (M.C.) con autorizaci√≥n de escritura (WR).</p>
            <p>Z7(1), Z7(2), Z7(3), Z7(4) es la zona de trabajo para M.C.</p>
            <p>El tama√±o de la zona es de 80 octetos: 4 Rubricas: 4 * 20 = 80</p>
            <hr />

            <h3>CFILE= - Creaci√≥n del Fichero</h3>

            <h4>Definici√≥n</h4>
            <p>La creaci√≥n del fichero da al sistema los par√°metros generales de este fichero.</p>
            <p>Los par√°metros son iguales que para un fichero S.I. s√≥lo que en este caso el tama√±o de los datos no puede ser nulo, aunque no haya ninguna zona de datos interrogables.</p>
            <p>Todas las rubricas (zonas de datos interrogables) deber√°n existir en todos los datos de cada art√≠culo (o registro) incluso si el fichero est√° declarado en longitud variable.</p>
            <p>La creaci√≥n de fichero en M.C. puede hacerse:</p>
            <ul>
              <li>Bien para un nuevo fichero</li>
              <li>Bien a partir de un fichero S.I. ya existente</li>
              </ul>

            <p>En este caso:</p>
            <ul>
              <li>Hay que dar en M.C. los mismos par√°metros que los usados en S.I. (misma clave, mismos datos)</li>
              <li>Si algunos enlaces tienen num√©ricos largos (B.C.D.) es necesario modificar el S.I. haciendo FIX en todos los num√©ricos largos</li>
              <li>El fichero S.I. no se modifica pero se podr√°n crear los enlaces deseados en tiempo diferido</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>                                LK =
CFILE=NLog, VD [=Long.hueco]  , RK = LongClave [ : Etiqu,E ]
             D  =Long.Datos      K =</code></pre>

            <p>Despu√©s CFILE= habr√° en el soporte cuatro ficheros de tipo: -I, -D (la parte S.I.), -V, -R (los ficheros de valores y de referencias de M.C.)</p>
            <h4>Ejemplo</h4>
            <pre><code>*
***   Llama S/P Assign
*
gosub 8500
CFILE=1,D=30,LK=10  ; Crear el fichero en M.C.</code></pre>

            <hr />

            <h3>DFILE= - Destrucci√≥n de Fichero</h3>

            <h4>Definici√≥n</h4>
            <p>La destrucci√≥n del fichero suprime del soporte los ficheros de Valores y de Referencias de M.C., llamados tambi√©n Diccionario; es decir, los ficheros de tipo -V y -R.</p>
            <p>Sin embargo, la parte S.I. (de tipo -I y -D) no se modifica ni se destruye.</p>
            <p>Esto permite volver a crear, en diferido, nuevos enlaces por ejemplo, los enlaces viejos han sido destruidos.</p>
            <p>Si se quiere destruir completamente el fichero, hay que asignarlo en S.I. y pedir una nueva destrucci√≥n del fichero.</p>
            <h4>Sintaxis</h4>
            <pre><code>DFILE= Nlog [ : Etiqu,E ]</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>    SEGMENT 0
    GOTO 100                ; Principio de ejecuci√≥n normal
    *
    *** Acceso en DBUG, DFILE, CFILE
    *
    GOSUB 8500              ; Asignar en M.C.
    *
    DFILE=1:10,E            ; Destruir el M.C. (-V y -R)
    *                       ; Si no existe, ejecutar en secuencia
10  GOSUB 8510              ; Asignar en S.I.
    DFILE=1:20,E            ; Destruir el S.I. (-I y -D)
    *
20  GOSUB 8500              ; Reasignar en M.C.
    CFILE=1,D=30,LK=10      ; Crear el M.C. (-I -D -V -R)
    *                       ; Las Rubricas y enlaces no se crean
    *** Principio de Ejecuci√≥n Standard
    *

100 GOSUB 8500              ; Asignar en M.C.
    *                       ; Para la ejecuci√≥n normal.</code></pre>

            <hr />

            <h3>KEY= - Declaraci√≥n de una Rubrica</h3>

            <h4>Definici√≥n</h4>
            <p>La declaraci√≥n de una zona de datos en forma de rubrica permitir√° preguntar al fichero seg√∫n el valor de esta rubrica o de una combinaci√≥n de √©sta con otras.</p>
            <p>La declaraci√≥n de una zona de datos en forma de rubrica debe ser hecha en todo programa que use M.C.:</p>
            <ul>
              <li>Despu√©s de la asignaci√≥n de un fichero en multicriterio</li>
              <li>Despu√©s de un eventual RKEY=</li>
              <li>Antes de la creaci√≥n de la rubrica (CKEY=)</li>
              <li>Antes de toda declaraci√≥n de un enlace con esta rubrica (LINK=)</li>
              <li>Antes de cualquier cuesti√≥n sobre esta rubrica (COUNT=, POSIT[.D]=)</li>
              </ul>

            <p>El n√∫mero m√°ximo de rubricas es de 255.</p>
            <p>Si las rubricas han sido creadas, se puede, en un programa de consulta, declarar s√≥lo algunas rubricas con el fin de proteger otras a determinadas cuestiones.</p>
            <h4>Sintaxis</h4>
            <pre><code>KEY=NLog,"Nombre de Rubrica", Long [, B [,No] ] [:Etiqu,E]
                                      N</code></pre>

            <h4>Par√°metros</h4>
            <table>
              <thead>
                <tr>
                  <th>Par√°metro</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>NLog</code></td>
                  <td>N√∫mero l√≥gico definido en el Assign=</td>
                </tr>
                <tr>
                  <td><code>"Nombre de Rubrica"</code></td>
                  <td>Nombre de la rubrica. Es una cadena de caracteres de longitud 1 a 16.</td>
                </tr>
                <tr>
                  <td><code>Long</code></td>
                  <td>N√∫mero de octetos de esta rubrica. Es un num√©rico corto. S√≥lo los 40 primeros octetos de una zona son interrogables.</td>
                </tr>
                <tr>
                  <td><code>N</code></td>
                  <td>Tipo Num√©rica corta</td>
                </tr>
                <tr>
                  <td><code>B</code></td>
                  <td>Tipo B.C.D. Num√©rica larga. Necesario hacer FIX</td>
                </tr>
                <tr>
                  <td><code>No</code></td>
                  <td>N√∫mero de decimales a conservar para los FIX(-,No). Por defecto hace FIX(-)</td>
                </tr>
                <tr>
                  <td>(Por defecto)</td>
                  <td>Tipo cadena de caracteres</td>
                </tr>
              </tbody>
            </table>

            <h4>Reglas para Declaraci√≥n</h4>
            <p>Las rubricas deben ser declaradas, para la creaci√≥n:</p>
            <ul>
              <li>A partir del 1er octeto de datos</li>
              <li>En el orden de los datos</li>
              <li>Respetando los tipos y los tama√±os declarados para los datos del fichero</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>*
***     Sub-programa: declaraci√≥n de rubricas KEY=
*

8600    KEY= 1,"CAN" ,2,N         ; Num√©rica corta 2 octetos
        KEY= 1,"MINI",2,N         ; Num√©rica corta 2 octetos
        KEY= 1,"PRECIO",8,B ,2    ; B.C.D. (Largo) 8 octetos y 2 decimales
        KEY= 1,"PROV",15          ; Cadena de caracteres 15 octetos
        *                         ; S√≥lo los 15 primeros caracteres del
        *                         ; proveedor se toman en cuenta.
        return</code></pre>

            <p>La longitud de la zona de trabajo de M.C. (Z7(1), ...), definida en el ASSIGN=, debe ser de 80 octetos al menos (4 * 20 = 80, donde 4 es el n√∫mero de rubricas).</p>
            <hr />

            <h3>CKEY= - Creaci√≥n de Rubricas</h3>

            <h4>Definici√≥n</h4>
            <ul>
              <li>Permite crear las rubricas declaradas por el (los) KEY= precedente(s)</li>
              <li>La creaci√≥n de rubricas s√≥lo se puede hacer una sola vez, salvo para insertar nuevas rubricas</li>
              <li>Se puede siempre a√±adir una rubrica de m√°s a un fichero M.C. que ya existe, siempre con el l√≠mite del n√∫mero m√°ximo de rubricas (255)</li>
              <li>En este caso no es preciso obligar a crear tambi√©n los nuevos enlaces, en diferido (opci√≥n DF de ASSIGN=)</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>CKEY= NLog [: Etiqu,E]</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>    SEGMENT 0
    GOTO 100                ; Principio de ejecuci√≥n normal
    *
    **  Acceso en DBUG, DFILE, CFILE y CKEY
    *
    GOSUB 8500              ; Asignar el fichero en M.C.
    *

    DFILE= 1 : 10,E         ; destruir -V y -R   Ejecutar en secuencia
10  gosub 8510              ; Asignar en S.I.
    DFILE= 1 : 20,E         ; destruir -I y -D en caso de error (no existente)
    *
20  gosub 8500              ; reasignar en M.C.
    CFILE= 1,D =30,LK=10    ; Crear el M.C. (-I -D -V -R)
    *
    GOSUB 8600              ; KEY= Declarar las 4 rubricas
    CKEY= 1                 ; Crear las rubricas una sola vez
    *
    *** Principio de ejecuci√≥n standard
    *
100 GOSUB 8500              ; Asigna el fichero en M.C.
    GOSUB 8600              ; Declarar las rubricas, para la interrogaci√≥n.
    *</code></pre>

            <hr />

            <h3>RKEY= - Suprime las Declaraciones de Rubricas</h3>

            <h4>Definici√≥n</h4>
            <p>Esta orden borra las declaraciones de rubricas (KEY=) memorizadas por el BAL en el tamp√≥n de la orden ASSIGN=.</p>
            <p>Las rubricas permanecen creadas en el diccionario (-V).</p>
            <p>Esto permite cambiar las rubricas que ser√°n interrogables, volviendo a hacer nuevos KEY=, sin cerrar el fichero.</p>
            <p>Esta orden es √∫til para declarar y despu√©s crear una nueva rubrica en el diccionario, cuando una o varias rubricas han sido ya declaradas por KEY= y memorizadas por el BAL en el tamp√≥n de la orden ASSIGN=.</p>
            <h4>Sintaxis</h4>
            <pre><code>RKEY=NLog [ : Etiqu,E ]</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>    ASSIGN=1,FICH,MC,WR,EX:Z7(1),80  ; Asigna el fichero FICH en M.C.
    KEY= 1,"CAN" , 2 , N    ; Num√©rica corta 2 octetos
    KEY= 1,"MINI", 2 , N    ; Num√©rica corta 2 octetos
    KEY= 1,"PRECIO",8,B,2   ; B.C.D. (Largo) 8 octetos y 2 decimales
    CKEY=1                  ; crea 3 rubricas
    ...
    RKEY=1                  ; anula las 3 declaraciones
                            ; las rubricas quedan CREADAS
    KEY= 1,"PROV",15        ; Cadena de caracteres 15 octetos
    CKEY=1                  ; crea la 4a rubrica
    ...</code></pre>

            <hr />

            <h3>NKEY= - Renombra una Rubrica</h3>

            <h4>Definici√≥n</h4>
            <p>Esta orden cambia el nombre de una rubrica en el diccionario del fichero (-V).</p>
            <p>A continuaci√≥n, s√≥lo el nuevo nombre de la rubrica puede ser usado para acceso.</p>
            <p>Esta orden s√≥lo puede ejecutarse si la unicidad de los nombres de rubricas se respeta.</p>
            <h4>Sintaxis</h4>
            <pre><code>NKEY=NLog ,"Viejo Nombre" , "Nuevo Nombre" [ : Etiqu,E ]</code></pre>

            <p>"Viejo Nombre" y "Nuevo Nombre" son cadenas de caracteres (constantes, variables o expresiones).</p>
            <h4>Ejemplo</h4>
            <pre><code>    ASSIGN=1,FICH,MC,WR,EX:Z7(1),80  ; Asigna el fichero FICH en M.C.
    KEY= 1,"CANTIDAD" , 2 , N       ; Num√©rica corta 2 octetos
    KEY= 1,"MINI", 2 , N            ; Num√©rica corta 2 octetos
    KEY= 1,"PRECIO", 8 , B , 2      ; B.C.D. (Largo) 8 octetos/ 2 decimales
    CKEY=1                          ; crea 3 rubricas
    ...
    NKEY=1,"CANTIDAD" , "CAN"       ; La rubrica CANTIDAD se renombra a CAN
    ...</code></pre>

            <hr />

            <h3>FKEY= - Redefinici√≥n de Rubricas</h3>

            <h4>Definici√≥n</h4>
            <p>Esta orden permite descomponer una rubrica en N sub-rubricas que podr√°n usarse separadamente llam√°ndolas por su nombre.</p>
            <p>El tama√±o total de las sub-rubricas no puede sobrepasar el de la rubrica redefinida.</p>
            <p>Esta orden s√≥lo se puede ejecutar si la unicidad de nombres de rubricas es respetada. Las sub-rubricas se crear√°n cuando se ejecutan los CKEY= que tienen que seguir a la redefinici√≥n.</p>
            <p>La redefinici√≥n de una rubrica se expresa en un bloque de instrucciones que se descompone en tres partes, y que seguir√° con un CKEY=:</p>
            <ul>
              <li>Una orden FKEY= indica el nombre de la rubrica a redefinir, √©sta tiene que haberse creado previamente</li>
              <li>Una sucesi√≥n de √≥rdenes KEY= que declaran, igual que a una rubrica, cada una de las sub-rubricas: su tipo, su tama√±o y su posici√≥n relativa</li>
              <li>Una orden FKEY= indica el fin de la redefinici√≥n</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>FKEY=NLog , "Nombre de Rubrica"  [ : Etiqu,E ]

KEY=NLog  , ...     ; Redefinici√≥n de la rubrica
KEY=NLog  , ...     ;  ...
...

FKEY=NLog  [ : Etiqu,E ]
...
CKEY=NLog  [ : Etiqu,E ]    ; Creaci√≥n de sub-rubricas en el -V</code></pre>

            <h4>Ejemplo</h4>
            <pre><code>    ASSIGN=1,FICH,MC,WR,EX:Z7(1),80  ; Asigna el fichero FICH en M.C.
    KEY= 1,"CODpostal", 5           ; Cadena de 5 caracteres
    CKEY=1                          ; crea la rubrica
    ...
    RKEY=1                          ; Inicializa el tamp√≥n
    FKEY=1,"CODpostal"              ; Principio de la redefinici√≥n
    KEY=1,"PROVINCIA",2             ; N√∫mero de la provincia en el tamp√≥n
    KEY=1,"ORDEN",3                 ; N√∫mero de orden en el tamp√≥n
    FKEY=1                          ; fin de la redefinici√≥n
    CKEY=1          ; crear las sub-rubricas que est√°n en el tamp√≥n.</code></pre>

            <hr />

            <h3>LKEY= - Lista de Rubricas</h3>

            <h4>Definici√≥n</h4>
            <p>Se pueden releer las declaraciones de todas las rubricas creadas. Los resultados se dan seg√∫n el orden de las declaraciones.</p>
            <p>En cada llamada el sistema da:</p>
            <table>
              <thead>
                <tr>
                  <th>Dato</th>
                  <th>Tipo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Nombre de la rubrica</td>
                  <td>16 caracteres ($)</td>
                  <td></td>
                </tr>
                <tr>
                  <td>Tama√±o de la rubrica</td>
                  <td>2 octetos (%)</td>
                  <td></td>
                </tr>
                <tr>
                  <td>Tipo de la rubrica</td>
                  <td>1 octeto (#)</td>
                  <td>0=$ (cadena), 4=Num√©rico</td>
                </tr>
                <tr>
                  <td>Posici√≥n / Principio Datos</td>
                  <td>2 octetos (%)</td>
                  <td></td>
                </tr>
              </tbody>
            </table>

            <p>La posici√≥n de la rubrica en el registro se calcula a partir del principio de los datos, el cero corresponde al primer octeto de datos.</p>
            <p>El fin de la lista se se√±ala por un c√≥digo de error diferente de cero (=96).</p>
            <h4>Sintaxis</h4>
            <pre><code>LKEY=NLog [ , (( ZONA )) ] : [ Etiqu,E, ] V [,L ]
          [ ,  (  F   )  ]</code></pre>

            <p>S√≥lo se puede poner uno de los par√°metros en el mismo orden.</p>
            <ul>
              <li><code>(F)</code> indica la primera llamada (principio de lista)</li>
              <li><code>ZONA</code> es una variable de tipo cadena de caracteres que contiene: o el car√°cter F que indica el principio de lista, o un blanco que indica que se lea la continuaci√≥n de la lista. ZONA se pone entre 2 niveles de par√©ntesis ((ZONA))</li>
              <li>Por defecto de par√°metro se lee la sucesi√≥n de la lista</li>
              <li><code>V [, L]</code> define la zona de recepci√≥n que debe ser de 21 octetos</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>    LKEY=1,(F):ZONERUB              ; Primera Llamada</code></pre>

            <p>Despu√©s de la primera llamada (opci√≥n (F)), ZONERUB contiene:</p>
            <ul>
              <li>Nombre de la rubrica: CANTIDAD</li>
              <li>Tama√±o de la rubrica: 2</li>
              <li>Tipo de la rubrica: 4 (Num√©rica)</li>
              <li>Posici√≥n: 0</li>
              </ul>

            <pre><code>    LKEY=1    :ZONERUB              ; Llamada siguiente</code></pre>

            <p>Despu√©s de la segunda llamada (sin opciones), ZONERUB contiene:</p>
            <ul>
              <li>Nombre de la rubrica: MINI</li>
              <li>Tama√±o de la rubrica: 2</li>
              <li>Tipo de la rubrica: 4 (Num√©rica)</li>
              <li>Posici√≥n: 2</li>
              </ul>

            <pre><code>    LKEY=1    :ZONERUB              ; Llamada siguiente</code></pre>

            <p>Despu√©s de la tercera llamada (sin opciones), ZONERUB contiene:</p>
            <ul>
              <li>Nombre de la rubrica: PRECIO</li>
              <li>Tama√±o de la rubrica: 8</li>
              <li>Tipo de la rubrica: 4 (Num√©rica)</li>
              <li>Posici√≥n: 4</li>
              </ul>

            <hr />

            <h3>LINK= - Declaraci√≥n de un Enlace</h3>

            <h4>Definici√≥n</h4>
            <ul>
              <li>La declaraci√≥n de un enlace permite indicar la sucesi√≥n de rubricas que compondr√° una cuesti√≥n (r√°pida)</li>
              <li>La declaraci√≥n de un enlace s√≥lo se puede hacer una sola vez, para cada enlace</li>
              <li>En todo momento un enlace puede ser insertado o suprimido (opci√≥n (D))</li>
              <li>Despu√©s de declarar todos los enlaces, √©stos deber√°n ser creados o destruidos (CLINK=)</li>
              <li>La declaraci√≥n de un enlace tiene que hacerse despu√©s de la declaraci√≥n de las diferentes rubricas que componen dicho enlace</li>
              <li>Un enlace puede estar compuesto de 1 a 10 rubricas</li>
              <li>La suma de longitudes de cada rubrica de un enlace debe ser inferior o igual a 40</li>
              <li>Se puede, en todo instante, definir una declaraci√≥n de enlace en un fichero MC, ya existente, teniendo en cuenta el n√∫mero m√°ximo de enlaces (255)</li>
              </ul>

            <h4>Opci√≥n (A) - Todas las Combinaciones</h4>
            <p>El orden de las rubricas en la declaraci√≥n de un enlace es importante:</p>
            <ul>
              <li>Define la(s) rubrica(s) (y su orden) en las cuestiones que se podr√°n hacer gracias al enlace</li>
              </ul>

            <p>Una opci√≥n (A) permite la interrogaci√≥n con cuestiones que lleven varias rubricas de un mismo enlace, las rubricas aparecer√°n en cualquier orden en la cuesti√≥n.</p>
            <p><b>Atenci√≥n:</b> En este caso, el n√∫mero de enlaces creados ser√°:</p>
            <table>
              <thead>
                <tr>
                  <th>Rubricas</th>
                  <th>Enlaces creados con opci√≥n (A)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>2</td>
                  <td>2</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>3</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>6</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>10</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>20</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>35</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>70</td>
                </tr>
                <tr>
                  <td>9</td>
                  <td>126</td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>252</td>
                </tr>
              </tbody>
            </table>

            <h4>Sintaxis</h4>
            <pre><code>LINK=NLog, "Descripci√≥n del enlace" [ ,((ZONA)) ] [:Etiqu,E]
                                    [ ,  (A)    ]
                                    [ ,  (D)    ]</code></pre>

            <ul>
              <li>"Descripci√≥n del enlace" es una sucesi√≥n de constantes o de variables cadenas de caracteres separadas por comas dando la sucesi√≥n del(de los) nombre(s) de rubricas que componen este enlace</li>
              <li>ZONA es una variable de tipo cadena, entre 2 niveles de par√©ntesis y que contiene el car√°cter "A" o "D" o un blanco, para indicar: Todas las combinaciones o Destruir este enlace o ninguna opci√≥n</li>
              </ul>

            <h4>Ejemplo sin opci√≥n (A)</h4>
            <pre><code>LINK=1, "A", "B", "C","D"</code></pre>

            <p>Permite poner cuestiones sobre las rubricas:</p>
            <ul>
              <li>A, B, C, D</li>
              <li>A, B, C</li>
              <li>A, B</li>
              <li>A</li>
              </ul>

            <p>(Permite cuatro cuestiones diferentes en este orden)</p>
            <p>Si la opci√≥n (A) se hubiera pedido, todas las combinaciones de estas cuatro rubricas se permitir√°n, pero el n√∫mero de enlaces habr√≠a sido de 6.</p>
            <h4>Advertencia</h4>
            <p>El n√∫mero total de enlaces de un fichero influye directamente sobre el tama√±o de cada uno de los ficheros -V y -R, y en el tiempo de acceso.</p>
            <p>Una buena elecci√≥n de los nombres de rubrica que componen los enlaces permiten satisfacer el m√°ximo de cuestiones, optimizando el espacio y tiempo.</p>
            <h4>Ejemplo Completo de Declaraci√≥n de Enlaces</h4>
            <p>Suponemos que se quiere (por ejecuci√≥n bajo Dbug en la direcci√≥n 3):</p>
            <ul>
              <li>Destruir los ficheros M.C. y S.I.</li>
              <li>Despu√©s crear el fichero en M.C.</li>
              <li>Luego crear cuatro rubricas</li>
              <li>y luego declarar dos enlaces.</li>
              </ul>

            <pre><code>    SEGMENT 0
    GOTO 100                ; Principio de ejecuci√≥n normal
    *
    *
    GOSUB 8500              ; Asignar el fichero  : en M.C.
    *
    DFILE=1:10,E            ; Destruir -V y -R  Ejecutar en secuencia.
10  GOSUB 8510              ; assign en SI
    DFILE=1:20,E            ; Destruir -I y -D  en caso de error
20  gosub 8500              ; assign en MC
    CFILE=1,D=30,LK=10      ; Crear el M.C. (-I -D -V -R)
    *
    GOSUB 8600              ; KEY= Declarar 4 rubricas
    CKEY=1                  ; Crear las rubricas, una sola vez.
    *
    *** Declarar los 2 enlaces, una sola vez autorizando las cuestiones :
    *
    *   "PROV","CAN","PRECIO","MINI"
    *   "PROV","CAN","PRECIO"
    *   "PROV","CAN"
    *   "PROV"
    *
    *   "CAN","PRECIO"
    *   "CAN"
    *
    LINK=1,"PROV","CAN","PRECIO","MINI"
    LINK=1,"CAN","PRECIO"
    *
    *** Principio de ejecuci√≥n  ATENCI√ìN los enlaces no est√°n creados
    *
100 GOSUB 8500              ; Asignar el fichero  : en M.C.
    *
    GOSUB 8600              ; Declarar las rubricas, para la interrogaci√≥n.</code></pre>

            <hr />

            <h3>CLINK= - Creaci√≥n de Enlaces</h3>

            <h4>Definici√≥n</h4>
            <p>Despu√©s de la declaraci√≥n de enlace, la creaci√≥n obtiene las REFERENCIAS asociadas a los VALORES multi-criterios.</p>
            <p>La creaci√≥n de enlaces pone al d√≠a el fichero de referencias (-R) para tomar en cuenta las inserciones y modificaciones hechas en diferido, y los enlaces que no han sido todav√≠a creados.</p>
            <p>La creaci√≥n de enlaces permite la interrogaci√≥n r√°pida.</p>
            <p>La creaci√≥n de enlaces concierne a:</p>
            <ul>
              <li>Los enlaces nuevos que no han sido a√∫n creados</li>
              <li>Los registros insertados (INSERT=) o modificados (MODIF=) en diferido</li>
              </ul>

            <p>Esta orden permite:</p>
            <ul>
              <li>Trabajar en un solo enlace, designado en el CLINK=, √©ste entonces puede ser creado o suprimido</li>
              <li>O trabajar en todos los enlaces, para crear sus referencias</li>
              </ul>

            <h4>Tiempo Real vs Diferido</h4>
            <p><b>En tiempo real:</b> La creaci√≥n de enlaces s√≥lo se debe hacer una sola vez en la vida del fichero, despu√©s de la declaraci√≥n de enlaces. Las puestas al d√≠a se hacen en tiempo real, en cada inserci√≥n (INSERT), supresi√≥n (DELETE=) o modificaci√≥n (MODIF=), de forma autom√°tica, y el fichero M.C. ser√° interrogable en cualquier momento.</p>
            <p><b>En diferido (Opci√≥n DF en ASSIGN=):</b> Las puestas al d√≠a del fichero de referencias no se hacen m√°s que en la ejecuci√≥n de la orden CLINK=. La ejecuci√≥n de la creaci√≥n de enlaces debe ser hecha antes de poner las cuestiones, si no, el multicriterio ignora las puestas al d√≠a.</p>
            <h4>Recomendaciones</h4>
            <p>Se aconseja crear los enlaces:</p>
            <ul>
              <li>En modo exclusivo (EX), para un multipuesto</li>
              <li>En modo copia (C), para mejorar los rendimientos, si se hace una salvaguardia</li>
              </ul>

            <h4>Sintaxis</h4>
            <pre><code>CLINK=NLog [,"Descripc.del enlace" ][ ,((ZONA)) ]  [ : Etiqu,E ]
                  o blanco          [    (D)    ]</code></pre>

            <ul>
              <li>Una cadena a blancos significa: ninguna opci√≥n</li>
              <li>Por defecto de opci√≥n el CLINK= trabaja en todos los enlaces, es una creaci√≥n</li>
              <li>Si la opci√≥n D se elige la "Descripc.del enlace" es obligatoria</li>
              </ul>

            <h4>Advertencia</h4>
            <p>La creaci√≥n de enlaces puede ser muy larga.</p>
            <p>El tiempo del CLINK= es proporcional:</p>
            <ul>
              <li>Al n√∫mero de enlaces a crear y al n√∫mero de registros del fichero SI, en caso de declaraci√≥n de un nuevo enlace</li>
              <li>O al n√∫mero de registros insertados o modificados en diferido</li>
              </ul>

            <p>Este tiempo es: <b>1 segundo / registro / enlace</b>, en un disco duro.</p>
            <h4>Ejemplo</h4>
            <pre><code>    SEGMENT 0
    GOTO 100                ; Principio de ejecuci√≥n normal
    *
    ** Acceso en Dbug, DFILE, CFILE, CKEY, LINK y CLINK
    *
    GOSUB 8500              ; Asignar el fichero: en M.C.
    DFILE=1:10,E            ; Destruir -V y -R  Ejecutar en secuencia.
10  GOSUB 8510              ; assign en SI
    DFILE=1:20,E            ; Destruir -I y -D
20  gosub 8500              ; assign en MC
    CFILE=1,D=30,LK=10      ; Crear el M.C. (-I -D -V -R)
    *
    GOSUB 8600              ; KEY= Declarar 4 rubricas
    CKEY=1                  ; Crear las rubricas, una sola vez.
    *
    *** Declarar 2 enlaces autorizando las cuestiones:
    *
    *   "PROV","CAN","PRECIO","MINI"
    *   "PROV","CAN","PRECIO"
    *   "PROV","CAN"
    *   "PROV"
    *
    *   "CAN","PRECIO"
    *   "CAN"
    *
    LINK=1,"PROV","CAN","PRECIO","MINI"
    LINK=1,"CAN","PRECIO"
    *
    ***                     ; Crear los enlaces
    *
    CLINK=1
    *
    *** Supresi√≥n del enlace "CAN","PRECIO"
    *
    LINK=1 ,"CAN","PRECIO", (D)
    CLINK=1,"CAN","PRECIO", (D)</code></pre>

            <hr />

            <h3>LLINK= - Lista de Enlaces</h3>

            <h4>Definici√≥n</h4>
            <p>Se puede consultar la declaraci√≥n de todos los enlaces, cada ejecuci√≥n de esta orden da la declaraci√≥n de un enlace.</p>
            <p>La lista de enlaces se compone de tres partes (tipos de enlace):</p>
            <ul>
              <li>Enlaces creados</li>
              <li>Enlaces a crear</li>
              <li>Enlaces a suprimir</li>
              </ul>

            <p>Cada una de estas partes puede estar vac√≠a.</p>
            <p>Las declaraciones de enlaces se ordenan por tipo de enlace y en orden creciente del n√∫mero de rubricas.</p>
            <p>En cada llamada el sistema da:</p>
            <table>
              <thead>
                <tr>
                  <th>Dato</th>
                  <th>Tipo</th>
                  <th>Valores</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Tipo del enlace</td>
                  <td>1 octeto (#)</td>
                  <td>20: Enlace Creado, 24: Enlace a Crear, 26: A Suprimir</td>
                </tr>
                <tr>
                  <td>N√∫mero de rubricas</td>
                  <td>1 octeto (#)</td>
                  <td></td>
                </tr>
                <tr>
                  <td>Lista de nombres de rubricas</td>
                  <td>16 octetos ($) por rubrica</td>
                  <td>En el orden del enlace</td>
                </tr>
              </tbody>
            </table>

            <p>El fin de la lista se se√±ala por un error distinto de cero (=96).</p>
            <h4>Sintaxis</h4>
            <pre><code>LLINK=NLog [ , (( ZONA )) ] : [ Etiqu,E, ] V [,L ]
           [ ,  (  F   )  ]</code></pre>

            <ul>
              <li><code>(F)</code> indica la primera llamada (principio de lista)</li>
              <li><code>ZONA</code> es una variable de tipo cadena de caracteres que contiene: o el car√°cter F que indica principio de lista, o un blanco que indica que se ha de leer la sucesi√≥n de la lista</li>
              <li><code>V [, L]</code> define la zona de recepci√≥n que debe ser de (2 + (N*16)) octetos donde N es el n√∫mero de rubricas del enlace</li>
              </ul>

            <h4>Ejemplo</h4>
            <pre><code>    LLINK=1,(F):ZONAENLACE  ; Primera llamada</code></pre>

            <p>Despu√©s de la 1a llamada (opci√≥n (F)), ZONAENLACE contiene:</p>
            <ul>
              <li>Tipo del enlace: 20 (enlace CREADO)</li>
              <li>N√∫mero de rubricas: 2</li>
              <li>1er nombre de rubrica: CAN</li>
              <li>2o nombre de rubrica: PRECIO</li>
              </ul>

            <pre><code>    LLINK=1    :ZONAENLACE  ; Llamada siguiente</code></pre>

            <p>Despu√©s de la 2a llamada (sin opciones), ZONAENLACE contiene:</p>
            <ul>
              <li>Tipo del enlace: 20 (enlace CREADO)</li>
              <li>N√∫mero de rubricas: 4</li>
              <li>1er nombre de rubrica: PROV</li>
              <li>2o nombre de rubrica: CAN</li>
              <li>3er nombre de rubrica: PRECIO</li>
              <li>4o nombre de rubrica: MINI</li>
              </ul>

            <pre><code>    LLINK=1:&amp;ERR,E,ZONAENLACE       ; √∫ltima llamada</code></pre>

            <p>Salida por error en &amp;ERR (c√≥digo de error 96 = fin de lista).</p>
            <hr />

            <h3>CUESTI√ìN - Definici√≥n</h3>

            <h4>Estructura de una Cuesti√≥n</h4>
            <p>Una cuesti√≥n aparecer√° como par√°metro de llamada en las √≥rdenes permitiendo:</p>
            <ul>
              <li>Contar el n√∫mero de registros que responde "S√ç" a la cuesti√≥n (COUNT=)</li>
              <li>Posicionarse delante o detr√°s del primer registro que responde "S√ç" a la cuesti√≥n (POSIT= o POSIT.D=), esto con el fin de leer por DOWN= o UP=</li>
              <li>Esto (COUNT= o POSIT[.D]=): bien r√°pidamente si existe un enlace, o bien m√°s lentamente si no existe enlace para responder a esta cuesti√≥n y si la opci√≥n (S) ha sido pedida</li>
              </ul>

            <h4>Composici√≥n</h4>
            <ul>
              <li>La cuesti√≥n puede estar en una cadena de caracteres o no</li>
              <li>Si la cuesti√≥n no est√° en una cadena de caracteres, el nombre de la rubrica y los valores est√°n en variables</li>
              <li>Una CUESTI√ìN est√° compuesta por 1 a 10 CRITERIOS, separados por comas</li>
              </ul>

            <h4>Criterio</h4>
            <p>Un CRITERIO est√° compuesto:</p>
            <ul>
              <li>De un nombre de RUBRICA, de un OPERADOR y de un VALOR</li>
              <li>O bien: de una rubrica, del operador "(" par√©ntesis apertura, dos valores separados por una coma, luego el operador ")" par√©ntesis de cierre</li>
              </ul>

            <p>Los espacios antes o detr√°s de los nombres de rubricas y los valores no son significativos.</p>
            <h4>Rubricas Interrogables</h4>
            <p>S√≥lo las RUBRICAS que se han declarado por KEY= despu√©s de ASSIGN= y/o despu√©s de RKEY= son interrogables por este programa. El orden de las declaraciones no tiene ninguna importancia.</p>
            <p>El hecho de no declarar un nombre de rubrica permite protegerse contra cuestiones "indiscretas". En efecto, en este caso no puede aparecer en una cuesti√≥n.</p>
            <h4>Operadores</h4>
            <table>
              <thead>
                <tr>
                  <th>Operador</th>
                  <th>Significado</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>=</code></td>
                  <td>Igual a</td>
                </tr>
                <tr>
                  <td><code>&lt;&gt;</code></td>
                  <td>Diferente de</td>
                </tr>
                <tr>
                  <td><code>&lt;</code></td>
                  <td>Inferior a</td>
                </tr>
                <tr>
                  <td><code>&lt;=</code></td>
                  <td>Inferior o igual a</td>
                </tr>
                <tr>
                  <td><code>&gt;</code></td>
                  <td>Superior a</td>
                </tr>
                <tr>
                  <td><code>&gt;=</code></td>
                  <td>Superior o igual a</td>
                </tr>
                <tr>
                  <td><code>(-,-)</code></td>
                  <td>Comprendido entre dos valores, bornes incluidos</td>
                </tr>
              </tbody>
            </table>

            <h4>Valores</h4>
            <p>Los VALORES pueden estar puestos entre simples comillas <code>'PARIS'</code> <code>'7,75'</code></p>
            <p>Dos comillas simples consecutivas son equivalentes a una comilla simple.</p>
            <h4>Caracteres de Sustituci√≥n</h4>
            <p>Si la rubrica es una cadena de caracteres, se pueden usar los caracteres de SUSTITUCI√ìN para el valor de esta rubrica:</p>
            <table>
              <thead>
                <tr>
                  <th>Car√°cter</th>
                  <th>Significado</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>*</code></td>
                  <td>Reemplaza 0 o N car√°cter(es) cualquiera(s)</td>
                </tr>
                <tr>
                  <td><code>#</code></td>
                  <td>Reemplaza 0 o 1 car√°cter cualquiera</td>
                </tr>
                <tr>
                  <td><code>!</code></td>
                  <td>Reemplaza 1 car√°cter cualquiera</td>
                </tr>
              </tbody>
            </table>

            <p>Si la rubrica no es de tipo cadena el uso de caracteres de sustituci√≥n no tiene sentido. En este caso es el valor ASCII del car√°cter de sustituci√≥n el usado.</p>
            <h4>Cuestiones con Varios Criterios</h4>
            <p>Si una CUESTI√ìN est√° compuesto por varios criterios:</p>
            <ul>
              <li>El multicriterio no tiene en cuenta los registros que responde "S√ç" en todos los criterios</li>
              <li>Para una interrogaci√≥n r√°pida (sin la opci√≥n (S)): s√≥lo los nombres de las rubricas declaradas en un mismo enlace pueden aparecer en una misma cuesti√≥n, y adem√°s en el orden en que fueron declaradas en el enlace si la opci√≥n (A), todas las combinaciones, no est√° activa</li>
              <li>Si existe un enlace para responder a la cuesti√≥n, las respuestas se dar√°n en el orden del enlace</li>
              <li>Si no existe ning√∫n enlace para responder a la cuesti√≥n, y la opci√≥n (S) est√° elegida, las respuestas se dar√°n en el orden de las claves del fichero SI</li>
              </ul>

            <h4>Ejemplos de Cuesti√≥n</h4>
            <pre><code>DCL  Q$=60

ASK= 1,I=9900:TABV(1),"Cuesti√≥n"=Q</code></pre>

            <p>O bien:</p>
            <pre><code>Q= "PROV=PEPITO"
; Pide todos los registros cuyo proveedor es PEPITO

Q= "PROV=P*,PRECIO &gt; 100"
; Pide todos los registros cuyo nombre del proveedor comienza por
; una P y cuyo precio es superior a 100.

Q= "PROV &lt;&gt; "
; Pide todos los proveedores cuyo nombre no es blanco, y por orden alfab√©tico.

Q= "MINI(10,50)"
; Pide todos los registros cuyo stock m√≠nimo est√° comprendido entre 10 y 50.</code></pre>

            <p>Cuesti√≥n con variables:</p>
            <pre><code>Cuesti√≥n: A=N,B &gt; X,C (M1,M2)</code></pre>

            <p>Da todos los registros cuyo:</p>
            <ul>
              <li>Valor de la rubrica A es igual a N y</li>
              <li>El valor de la rubrica B es superior a X y</li>
              <li>El valor de la rubrica C est√° entre M1 y M2</li>
              </ul>

            <p>A, B y C son variables de tipo cadena de caracteres, que contienen los nombres de las rubricas.</p>
            <p>N, X, M1 y M2 son variables del tipo correspondiente a las rubricas cuyos nombres est√°n respectivamente en A, B y C.</p>
            <pre><code>ej : COUNT=1, A=N,B&gt;X,C(M1,M2) : X
     COUNT=1, Q : X</code></pre>

            <hr />

            <h3>COUNT= - Contar las Respuestas</h3>

            <h4>Definici√≥n</h4>
            <p>Esta orden permite contar los registros del fichero que responden "S√ç" a la cuesti√≥n puesta (en el COUNT=), por defecto de CUESTI√ìN el sistema cuenta los registros S.I.</p>
            <h4>Opciones</h4>
            <table>
              <thead>
                <tr>
                  <th>Opci√≥n</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>(U)</code></td>
                  <td>√önica. Permite no contar los registros cuyos valores del enlace usado son diferentes los unos de los otros, esto para cualquiera que sean las rubricas realmente puestas en la cuesti√≥n.</td>
                </tr>
                <tr>
                  <td><code>(S)</code></td>
                  <td>Secuencial. Permite contar los registros usando el fichero S.I. si no existe enlace para responder a la cuesti√≥n, los accesos son ahora m√°s lentos.</td>
                </tr>
              </tbody>
            </table>

            <p>Estas opciones (U) o (S) pueden estar puestas en una variable. √âsta se pone entre dos niveles de par√©ntesis. Contendr√° o bien el car√°cter U o bien el S o bien un blanco que significar√° que ninguna de las opciones es elegida.</p>
            <h4>Sintaxis</h4>
            <pre><code>               [ CUESTI√ìN                ]
COUNT=Nlog,    ["CUESTI√ìN", [ ((ZONA)) ] ] : [ Etiqu,E, ] X
                            [  ( U  )  ]
                            [  ( S  )  ]</code></pre>

            <ul>
              <li><code>X</code> es una variable num√©rica corta o larga que recibir√° el n√∫mero de respuestas</li>
              <li>Por defecto de CUESTI√ìN: Contar los registros S.I.</li>
              </ul>

            <h4>Ejemplo</h4>
            <p>Contar y editar el n√∫mero de registros que responden "S√ç" a una cuesti√≥n introducida por teclado, si hay enlace como si no existe:</p>
            <pre><code>DCL      Q$=60        ; Variable para introducir la cuesti√≥n
DCL      Q1           ; N√∫mero de respuestas COUNT
 .
ASK=1,I=9999 : TABV(1),"Cuesti√≥n:" = Q      ; CAN=10 por ejemplo.
COUNT=1, Q  , (S) : 9000,E  , Q1            ; incluso si no hay enlaces
print=1:tabv(1),"Respuesta :",(N4Z), Q1, tabv(1)</code></pre>

            <hr />

            <h3>POSIT= y POSIT.D= - Posicionamiento</h3>

            <h4>Definici√≥n</h4>
            <ul>
              <li><code>POSIT=</code> Posiciona el puntero de lectura delante (para hacer DOWN...)</li>
              <li><code>POSIT.D=</code> Posiciona el puntero de lectura detr√°s (para hacer UP...)</li>
              </ul>

            <p>Estas instrucciones permiten posicionar el puntero de lectura antes del primer (o detr√°s del √∫ltimo) registro que responde "S√ç" a la cuesti√≥n pedida (en el POSIT= o el POSIT.D=).</p>
            <h4>Opciones</h4>
            <table>
              <thead>
                <tr>
                  <th>Opci√≥n</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>(U)</code></td>
                  <td>√önica. En los DOWN y UP el sistema s√≥lo leer√° los registros cuyos valores del enlace usado son diferentes los unos de los otros, incluso si este enlace contiene m√°s rubricas que las que hay en la cuesti√≥n puesta.</td>
                </tr>
                <tr>
                  <td><code>(S)</code></td>
                  <td>Secuencial. En los DOWN y UP el sistema leer√° el fichero S.I. en secuencial, si no hay enlaces que permitan responder a la cuesti√≥n. Los accesos ser√°n m√°s lentos.</td>
                </tr>
              </tbody>
            </table>

            <h4>Resultado</h4>
            <p>El sistema da en una variable de tipo num√©rico:</p>
            <ul>
              <li>Bien 0 (cero), si ning√∫n registro responde a la cuesti√≥n</li>
              <li>Bien cualquier n√∫mero si hay al menos un registro que responda "S√ç" a la cuesti√≥n</li>
              </ul>

            <p>(Este n√∫mero indica el n√∫mero de registros que responden "S√ç" al primer acceso l√≥gico del multi-criterio, es inferior o igual al n√∫mero dado por COUNT=).</p>
            <p>Es obligatorio ejecutar una de las dos instrucciones antes de una lectura por DOWN o UP, pues si no, el sistema leer√° el fichero S.I.</p>
            <p>POSIT= es el equivalente en M.C. a un OPEN= para una lectura secuencial en S.I. (Secuencial Indexado).</p>
            <h4>Sintaxis</h4>
            <pre><code>POSIT=   Nlog, "CUESTI√ìN" [, ((ZONA)) ] : [ Etiqu,E, ]  X
POSIT.D=         CUESTI√ìN [,  ( U  )  ]
                          [,  ( S  )  ]</code></pre>

            <h4>Ejemplo</h4>
            <p>Posicionarse antes del primer registro que responde "S√ç" a la cuesti√≥n. La opci√≥n U, un registro con valor de enlace distinto se pone en una variable cadena:</p>
            <pre><code>     DCL Q$=60              ; Variable para introducir la cuesti√≥n
     DCL Q2                 ; N√∫mero de respuestas para POSIT=
     DCL ZONA$=1            ; para poner U S o blanco
      .
      .
100  ASK=1,I=9999 : tabv(1), "Cuesti√≥n:" = Q        ; La cuesti√≥n en Q
     ZONA="U"                                       ; opci√≥n √önica
     POSIT=1 , Q  , ((ZONA)) :9000,E  , Q2
     IF Q2=0 GOTO 100                               ; No hay respuesta
     .
     .
200  DOWN=1: 9000,ER, C1,41                 ; leer la 1a. respuesta
     print=1:C1,tabv(1)                     ; edita
     goto 200                               ; leer el siguiente</code></pre>

            <hr />

            <h3>Lectura Secuencial - DOWN= y UP=</h3>

            <h4>Posicionamiento Previo</h4>
            <p>Antes de la 1a orden de lectura secuencial hay que posicionar el puntero de lectura, indicando el (o los) criterio(s) elegido(s) en la cuesti√≥n:</p>
            <ul>
              <li>Con <code>POSIT=</code> para hacer DOWN...</li>
              <li>Con <code>POSIT.D=</code> para hacer UP...</li>
              </ul>

            <p>Si no se ejecuta el POSIT... la lectura se har√° autom√°ticamente en S.I. en el orden de las claves.</p>
            <h4>√ìrdenes Disponibles</h4>
            <p>El m√©todo de acceso multicriterio dispone de las mismas √≥rdenes y sintaxis que el m√©todo de acceso secuencial indexado para leer secuencialmente:</p>
            <pre><code>DOWN=    ,    DOWN.M=    ,    DOWN.L=    ,     DOWN.ML=
  UP=    ,      UP.M=    ,      UP.L=    ,       UP.ML=</code></pre>

            <p>En acceso multi-criterio, el sistema s√≥lo da los registros que responden "S√ç" a la cuesti√≥n (y cuyo √≠ndice se ha seleccionado).</p>
            <p>El orden de lectura secuencial en M.C. es el orden del valor del enlace utilizado, salvo que la opci√≥n S est√© seleccionada, porque entonces el orden es el de las claves (S.I.), si no hay enlace para responder a la cuesti√≥n.</p>
            <p>Si la opci√≥n U, √∫nica ha sido seleccionada, el sistema s√≥lo da aquellos registros cuyo valor de enlace sea diferentes unos de los otros.</p>
            <p>Por ejemplo: Una cuesti√≥n, sin opci√≥n, en enlace "PROV" da los proveedores seleccionados en el orden de nombres de proveedores.</p>
            <p>Cuando no hay respuestas a la cuesti√≥n, las √≥rdenes DOWN(...) y UP(...) reenv√≠an el c√≥digo de error 96 (fin de respuestas) si un POSIT ha sido ejecutado, si no, se retorna el c√≥digo de error de S.I.</p>
            <hr />

            <h3>DOWN= y UP= - Lectura de Clave, Index y Datos</h3>

            <h4>DOWN=</h4>
            <pre><code>DOWN=Nlog [ ,Index ] : [ Etiqu,E, ]  C1  [, L ]</code></pre>

            <p>Leer la clave siguiente perteneciente a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y respondiendo "S√ç" a la cuesti√≥n, esto si no hay opciones.</p>
            <p>Luego pone a partir de la variable C1: la clave, el √≠ndice y los datos del registro encontrado.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total a transferir.</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>DOWN= 1,2:C1,41  ; leer el registro siguiente del subnivel 2 (por ejemplo
                   los registros cuya cantidad es inferior a 100), que
                   responde "S√ç" a la cuesti√≥n pedida, si no hay opci√≥n.</code></pre>

            <h4>UP=</h4>
            <pre><code>UP=Nlog [ ,Index ] : [ Etiqu,E, ]   C1  [, L ]</code></pre>

            <p>Leer la clave precedente perteneciente a la uni√≥n de subniveles definido por el valor del √≠ndice (Index), y responde "S√ç" a la cuesti√≥n, si no hay opci√≥n.</p>
            <p>Luego pone a partir de la variable C1: La clave, el √≠ndice y los datos del registro le√≠do.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total a transferir.</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>UP= 1 , /FF  : C1 , 41      ; leer el registro anterior de cualquier sub-
                              nivel y que respondan "S√ç" a la cuesti√≥n
                              pedida, por defecto de opci√≥n.</code></pre>

            <hr />

            <h3>DOWN.L= y UP.L= - Lectura con Tama√±o de Datos</h3>

            <h4>DOWN.L=</h4>
            <pre><code>DOWN.L=Nlog [, Index ] : [ Etiqu,E, ]  L1  [, L ]</code></pre>

            <p>Leer la clave siguiente que pertenece a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y respondiendo "S√ç" a la cuesti√≥n.</p>
            <p>Luego pone a partir de la variable L1: El tama√±o de datos (%), la clave, el √≠ndice, y los datos del registro.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total m√°ximo a transferir.</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>DOWN.L= 1,2:L1,43  ; leer el registro siguiente de subnivel 2 (por ejemplo
                     todos cuya cantidad es inferior a 100), responden "S√ç"
                     a la cuesti√≥n propuesta, por defecto de opci√≥n. Los 2
                     primeros octetos contienen la longitud real de los datos</code></pre>

            <h4>UP.L=</h4>
            <pre><code>UP.L=Nlog [, Index ] : [ Etiqu,E, ]  L1  [, L ]</code></pre>

            <p>Leer la clave anterior perteneciente a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y respondiendo "S√ç" a la cuesti√≥n.</p>
            <p>Luego pone a partir de la variable L1: El tama√±o de los datos (%), la clave, el √≠ndice y los datos del registro.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total m√°ximo a transferir.</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>UP.L= 1,2:L1,43  ; leer el registro anterior de subnivel 2, que responde
                   "S√ç" a la cuesti√≥n propuesta.
                   Los 2 primeros octetos contienen el tama√±o real de datos</code></pre>

            <hr />

            <h3>DOWN.M= y UP.M= - Lectura para Modificaci√≥n</h3>

            <h4>DOWN.M=</h4>
            <pre><code>DOWN.M=Nlog [, Index ] : [ Etiqu,E, ]   C1  [, L ]</code></pre>

            <p>Leer la clave siguiente perteneciente a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y que respondan "S√ç" a la cuesti√≥n propuesta, esto por defecto de opciones.</p>
            <p>Luego pone a partir de la variable C1: la clave, el √≠ndice y los datos del registro le√≠do.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total a transferir.</p>
            <p><b>La clave se bloquea para modificaci√≥n</b> (ver SEARCH.M=...)</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>DOWN.M=1,2 : C1,41 ; El registro est√° bloqueado</code></pre>

            <h4>UP.M=</h4>
            <pre><code>UP.M=Nlog [, Index ] : [ Etiqu,E, ]   C1  [, L ]</code></pre>

            <p>Leer la clave anterior perteneciente a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y que responden "S√ç" a la cuesti√≥n.</p>
            <p>Luego pone a partir de la variable C1: la clave, el √≠ndice y los datos del registro.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total a transferir.</p>
            <p><b>La clave es bloqueada para modificaci√≥n</b> (ver SEARCH.M=...)</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>UP.M=1 : C1,41 ; leer el registro anterior. El registro es bloqueado.</code></pre>

            <hr />

            <h3>DOWN.ML= y UP.ML= - Lectura con Tama√±o para Modificaci√≥n</h3>

            <h4>DOWN.ML=</h4>
            <pre><code>DOWN.ML=Nlog [, Index ] : [ Etiqu,E, ]   L1   [, L ]</code></pre>

            <p>Leer la clave siguiente perteneciente a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y que responde "S√ç" a la cuesti√≥n.</p>
            <p>Luego pone a partir de la variable L1: el tama√±o de datos (%), la clave, el √≠ndice y los datos del registro.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total m√°ximo a transferir.</p>
            <p><b>La clave est√° bloqueada para modificaci√≥n</b> (ver SEARCH.M=...)</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>DOWN.ML=1 : L1,43   ; Leer el registro siguiente de subnivel 1, bloquear
                      el registro. Los 2 primeros octetos contienen el
                      tama√±o de los datos.</code></pre>

            <h4>UP.ML=</h4>
            <pre><code>UP.ML=Nlog [, Index ] : [ Etiqu,E, ]   L1  [, L ]</code></pre>

            <p>Leer la clave anterior perteneciente a la reuni√≥n de subniveles definidos por el valor del √≠ndice (Index), y que responden "S√ç" a la cuesti√≥n.</p>
            <p>Luego pone a partir de la variable L1: el tama√±o de datos (%), la clave, el √≠ndice y los datos del registro.</p>
            <p>L da el n√∫mero de octetos (el tama√±o) total m√°ximo a transferir.</p>
            <p><b>La clave est√° bloqueada para modificaci√≥n</b> (ver SEARCH.M=...).</p>
            <p><b>Ejemplo:</b></p>
            <pre><code>UP.ML= 1 : L1,43</code></pre>

            <hr />

            <h3>Ejemplo Completo de Lectura M.C.</h3>

            <p>Editar los nombres de proveedores en orden alfab√©tico si hay un enlace "PROV":</p>
            <pre><code>100   POSIT= 1,"PROV&lt;&gt; " : Q1(2)    ; Posiciona antes del 1er.registro

      IF Q1(2)= 0  GOTO  8000       ; no hay respuesta

200   DOWN=1 : 300, E , C1,41       ; leer el siguiente

      PRINT= 1 : "Nombre del Proveedor : ",F1 ,tabv(1)       ; editar

      GOTO 200                      ; continuar

300   IF  E  &lt;&gt; 96  GOTO  9000      ; Error general

8000  Print=1 : "Fin de Respuestas", Tabv (1)

      GOTO 9999

9000  Print=1 : "Error.:",E
      pause " cr "                  ; para leer el error
9999  STOP</code></pre>

            <hr />

            <h3>STAT= - Informaciones de Estado</h3>

            <h4>Definici√≥n</h4>
            <p>Estas informaciones de Estado de tipo SISTEMA, HIST√ìRICO y de CONTADORES son referentes a la gesti√≥n y la evoluci√≥n de los ficheros. Pueden leerse por la orden STAT=</p>
            <h4>Sintaxis</h4>
            <pre><code>STAT=Nlog : [ Etiqu,E , ] Var [, L ]</code></pre>

            <table>
              <thead>
                <tr>
                  <th>Par√°metro</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>Nlog</code></td>
                  <td>N√∫mero l√≥gico de 1 a 32</td>
                </tr>
                <tr>
                  <td><code>Var</code></td>
                  <td>Zona de recepci√≥n de informaciones estructuradas</td>
                </tr>
                <tr>
                  <td><code>L</code></td>
                  <td>Tama√±o de la zona de recepci√≥n, debe ser de 23 octetos</td>
                </tr>
              </tbody>
            </table>

            <h4>Estructura de Datos Retornados</h4>
            <table>
              <thead>
                <tr>
                  <th>Tipo</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>#</td>
                  <td>N√∫mero de octetos transmitidos por el multi-criterio</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>N√∫mero de versi√≥n del multi-criterio que cre√≥ el fichero</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>A√±o de creaci√≥n del fichero</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>Mes de creaci√≥n del fichero</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>D√≠a de creaci√≥n del fichero</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>A√±o de la √∫ltima transacci√≥n (del √∫ltimo cierre)</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>Mes del √∫ltimo cierre</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>D√≠a del √∫ltimo cierre</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>Hora del √∫ltimo cierre</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>Minuto del √∫ltimo cierre</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>Reservado</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>N√∫mero de registros en el fichero de datos</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>N√∫mero de rubricas declaradas y creadas</td>
                </tr>
                <tr>
                  <td>#</td>
                  <td>N√∫mero de enlaces declarados y creados</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>N√∫mero de interrogaciones (Count + Posit + Search + Stat)</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>N√∫mero de puestas al d√≠a (insert + Delete + Modif)</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>N√∫mero de insert en diferido. Si este valor es diferente de cero es necesario hacer un CLINK antes de interrogar al fichero.</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo Completo</h4>
            <pre><code>program "stat"
dcl NB#(2)              ; (1) No.octetos
                        ; (2) N√∫mero de versi√≥n en la creaci√≥n.
dcl CREEAN%             ;     A√±o de creaci√≥n
dcl CREEMJ#(2)          ; (1) Mes de creaci√≥n
                        ; (2) D√≠a de creaci√≥n
dcl TRAAN%              ;     A√±o √∫ltimo cierre
dcl TRAMJ#(5)           ; (1) Mes √∫ltimo cierre
                        ; (2) D√≠a √∫ltimo cierre
                        ; (3) Hora √∫ltimo cierre
                        ; (4) Minuto √∫ltimo cierre
                        ; (5) reservado
dcl NBART%              ;     N√∫mero de registros
dcl NBDCL#(2)           ; (1) N√∫mero de rubricas creadas
                        ; (2) N√∫mero de enlaces creados
dcl NBACCES%(3)         ; (1) No.interrog.: Count, Posit, Search, Stat
                        ; (2) No.puestas al d√≠a: Insert, Modif, Delete
                        ; (3) No. Insert en diferido

dcl NB1#(2)             ; para conversi√≥n del N√∫mero de versi√≥n
dcl ZONA$=256

segment 0

assign=1,"FMC",MC:ZONA
STAT=1:NB(1),23

NB1(1)=NB(2)/16
NB1(2)=mod( NB(2) , 16 )

print=1:"Fichero creado el  : ",(NZ,E),CREEMJ(2),"/",CREEMJ(1),"/",
        (N3Z),CREEAN,tabv(1)
print=1:"por un M.C. N√∫mero : ",(NZ,U),NB1(1),".",NB1(2),tabv(1)
print=1:"Cerrado el         : ",(NZ,E),TRAMJ(2),"/",TRAMJ(1),"/",
        (N3Z,E),TRAAN,"a las",(NZ,E)TRAMJ(3)," h.  ",TRAMJ(4)," Mn.",
        tabv(1)
print=1:"N√∫mero de enlaces  : ",(NZ ),NBDCL(2),tabv(1)
print=1:"N√∫mero de rubricas : ",(NZ ),NBDCL(1),tabv(1)
print=1:"N√∫mero de registros: ",(N3Z),NBART   ,tabv(1)
print=1:"No.de Interrogaci√≥n: ",(N3Z),NBACCES(1),tabv(1)
print=1:"No.de puestas a d√≠a: ",(N3Z),NBACCES(2 ),tabv(1)
print=1:"No.Insert diferidos: ",(N3Z),NBACCES(3 ),tabv(1)
stop
eseg 0
end</code></pre>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <h2>Anexo</h2>

            <h3>Contenido del Anexo</h3>

            <ul>
              <li>Declaraci√≥n de un art√≠culo S.I. o M.C.</li>
              <li>Tiempos de acceso S.I.</li>
              <li>Ejemplo de programa Multi-Criterio</li>
              <li>C√°lculo de espacio en disco</li>
              <li>Ocupaci√≥n de espacio memoria en B.A.L.</li>
              <li>N√∫meros l√≥gicos</li>
              <li>Estructura de un fichero traducido -T</li>
              <li>Estructura de un cat√°logo de PROLOGUE</li>
              <li>Esquema de un cable TELE</li>
              <li>Los c√≥digos ASCII</li>
              <li>Los c√≥digos PROLOGUE</li>
              <li>C√≥digos de respuesta (errores)</li>
              <li>Palabras Reservadas</li>
              <li>Tabla de INDEX</li>
              </ul>

            <hr />

            <h3>Declaraci√≥n de un Art√≠culo S.I. o M.C.</h3>

            <h4>Estructura General del Registro</h4>
            <pre><code>Nombre del Fichero :

Nombre de Clave :          Tipo de Clave  :      Tama√±o de la Clave :

Nombre 1er.Dato :          Tama√±o  ( total m√°ximo ) de los DATOS    :

:-------------------------------------------------------------------------:
!   C√≥d.   ! Tama√±o le√≠do !     CLAVE     ! INDEX !       DATOS           !
! Respuesta!   de Datos   ! 2 a 51 oct. SI! 1 oct ! 0 a 32767 oct. S.I.   !
! 2 oct. % !  2 octetos % ! 2 a 40 oct. MC!   #   ! 0 a  2700 oct. M.C.   !
`-------------------------------------------------------------------------'
           ^              ^               ^       ^                       l
           l              l               l       l   INSERT=             l
           l              l               l       l   SEARCH=             l
           l              l               l       l   MODIF=              l
           l              l               l       `----------------------&gt;l
           l              l               l   SEARCH.M=                   l
           l              l               `------------------------------&gt;l
           l              l   DOWN=                                       l
           l              l   UP=                                         l
           l              l   DOMN.M=                                     l
           l              l   UP.M=                                       l
           l              `----------------------------------------------&gt;l
           l    DOWN.L=                                                   l
           l    UP.L=                                                     l
           l    DOWN.ML=                                                  l
           l    UP.ML=                                                    l
           `-------------------------------------------------------------&gt;l

           :--------------------------------------------------------------:
           !  Tama√±o le√≠do  !  INDEX  !          DATOS                    !
           !    de Datos    !  1 oct  !   0 a 32767 octetos  S.I.         !
           !   2 octetos %  !    #    !   0 a  2700 octetos  M.C.         !
           `--------------------------------------------------------------'
           ^                                                              l
           l    SEARCH.ML=                                                l
           `-------------------------------------------------------------&gt;l

                     :----------------------------------------------------:
                     !  Tama√±o le√≠do  !          DATOS                    !
                     !    de Datos    !   0 a 32767 octetos  S.I.         !
                     !   2 octetos %  !   0 a  2700 octetos  M.C.         !
                     `----------------------------------------------------'
                     ^                                                    l
                     l    SEARCH.L=                                       l
                     `---------------------------------------------------&gt;l</code></pre>

            <h4>Resumen de √ìrdenes y Zonas Transferidas</h4>
            <table>
              <thead>
                <tr>
                  <th>Orden</th>
                  <th>Zona transferida</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>INSERT=</code>, <code>SEARCH=</code>, <code>MODIF=</code></td>
                  <td>INDEX + DATOS</td>
                </tr>
                <tr>
                  <td><code>SEARCH.M=</code></td>
                  <td>CLAVE + INDEX + DATOS</td>
                </tr>
                <tr>
                  <td><code>DOWN=</code>, <code>UP=</code>, <code>DOWN.M=</code>, <code>UP.M=</code></td>
                  <td>CLAVE + INDEX + DATOS</td>
                </tr>
                <tr>
                  <td><code>DOWN.L=</code>, <code>UP.L=</code>, <code>DOWN.ML=</code>, <code>UP.ML=</code></td>
                  <td>Tama√±o + CLAVE + INDEX + DATOS</td>
                </tr>
                <tr>
                  <td><code>SEARCH.ML=</code></td>
                  <td>Tama√±o + INDEX + DATOS</td>
                </tr>
                <tr>
                  <td><code>SEARCH.L=</code></td>
                  <td>Tama√±o + DATOS</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejemplo de Declaraci√≥n</h4>
            <p>Nombre del Fichero: CLIENTE</p>
            <ul>
              <li>Nombre Clave: C1</li>
              <li>Tipo de Clave: LK</li>
              <li>Longitud de Clave: 10</li>
              <li>Nombre 1er.Dato: D1</li>
              <li>Tama√±o total m√°ximo de DATOS: 20</li>
              </ul>

            <pre><code>:-------------------------------------------------------------------------:
!   C√≥d.   ! Tama√±o le√≠do !     CLAVE     ! INDEX !       DATOS           !
! Respuesta!   de Datos   ! 2 a 51 oct. SI! 1 oct ! 0 a 32767 oct. S.I.   !
! 2 oct. % !  2 octetos % ! 2 a 40 oct. MC!   #   ! 0 a  2700 oct. M.C.   !
`-------------------------------------------------------------------------'
field=m
dcl E1%    ,    L1%       ,      C1$=10   , I1#   ,  D1=5 , D2% , D3$=13

           ^              ^               ^       ^                       l
           l              l               l       l  INSERT=1,C0,I0:D1,20 l
           l              l               l       l  SEARCH=1,C0,I0:D1,20 l
           l              l               l       l  MODIF= 1,C0,I0:D1,20 l
           l              l               l       `----------------------&gt;l
           l              l               l   SEARCH.M=1,C0,I0 : I1,21    l
           l              l               `------------------------------&gt;l
           l              l   DOWN=  1,I0 : C1,31                         l
           l              l   UP=    1,I0 : C1,31                         l
           l              l   DOMN.M=1,I0 : C1,31                         l
           l              l   UP.M=  1,I0 : C1,31                         l
           l              `----------------------------------------------&gt;l
           l    DOWN.L= 1,I0 : L1,33                                      l
           l    UP.L=   1,I0 : L1,33                                      l
           l    DOWN.ML=1,I0 : L1,33                                      l
           l    UP.ML=  1,I0 : L1,33                                      l
           `-------------------------------------------------------------&gt;l

           :--------------------------------------------------------------:
           !  Tama√±o le√≠do  !  INDEX  !           DATOS                   !
           !    de Datos    !  1 oct  !   0 a 32767 octetos  S.I.         !
           !   2 octetos %  !    #    !   0 a  2700 octetos  M.C.         !
           `--------------------------------------------------------------'
field=m,C1
dcl FILLER=8 , L2%
           ^                                                              l
           l    SEARCH.ML=1,C0,I0 : L2,23                                 l
           `-------------------------------------------------------------&gt;l

                     :----------------------------------------------------:
                     !  Tama√±o le√≠do  !           DATOS                   !
                     !    de Datos    !   0 a 32767 octetos  S.I.         !
                     !   2 octetos %  !   0 a  2700 octetos  M.C.         !
                     `----------------------------------------------------'
field=m,C1
dcl FILLER=9 , L3%
field=m              ^                                                    l
                     l    SEARCH.L=1,C0,I0 : L3,22                        l
                     `---------------------------------------------------&gt;l</code></pre>

            <hr />

            <h3>Tiempos de Acceso S.I.</h3>

            <p>Los tiempos de acceso en Secuencial Indexado dependen de:</p>
            <ul>
              <li>N√∫mero de niveles del grafo de claves</li>
              <li>Longitud de la clave</li>
              <li>N√∫mero de registros</li>
              <li>Tipo de disco utilizado</li>
              </ul>

            <hr />

            <h3>Ejemplo de Programa Multi-Criterio</h3>

            <pre><code>program "JMP-EX-MULTICRI" ; 25 / 06 / 1987
*                   ; Fichero TEXTO ,  MC  &gt;=  1.8c
*                   ; PLG 2.23    TR  EX  5.1f  PRECIO con signo
*                   ; Opci√≥n en lista , No insert diferidos en STAT
*
***    LAS VARIABLES DEL FICHERO STOCK ( CLEPRODUIT y FOURNISSEUR )
*
*      CLAVE $ CLEPRODUIT de 10     DATOS   QUANTITE de  27
*
dcl CLEPRODUIT$=10  ; la clave : Nombre del Producto
dcl INDXLU#         ; Index=1 todos ; =3 Si Stock M√≠nimo &gt; Cantidad
dcl QUANTITE%       ; Cantidad
dcl STOCKMINI%      ; Stock M√≠nimo
dcl PRIX            ; Precio
dcl FOURNISSEUR$    ; Proveedor
*
***         Las Variables Para el Multicriterio
*
dcl ZONE$=256       ; Zona Para  Assign=  En M.C.
*                   ; 20 Octetos por R√∫brica ( m√≠nimo )
*                   ; 20*4 = 80
*
dcl QUESTION$=60    ; Cuesti√≥n M.C.  o  Lista en S.I.
dcl OPT$=1          ; opci√≥n para COUNT= y POSIT= (S) (U) blanco
*
dcl NOMBRE(2)       ; (1) N√∫mero De Respuestas En COUNT=
*                   ; (2) N√∫mero De Respuestas En POSIT=
dcl NB1#(2)         ; para Conv en HEXA de N√∫mero de M.C.
*
*** Las Variables  Para Estad√≠sticas  en M.C.  &gt;= 1.4
*
dcl NB#(2)          ; (1) N√∫mero De Octetos
*                   ; (2) N√∫mero de versi√≥n M.C. a la Creaci√≥n
dcl CREEAN%         ;     A√±o   de Creaci√≥n del fichero
dcl CREEMJ#(2)      ; (1) Mes   de Creaci√≥n del fichero
*                   ; (2) D√≠a   de Creaci√≥n del fichero
dcl TRAAN%          ;     A√±o   √∫ltimo Cierre
dcl TRAMJ#(5)       ; (1) Mes   √∫ltimo Cierre
*                   ; (2) D√≠a   √∫ltimo Cierre
*                   ; (3) Hora  √∫ltimo Cierre
*                   ; (4) Minu. √∫ltimo Cierre
*                   ; (5) Reserva
dcl NBART%          ;     N√∫mero de art√≠culos
dcl NBDCL#(2)       ; (1) N√∫mero de R√∫bricas Creadas
*                   ; (2) N√∫mero de Enlaces  Creadas
dcl NBACCES%(3)     ; (1) No.Interno   :Count Posit Search Stat
*                   ; (2) No.Puestas al D√≠a    : Ins. Del. Modif
*                   ; (3) No.de inserciones en diferido.</code></pre>

            <h4>Variables para Fichero Fuente Relativo</h4>
            <pre><code>dcl FSSECT%         ; N√∫mero del sector a escribir
dcl FSTEX1$=256     ; Zona para una r√∫brica
dcl FSTEX2$=256     ; Zona para transferencia en fichero
dcl FSLONG%         ; Longitud + 1 de FSTEX2 antes de concatenaci√≥n</code></pre>

            <h4>Variables de Trabajo General</h4>
            <pre><code>dcl INDXCALCULE#    ; Index Par√°metro De Entrada : C√°lculo/ Entrada
*
dcl REPONSE%(4)     ; (1) Respuesta del Sistema de Ficheros
*                   ; (2) N√∫mero De L√≠nea
*                   ; (3) N√∫mero De Segmento
*                   ; (4) Respuesta Del subprograma de Di√°logo
dcl CHOIX#          ; Elecci√≥n
dcl SORTIE#         ; Elecci√≥n de la salida 1=Pantalla,2=Imp,3=Fich.Texto
dcl ACCORD$=1       ; ¬øEs correcto? ( S s  - N n )
dcl PERIPH#         ; 1 Pantalla   2 Impresora
dcl ZONEIMP$=134    ; Zona de Transferencia : velocidad m√°x. en S.O.R.
dcl IMP$=4          ; Nombre De La Impresora O Blanco Si es la Impl√≠cita
dcl IMP1#           ; = 0 Imp NO asignada ni reservada
*                   ; = 1 Imp Impl√≠cita reservada por el sistema
*                   ; = 2 Imp asignada por ASSIGN=
dcl LIGNELIBRE%     ; No. de l√≠neas Disponibles en la p√°gina
dcl MAXILIGNE%(2)   ; (1) M√°x. de L√≠neas en la Pantalla
*                   ; (2) M√°x. de L√≠neas en la Impresora
*                         Nlog=2 si IMP en ASSIGN=
*
dcl FICH$=16        ; Fichero  [Sup.] Nomfich [:Claves]
dcl ETOILE$=79      ; un ***** Para cabecera de listado
dcl POINT1$=30      ; un ..... Para Gu√≠a de Entrada
dcl BLANC$=79       ; a Blancos Para Borrar</code></pre>

            <h4>Segmento Principal</h4>
            <pre><code>segment 0
goto 100

*** ACCESO EN DBUG  DESTRUIR Y CREAR   ..Dbug : G 3(cr)
***         El fichero
***         Las R√∫bricas  ( KEY=  , CKEY=  )
***         Los Enlaces   ( LINK= , CLINK= )
*
1       gosub 9500                  ; Nombre FICHERO Y ASSIGN=1 en M.C.
        dfile=1:10,REPONSE(1)       ; En M.C.
10      gosub 9550                  ; Assign=1 en S.I.  para destruirlo
        dfile=1:20,REPONSE(1)       ; En S.I.
20      gosub 9500                  ; Assign=1  En  M.C. Para el resto
        cfile=1,D=27,LK=10          ; DATOS 27 Oct. CLAVE $ a Izda. 10 Oct.
*
        gosub 9600                  ; KEY=  Antes CKEY= ,COUNT=,POSIT[.d]=
        ckey=1                      ; Una Sola Vez ( en DF  y en TR  )
        link=1,"FOUR","QTE","PRIX"  ; LINK=  Una  Sola Vez
        clink=1                     ; En  TR  : Una Sola Vez
        *                           ; En  DF  : Despu√©s de Puestas al D√≠a
        *                           ;        Antes Interrog. Count,Posit[.]
        *
***         ENTRADA Principal Del Programa          ***
*
100
        gosub 9500          ; NOMBRE DEL FICHERO Y ASSIGN=1 en M.C.
        *
        gosub 9600          ; KEY  Necesario para Interrogar
*
        REPONSE(3)=0        ; N√∫mero del segmento para edici√≥n de error
        MAXILIGNE(1)=conf(1)        ; No. De L√≠neas Pantalla
        MAXILIGNE(2)=conf(3)        ; No. De L√≠neas Impresora
        ETOILE=gener(79,"*")        ; Asteriscos para Cabecera
        POINT1=gener(30,".")        ; Gu√≠a de Entrada
*
200
        print=1:clear,tab(20,1),"* * *    M e n u    * * *"
        print=1:tabv(3),tab(25),"1 ... Inserci√≥n"
        print=1:tabv(2),tab(25),"2 ... Modificaci√≥n"
        print=1:tabv(2),tab(25),"3 ... Destrucci√≥n"
        print=1:tabv(2),tab(25),"4 ... Listado en S.I."
        print=1:tabv(2),tab(25),"5 ... Interrogaci√≥n  en  M.C."
        print=1:tabv(2),tab(25),"6 ... Estado de M.C."
        print=1:tabv(2),tab(25),"7 ... Destruir y Crear el fichero ..."
        print=1:tabv(2),tab(25),"8 ... Fin de trabajo"
        mask 3                      ; Validar
        ask=1,I=9999:tabv(3),tab(20),"Elija Opci√≥n..",tab(47),(U),POINT1=
        tab(47),(Z),CHOIX
        of CHOIX goto 1000,2000,3000,4000,4000,6000,1,9999
        print=1:tab(50) ,"Error De Tecleo"
        wait 2
        goto 200</code></pre>

            <h4>Inserci√≥n</h4>
            <pre><code>*
***         Inserci√≥n
*
1000
        print=1:clear,tab(30),"Inserci√≥n"
        gosub 9000                  ; Inic. de datos
        gosub 7000                  ; Di√°logo De Entrada
        if REPONSE(4)&lt;&gt;0 goto 200   ; Retorno Men√∫
        REPONSE(2)=1000                     ; N√∫mero De L√≠nea
        insert=1,CLEPRODUIT,INDXCALCULE:1010,REPONSE(1),QUANTITE,27
1010    if REPONSE(1)=  0 goto 1020
        if REPONSE(1)&lt;&gt;81 goto 9900
        print=1:tab(50),"Art√≠culo en stock"
        wait 2
        print=1:tab(50),space(17)
1020    goto 1000</code></pre>

            <h4>Modificaci√≥n</h4>
            <pre><code>*
***         Modificaci√≥n
*
2000
        print=1:clear,tab(30),"Modificaci√≥n"
        gosub 7000                  ; Di√°logo De Entrada
        if REPONSE(4)&lt;&gt;0 goto 200   ; Retorno Men√∫
        REPONSE(2)=2000
        modif=1,CLEPRODUIT,INDXCALCULE:9900,REPONSE(1),QUANTITE,27
        goto 2000</code></pre>

            <h4>Supresi√≥n</h4>
            <pre><code>*
***         Supresi√≥n
*
3000
        print=1:clear,tab(30),"Supresi√≥n"
        gosub 7000                  ; Di√°logo De Entrada
        if REPONSE(4)&lt;&gt;0 goto 200   ; Retorno Men√∫
        REPONSE(2)=3000
        delete=1,CLEPRODUIT,/FF:9900,REPONSE(1) ; Suprime Todos los bits
*           index   : la clave, los datos y enlaces
*
3120    print=1:tabv(2),tab(20),"Supresi√≥n Efectuada"
        wait 2
        goto 3000</code></pre>

            <h4>Lista Secuencial S.I. o M.C.</h4>
            <pre><code>*
***         lista  Secuencial  S.I.  o M.C.
*
4000
        QUESTION=" "                        ; M.C. a Priori
        OPT=" "                             ; no opci√≥n a priori
4010    if CHOIX=5 goto 4050                ; M.C.

        QUESTION="En Secuencial S.I."       ; Para Cabecera Listado S.I.
        print=1:clear,tab(25),"Listado Secuencial en S.I."
        goto 4100

        print=1:clear,tab(25),"Listado Por Interrogaci√≥n En M.C."
*
***         Di√°logo
*
4100    gosub 7500                  ; di√°logo para listado
        if REPONSE(4)&lt;&gt;0 goto 200   ; Retorno Men√∫
*
***         Principio de Listado
***         ====================
*
        REPONSE(2)=4100
        if CHOIX=5 goto 4250        ; En M.C. Hacer POSIT.D=
*
***         Posicionar en Principio de Fichero si es S.I.
*
        open=1:9900,REPONSE(1)      ; OPEN=1  Principio de Fichero En S.I.
        goto 4300                   ; Cabecera
*
***         Posicionar en la 1a.Respuesta en M.C.
*
4250    posit=1,QUESTION, ((OPT)) :9900,REPONSE(1),NOMBRE(2)
*
4300    gosub 8000                  ; Cabecera
*
***         Art√≠culo Siguiente
***         ==================
*
4400    REPONSE(2)=4400
        down=1,INDXCALCULE:4800,REPONSE(1),CLEPRODUIT,38
        gosub 8100                  ; edita un art√≠culo
        op 4500                     ; Acceso Operador para Interrumpir
        goto 4400                   ; Art√≠culo Siguiente</code></pre>

            <h4>Acceso Operador en Curso de Edici√≥n</h4>
            <pre><code>*
*** Acceso Operador en curso de edici√≥n
*
4500    mask 3                      ; Validaci√≥n Obligatoria
        ask=1,I=4520:tab(20),"Retorno Di√°logo  S / N : "=(A),tab(45),ACCORD
        if ACCORD="S s N n " then 4510 else 4500
4510    if ACCORD="S s " goto 4520  ; libera imp, Retorno di√°logo
        print=1:tab(20),atb(21),tab(1) ; Borra y se queda en la misma l√≠nea
        goto 4400                   ; Contin√∫a el listado
4520    gosub 9750                  ; libera Imp, retorno di√°logo
        goto 4010</code></pre>

            <h4>Fin de Listado</h4>
            <pre><code>*
***         Fin de Listado
***         ==============
*
4800    if CHOIX=5 goto 4850        ; En M.C. 96=Fin de respuestas
*
        if REPONSE(1)= 48 goto 4900 ; Fin En S.I.
*       if REPONSE(1)= 96 goto 4400 ; para Bug M.C. despu√©s interrog.
        goto 9900
*
4850    if REPONSE(1)&lt;&gt;96 goto 9900 ; Fin En M.C.
*
*** edita mensaje de fin de fichero
*
4900    gosub 8200                  ; Edici√≥n fin del Cuadro
        print=1:tabv(1),tab(20),"Fin De Listado"
        if PERIPH=1 goto 4910
        print=PERIPH:tab(20),"Fin De Listado",tabv(1)
        gosub 9750                  ; Liberar La Impresora
4910    pause " Pulsar ENTER "
        goto 4010</code></pre>

            <h4>Estado de M.C.</h4>
            <pre><code>*
*** Estado de M.C.
*
6000
        print=1:clear,tab(25),"Edici√≥n De Estado"
        gosub 7500                  ; Di√°logo Pantalla/Impresora
        if REPONSE(4)&lt;&gt;0 goto 200   ; Retorno Men√∫
        REPONSE(2)=6000
        stat=1:9900,REPONSE(1),NB(1),23
*
***         Conv en pseudo-HEXA
*
        NB1(1)=NB(2)/16
        NB1(2)=mod(NB(2),16)
*
        print=PERIPH:clear,tab(20),"ESTADOS",(N2Z,E),tab(37),NB(1),
        " Octetos",tabv(3)
        print=PERIPH:tab(5),"El Fichero se cre√≥ el ...: ",(NZ,E),CREEMJ(2)
        ,"/",CREEMJ(1),"/",(N3Z),CREEAN,tabv(1)
        print=PERIPH:tab(5),"Por  un  M. C.   Versi√≥n : ",(NZ,U),NB1(1),
        ".",NB1(2),tabv(3)
        print=PERIPH:tab(5),"√öltima Actualizaci√≥n el..: ",(NZ,E),TRAMJ(2),
        "/",TRAMJ(1),"/",(N3Z,E),TRAAN,"   a ",(NZ,E),TRAMJ(3)," h.  ",
        TRAMJ(4)," Mn.",tabv(2)
        print=PERIPH:tab(5),"N√∫mero de Enlaces .......: ",(NZ,E),NBDCL(2),
        tabv(1)
        print=PERIPH:tab(5),"N√∫mero de R√∫bricas ......: ",(NZ,E),NBDCL(1),
        tabv(2)
        print=PERIPH:tab(5),"N√∫mero de Registros .....: ",(N4Z,E),NBART,
        "  Article(s)",tabv(2)
        print=PERIPH:tab(5),"N√∫mero de Interrogaciones: ",(N4Z,E),
        NBACCES(1),"  Count  + Posit  + Search + Stat",tabv(2)
        print=PERIPH:tab(5),"N√∫mero de Puestas al D√≠a : ",(N4Z,E),
        NBACCES(2),"  Insert + Delete + Modif",tabv(2)
*
        print=PERIPH:tab(5),"No.de Inserts en diferido: ",(N4Z,E),
        NBACCES(3),"  Crear los enlaces si &lt;&gt; 0",tabv(2)
*
        pause " Pulse ENTER "
        gosub 9750                  ; Libera la IMPresora
        goto  6000</code></pre>

            <h4>Di√°logo de Entrada (7000)</h4>
            <pre><code>7000
        CLEPRODUIT=" "                      ; La Clave Nombre Del Producto
        mask 35
7010
        print=1:tab(50,3),atb(21)   ; Borra Modif En Curso Si OP ...
        ask=1,I=7480,D=7013:tab( 7,3),"Producto....:",(UW9),tab(22),
        CLEPRODUIT,tab(35),POINT1=tab(35),CLEPRODUIT
7013    if CLEPRODUIT=" " goto 7010
        CLEPRODUIT=large(CLEPRODUIT)    ; Fuerza las may√∫sculas
        print=1:(UW9),tab(22),CLEPRODUIT,tab(35),space(10)
*
***         Verifica PRESENCIA o AUSENCIA
*
7020    REPONSE(2)=7020
        search.m=1,CLEPRODUIT:7030,REPONSE(1),INDXLU  ,28
7030    of CHOIX goto 7050          ; Verif.AUSENCIA para Insert=
*
***         Verif.  PRESENCIA para  Modif= y Delete=
*
        if REPONSE(1)= 0  goto 7100 ; Ok  Presencia para M√≠ mismo
        if REPONSE(1)&lt;&gt;74 goto 7035 ; BLOQUEADO   Por otro puesto
        print=1:tab(50,3),"Modificaci√≥n En Curso"
        wait 1                      ; Libera tiempo U.C. para otros
        op 7010                     ; Cuestiones sobre Productos
        goto 7020
*
*
7035    if REPONSE(1)&lt;&gt;78 goto 9900 ; Error
        print=1:tab(50,3),"Ausencia del Fichero"
        pause " Pulse ENTER "
        print=1:tab(50,3),space(29) ; Borra
        goto 7000
*
***         Verif. AUSENCIA para Insert=
*
7050    if REPONSE(1)=78  goto 7100 ; Ok  Ausente
        if REPONSE(1)=74  goto 7060 ; Presente y Bloqueado por otro pto.
        if REPONSE(1)&lt;&gt;0  goto 9900 ; Error No bloqueado por otro Puesto
*
*
***         Desbloquear
*
        gosub 9800                  ; Desbloquear Nlog=1
*
7060    gosub 9000                  ; ReInic.datos
        print=1:tab(50,3),"Ya en el Fichero"
        pause " Pulse ENTER "
        print=1:tab(50,3),space(29) ; Borrar
        goto 7000</code></pre>

            <h4>Di√°logo de Entrada - Continuaci√≥n (7100-7490)</h4>
            <pre><code>7100    print=1:tab(50,3),space(21) ; Borra Modif En Curso Si Modif
        ;  Terminado sobre el Otro Puesto
        if CHOIX&lt;&gt;3 goto 7200               ; NO  Delete=
*
*** Supresi√≥n
*
        PERIPH=1                    ; Edici√≥n pantalla
        print=1:tabv(2)
        gosub 8010                  ; Edici√≥n En cabecera
        gosub 8100                  ; Edici√≥n de un art√≠culo
        gosub 8200                  ; Edici√≥n Fin Del Cuadro
        gosub 7900                  ; De Acuerdo
        of REPONSE(4) goto 7480,7010        ; Esc. , Up
        goto 7490                   ; Fin Ok
*
*** Ense√±ar Art√≠culo
*
7200    print=1:   tab(7,6)   ,"Cantidad    :",(N3Z,U4)   ,tab(22),
        QUANTITE,tab(40),BLANC
        print=1:tabv(2),tab(7),"Stock M√≠nimo:",(N3Z,U4)   ,tab(22),
        STOCKMINI,tab(40),BLANC
        print=1:tabv(2),tab(7),"Precio      :",(-N3Z.N2,U8),tab(21),PRIX,
        tab(40),BLANC
        print=1:tabv(2),tab(7),"Proveedor   :",(UW14)     ,tab(22),
        FOURNISSEUR,tab(40),BLANC
*
*** Di√°logo de Entrada de DATOS
*
7210    ask=1,I=7480,U=7010,D=7213:(N3Z,U4),tab(22, 6),QUANTITE ,tab(40),
        POINT1=tab(40),QUANTITE
7213    print=1:(N3Z,U4),tab(22),QUANTITE,tab(40),BLANC
*
7220    ask=1,I=7480,U=7210,D=7223:(N3Z,U4),tab(22, 8),STOCKMINI ,tab(40),
        POINT1=tab(40),STOCKMINI
7223    print=1:(N3Z,U4),tab(22),STOCKMINI,tab(40),BLANC</code></pre>

            <h4>C√°lculo de Index y Entrada de Precio</h4>
            <pre><code>*
***         C√°lculo Index
*
        INDXCALCULE=1                       ; Presente   Index = 1 + ...
        if QUANTITE&gt;=STOCKMINI goto 7230
        INDXCALCULE=INDXCALCULE OR 2        ; Mini &gt; Qte Index = 2 + ...
*
7230    ask=1,I=7480,U=7220,D=7233:(-N3Z.N2,U8),tab(21,10),PRIX ,tab(40),
        POINT1=tab(40),PRIX

        *===============================*
        *                               *
        *   Hacer  FIX ( .. , N  )      *   El signo se autoriza para
        *                               *   testear las r√∫bricas num√©ricas
        *   en las r√∫bricas   B.C.D     *   largas de valores negativos.
        *                               *
        *===============================*

        PRIX=fix(PRIX,2)            ; Es una R√öbrica de Tipo B.C.D.


7233    print=1:(-N3Z.N2,U8),tab(21),PRIX,tab(40),BLANC
*
7240    ask=1,I=7480,U=7230,D=7243:(UW14),tab(22,12),FOURNISSEUR ,tab(40),
        POINT1=tab(40),FOURNISSEUR
7243    FOURNISSEUR=large(FOURNISSEUR)
        print=1:(UW14),tab(22),FOURNISSEUR,tab(40),BLANC
*
7300    gosub 7900                  ; De Acuerdo
        of REPONSE(4) goto 7480,7240; Esc  , Up
        goto 7490
*
***         Salida por Escape  o No de Acuerdo
*
7480    gosub 9800                  ; Desbloquea si No Acuerdo o  Esc
        REPONSE(4)=1                ; Escape
*
7490    return</code></pre>

            <h4>Di√°logo para Listado, Interrogaci√≥n, Estado (7500)</h4>
            <pre><code>*
***         Di√°logo para listado , Interrogaci√≥n , Estado
*
7500
        mask 35
        INDXCALCULE=1               ; A Priori Todo el fichero
        PERIPH=1
7510    SORTIE=1                    ; A Priori en la pantalla
        print=1:tab( 7, 6),"SALIDA :1 Pantalla ,2 Impresora         :"
        if choix=6 goto 7511
        print=1:tab(37),",3=F.Texto :"
7511    ask=1,I=7580,D=7513:(Z,U),tab(50),SORTIE,tab(58),POINT1=tab(58),
        SORTIE
7513    of SORTIE goto 7515,7515
        if CHOIX=6 goto 7510        ; No 3 en Estado
        if SORTIE=3 goto 7516       ; salida Fichero en S.I. o en M.C.
        goto 7510
7515    PERIPH=SORTIE
7516    print=1:(Z,U),tab(50),SORTIE,tab(58),BLANC
        print=1:(U45),tab(7,8),BLANC
*
7520    of SORTIE goto 7530,7521,7528

*
***         Elecci√≥n de la IMPresora
*
7521    ask=1,I=7580,U=7510,D=7522:tab( 7, 8),"Nombre de la Impresora O
        Blanco  :",(A2N,U3),tab(42),IMP,tab(48),POINT1=tab(48),IMP
7522    print=1:(A2N,U3),tab(42),IMP,tab(48),BLANC

        gosub 9700                  ; reserva IMP si es posible
        if REPONSE(4)&lt;&gt;0 goto 7521  ; error

        goto 7530
*
***     Salida Fichero texto
*
7528
        goto 7530</code></pre>

            <h4>Di√°logo para Listado - Continuaci√≥n (7530-7590)</h4>
            <pre><code>7530
        if CHOIX=6 goto 7570        ; Acuerdo si STAT
        ask=1,I=7580,U=7538,D=7533:tab(7,10),"1 Completo , 2 Stock M√≠nimo",
        tab(40),":",(Z,U),tab(42),INDXCALCULE,tab(48),POINT1=tab(48),
        INDXCALCULE
7533    of INDXCALCULE goto 7535,7535
        goto 7530
7535    print=1:(Z,U),tab(42),INDXCALCULE,tab(48),BLANC
        goto 7540
7538    of PERIPH goto 7510         ; Up a la Cuesti√≥n precedente Pantalla
        goto 7520                   ; Imp
        *
        ***         La Cuesti√≥n  En  M.C.
        *
7540    if CHOIX=4 goto 7570        ; De acuerdo si Lista S.I.
7541    print=1:tab(7,12),"Pregunta sobre : FOUR , QTE , PRIX , MINI"
        ask=1,I=7580,U=7530,D=7543:(UW59,U),tab(7,14),QUESTION,POINT1=
        tab(7),QUESTION
7543    if QUESTION=" " goto 7541
        print=1:(UW59,U),tab(7),QUESTION,space(1)
        *
7545    print=1:tab(7,16),"Opci√≥n   S U o blanco : "
        ask=1,I=7580,U=7530,D=7543:(U),tab(30,16),OPT,"."=tab(30),OPT
7547    OPT=large(OPT)
        if OPT="S U " goto 7548
7548    print=1:(U),tab(30),OPT,space(1)
        *
        *
        REPONSE(2)=7543             ; N√∫mero de Respuestas
        count=1,QUESTION, ((OPT)) :7550,REPONSE(1),NOMBRE(1)
        goto 7560
        *
7550    if REPONSE(1)&lt; 88 goto 9900
        if REPONSE(1)&lt;=91 goto 7555
        if REPONSE(1) =93 goto 7555
        if REPONSE(1)&lt; 97 goto 9900
        if REPONSE(1) &gt;99 goto 9900
7555    print=1:tab(7,18),"Cuesti√≥n Incorrecta ",REPONSE(1)
        pause " Pulse ENTER "
        print=1:tab(7,18),space(30)
        goto 7541
*
7560    print=1:tab(7,18),"N√∫mero de Respuestas : ",(N4Z),NOMBRE(1)
*
***         De acuerdo
*
7570    gosub 7900                  ; De acuerdo
        of REPONSE(4) goto 7580,7575; Esc , Up
        goto 7590                   ; Ok
7575    if CHOIX=4 goto 7520        ; Retorno si lista  S.I. : Completa
        if CHOIX=5 goto 7541        ; Retorno si Interr.M.C. : Cuesti√≥n
        if PERIPH=1 then 7510 else 7521 ; Retorno si Stat a Ecr/Imp o NOM
        ;                                    IMP
7580    REPONSE(4)=1                ; Esc En Di√°logo/Acuerdo, o NO
        gosub 9750                  ; Liberar La Imp.Si Abandono
7590    return</code></pre>

            <h4>Di√°logo Acuerdo (7900)</h4>
            <pre><code>*
***         Di√°logo Acuerdo
*
7900    mask 3                      ; Validar
        ACCORD=" "                  ; Respuesta Obligatoria
        ask=1,I=7980,U=7982:tab(20,20),"Acuerdo S/N :",(A,U),tab(40),
        POINT1=tab(40),ACCORD
        if ACCORD="S s N n " then 7910 else 7900
7910    if ACCORD="N n "     goto 7980
*
        REPONSE(4)=0                ; Ok
        goto 7990
*
7980    REPONSE(4)=1                ; Escape  O  Non
        goto 7990
*
7982    REPONSE(4)=2                ; Up
*
7990    mask 35                     ; M√°scara de entrada a priori
        return</code></pre>

            <h4>Edici√≥n Cabecera y Art√≠culos (8000-8200)</h4>
            <pre><code>8000
        if SORTIE&lt;3 goto 8001       ; No de fichero texto
        gosub 8500                  ; Inic.Fichero texto
        return
*
***         Edita En Cabecera de P√°gina
*
8001    print=PERIPH:clear,tab(10),"Listado Del Fichero ",QUESTION,tabv(2)
8010
        print=PERIPH:(U72),ETOILE,tabv(1); Una L√≠nea de asteriscos
        print=PERIPH:"*",tab(14),"!",tab(25),"!",tab(38),"!",tab(54),"!",
        tab(72),"*",tabv(1)
        print=PERIPH:"*",tab( 4),"Producto  !",tab(16),"Cantidad !",
        tab(27),"Stock Mini !",tab(40),"Precio Unitar.!",tab(58),
        "Proveedor     *",tabv(1)
        print=PERIPH:"*",tab(14),"!",tab(25),"!",tab(38),"!",tab(54),"!",
        tab(72),"*",tabv(1)
        print=PERIPH:(U72),ETOILE,tabv(1)
        print=PERIPH:"*",tab(14),"!",tab(25),"!",tab(38),"!",tab(54),"!",
        tab(72),"*",tabv(1)
        LIGNELIBRE=MAXILIGNE(PERIPH)-12     ; No. de l√≠neas a Imprimir
        return
*
***         Edita Un Art√≠culo de M√°s
*
8100
        if SORTIE&lt;3 goto 8101       ; No F. Texto
        gosub 8520                  ; un art√≠culo de m√°s
        return
8101    if LIGNELIBRE&lt;&gt;0 goto 8150  ; La P√°g. No est√° Llena
        if PERIPH&lt;&gt;1 goto 8110      ; No en la Pantalla
        pause " Pulse ENTER "
8110    gosub 8000                  ; Cabecera
*
8150    print=PERIPH:"*",tab(3),CLEPRODUIT," !"             ; Producto
        print=PERIPH:( N3Z,U),tab(18),QUANTITE ,tab(25),"!" ; Cantidad
        print=PERIPH:( N3Z,U),tab(30),STOCKMINI,tab(38),"!" ; Stock Mini
        print=PERIPH:(-N3Z.N2,U),tab(42),PRIX  ,tab(54),"!" ; Precio
        print=PERIPH:       tab(56),FOURNISSEUR,tab(72),"*" ; Proveedor
        print=PERIPH:tabv(1)
        LIGNELIBRE=LIGNELIBRE-1     ; Resta una l√≠nea
        return
*
***         Edici√≥n del fin de Cuadro
*
8200
        if SORTIE&lt;3 goto 8201       ; No  F. Texte
        gosub 8570                  ; Fin de Fichero texto
        return
8201    print=PERIPH:"*",tab(14),"!",tab(25),"!",tab(38),"!",tab(54),"!",
        tab(72),"*",tabv(1)
        print=PERIPH:(U72),ETOILE,tabv(1); Una L√≠nea de asteriscos
        return</code></pre>

            <h4>Fichero Texto Fuente para WS (8500-8570)</h4>
            <pre><code>*
***     FICHERO TEXTO FUENTE para WS
*
***     Crear el fichero relativo
***     Inic.n√∫mero de sector  = 0 ,  Zona a escribir a blancos
*
8500
        assign=4,"FSSTOCK-S",wr,ex
        dfile=4:8502,REPONSE(1)
8502    REPONSE(2)=8502
        cfile=4:9900,REPONSE(1)
        FSSECT=0                    ; N√∫mero de sector
        FSTEX2=" "                  ; Texto a escribir
        return
*
***     Escribir un ART√çCULO, las zonas entre comillas " " chr$/22
*
8520
        FSTEX1=chr$(/22)+left( CLEPRODUIT,len$(CLEPRODUIT) )+chr$(/22)+","
        gosub 8530                  ; Concatenar y escribir si lleno
        FSTEX1=chr$(/22)+conv(QUANTITE)+chr$(/22)+","
        gosub 8530                      ; concatenar
        FSTEX1=chr$(/22)+conv(STOCKMINI)+chr$(/22)+","
        gosub 8530
        FSTEX1=chr$(/22)+strn( roun( PRIX/100, 2) )+chr$(/22)+","
        gosub 8530
        FSTEX1=chr$(/22)+left( FOURNISSEUR , len$(FOURNISSEUR) )+chr$(/22)
        +chr$(/0D)+chr$(/0A)
        gosub 8530                  ; Concatenar y escribir en fichero
        return
*
***     Concatenaci√≥n articl. FSTEX1 --&gt; FSTEX2  y escribir si lleno
*
8530    FSLONG=len$( FSTEX2 ) + 1   ; 1er libre antes de inserci√≥n
        FSTEX2=includ( FSLONG , FSTEX1 )
        if FSLONG+len$( FSTEX1 ) &lt;= 256 goto 8540   ; zona no llena
*
***     Escribir un sector y fin concatenaci√≥n
*
        REPONSE(2)=8530
        write=4,/A0,FSSECT:9900,REPONSE(1),FSTEX2
        FSSECT=FSSECT+1
        FSTEX2=substr(FSTEX1,258-FSLONG,len$(FSTEX1))       ; Resto articl.
8540    return
*
***     Escribir fin de fichero
*
8570
        FSLONG=len$( FSTEX2 ) + 1
        FSTEX2=includ( FSLONG , chr$(/1A) )
        REPONSE(2)=8570
        write=4,/A0,FSSECT:9900,REPONSE(1),FSTEX2
        return</code></pre>

            <h4>Subrutinas de Servicio (9000-9600)</h4>
            <pre><code>*
***         Inic. de Datos
*
9000
        QUANTITE=0
        STOCKMINI=0
        PRIX=0
        FOURNISSEUR=" "
        return
*
*
***         NOMBRE DE FICHEROS Y ASSIGN=
*
9500
        FICH="FBLSTMC"
        REPONSE(2)=9500
        assign=1,FICH,WR,MC:9900,REPONSE(1),ZONE    ; en M.C. en General
        return
*
*
9550
        REPONSE(2)=9550
        assign=1,FICH,WR,SI                         ; en S.I. para Destruir
        return
*
***         KEY= Declarar las R√∫bricas
***                 En el orden de las DCL Para crearlas
*
9600
        KEY=1,"QTE" ,2 ,N           ; Num√©rica Corta
        KEY=1,"MINI",2 ,N           ; Num√©rica Corta
        KEY=1,"PRIX",8 ,B,2         ; B.C.D. ( Num. Larga ,2 decimales)
        *                           ; Hacer FIX(..,2)
        KEY=1,"FOUR",15             ; $ Cadena
        return</code></pre>

            <h4>Reservar Impresora (9700)</h4>
            <pre><code>9700
        *
        *** Reservar la imp IMP si es posible
        ***     salida : REPONSE(4) = 0 : Ok
        ***              REPONSE(4) = 1 : No  Ok Nombre de IMP desconocida
        ***                                   ...   o IMP ocupada
        ***
        ***              IMP1 = 0 No salida por Impresora
        ***              IMP1 = 1 Imp impl√≠cita
        ***              IMP1 = 2 Imp asignada
        *
        IMP1=0                      ; No impresora a priori
        IF PERIPH=1 goto 9745       ; No salida por IMP pero Ok

        IMP1=1                      ; IMP impl√≠cita
        IF IMP=" "  goto 9745       ; Ok

        ACCORD=SUBSTR(IMP,3,1)
        if ACCORD&lt;&gt;" " goto 9705
        IMP=includ(3,"0")           ; "IM0 "
9705    IMP=includ(4,".")           ; "IM0." Poner Un Punto

        assign=2,IMP,im,wr,ex:9725,REPONSE(1),ZONEIMP
        REPONSE(2)=9705
        open=2:9710,REPONSE(1)      ; La IMP est√° asignada y
        IMP1=2                      ;     reservada por programa
        goto 9745                   ; Ok

9710    REPONSE(2)=9710
        close=2                     ; Libera La Imp
        IMP1=0                      ; La IMP no est√° m√°s reservada
        if REPONSE(1)&lt;&gt;44 goto 9715 ; No Reservada
        print=1:tab(48),"YA RESERVADA"
        goto 9730                   ; Pausa Borra Mensaje

9715    if REPONSE(1) =40 goto 9720 ; IMP no tiene un nombre de IMP
        if REPONSE(1)&lt;&gt;56 goto 9725 ; Incorrecto, Error

9720    print=1:tab(48),"La Imp. no est√° declarada"
        goto 9730                   ; Pausa Borra Mensaje

9725    IMP1=0                      ; No IMP ni Impl√≠cita ni asignada
        print=1:tab(48),"Incorrecto,error  : ",REPONSE(1)

9730    pause " Pulse ENTER "
        print=1:tab(48,8),atb(21)   ; Borrar fin de l√≠nea
        REPONSE(4)=1                ; No Ok
        goto 9749

9745    REPONSE(4)=0                ; Ok

9749    return</code></pre>

            <h4>Liberar Impresora y Desbloquear (9750-9800)</h4>
            <pre><code>        *
        *** LIBERAR LA IMPRESORA
        ***     IMP1 = 0 : no est√° reservada
        ***     IMP1 = 1 : IMP impl√≠cita no asignada
        ***     IMP1 = 2 : IMP asignada y reservada
        *
9750
        if PERIPH=1 goto 9790       ; No salida de IMP
        of IMP1     goto 9760, 9770 ; Impl√≠cita, Asignada
        goto 9790                   ; no asignada

9760    REPONSE(2)=9760
        print=PERIPH:chr$(/1A)      ; Libera la IMP no Asignada
        goto 9790

9770    REPONSE(2)=9770
        close=PERIPH:9900,REPONSE(1); Libera la IMP Asignada

9790    IMP1=0                      ; No asigna
        return

*
***         Desbloquear Nlog=1
*
9800
        REPONSE(2)=9800
        open=1:9900,REPONSE(1)
        return</code></pre>

            <h4>Salida por Error General</h4>
            <pre><code>*
*** Salida por Error General
*
9900
        print=1:tab( 5,23),"Error  : " ,REPONSE(1),"  L√≠nea : ",REPONSE(2)
        ,"  Segmento: ",REPONSE(3)
        pause " Pulse ENTER "               ; para leer el error
9999
        stop
        eseg 0
        end</code></pre>

            <hr />

            <h3>C√°lculo de Espacio en Disco</h3>

            <h4>Funciones Utilizadas</h4>
            <ul>
              <li><b>E+(x)</b>: Da el entero m√°s peque√±o superior o igual a x.</li>
              <li><b>E-(x)</b>: Da el entero m√°s grande inferior o igual a x.</li>
              </ul>

            <h4>Conversiones</h4>
            <p>Cuando un c√°lculo se hace en octetos, hay que calcular el n√∫mero de sectores dividiendo el n√∫mero de octetos por 256, y tomando el entero m√°s peque√±o superior o igual al n√∫mero encontrado (funci√≥n E+(x)). Se obtiene el tama√±o en sectores.</p>
            <p>Cuando un c√°lculo se ha obtenido en sectores, hay que dividir el n√∫mero de sectores por el n√∫mero de sectores por gr√°nulo (LGR suele ser igual a 16), despu√©s se toma el entero m√°s peque√±o superior o igual al n√∫mero encontrado (funci√≥n E+(x)). Se obtiene el tama√±o en gr√°nulos.</p>
            <h4>Variables</h4>
            <ul>
              <li><b>No.</b> = N√∫mero de art√≠culos del fichero</li>
              <li><b>LDatos</b> = Longitud de datos de un art√≠culo en octetos</li>
              <li><b>LClave</b> = Longitud de clave en octetos</li>
              </ul>

            <h4>Fichero Secuencial</h4>
            <pre><code>Tama√±o en octetos = No. * LDatos</code></pre>

            <h4>Fichero Secuencial Indexado</h4>
            <p>Para los ficheros de datos de un S.I. se supondr√° que los huecos han sido recuperados, por SVSI y RTSI.</p>
            <p><b>Fichero de datos (-D) en longitud fija:</b></p>
            <pre><code>Tama√±o en octetos = No. * LDatos</code></pre>

            <p><b>Fichero de datos (-D) en longitud variable:</b></p>
            <pre><code>Tama√±o en octetos = No. * ( LDatos + 2 )</code></pre>

            <h4>Fichero de Claves (-I u otro -V -R -B)</h4>
            <p>T = tasa de reemplazamiento (n√∫mero entre 1 y 2, despu√©s de SVSI/RTSI tiende hacia 1)</p>
            <p><b>Tama√±o en sectores:</b></p>
            <pre><code>E+( No. / E-( E-( 254 / ( LClave + 6 ) ) / T ) ) + 1</code></pre>

            <p>Donde:</p>
            <ul>
              <li><code>E-( 254 / ( LClave + 6 ) )</code> = M√°ximo de claves por sectores</li>
              <li><code>E-( ... / T )</code> = M√≠nimo de claves por sectores</li>
              <li>El resultado = N√∫mero de sectores de claves</li>
              </ul>

            <h4>F√≥rmula Aproximada para S.I. con Datos</h4>
            <p>Los resultados son buenos con un margen de error del 1% aprox.</p>
            <p><b>a) LClave = LDatos (aproximadamente):</b></p>
            <pre><code>Tama√±o en octetos = ( No. * ( LClave + LDatos ) ) / 0.6</code></pre>

            <p><b>b) LClave &lt;&lt; LDatos (LClave = 10, LDatos = 100 o m√°s):</b></p>
            <pre><code>Tama√±o en octetos = ( No. * ( LClave + LDatos ) ) / 0.85</code></pre>

            <h4>N√∫mero de Claves M√°ximas/M√≠nimas de un Fichero de Claves</h4>
            <p>Todos los niveles del grafo se tienen en cuenta, y comprenden la ra√≠z.</p>
            <p>Para el c√°lculo de espacio, es necesario hacer menos 2.</p>
            <p>Los dos rangos de cifras para cada longitud de clave, corresponden a las tasas de reemplazamiento m√≠nima y m√°xima.</p>
            <p><b>Tabla 1: Longitudes de clave 2-15</b></p>
            <table>
              <thead>
                <tr>
                  <th>Long.Clave</th>
                  <th>Clav/Sect</th>
                  <th>Nivel 2</th>
                  <th>Nivel 3</th>
                  <th>Nivel 4</th>
                  <th>Nivel 5</th>
                  <th>Nivel 6</th>
                  <th>Nivel 7</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>2</td>
                  <td>31/15</td>
                  <td>1.023/527</td>
                  <td>32.767/8.463</td>
                  <td>65.536/65.536</td>
                  <td>-</td>
                  <td>-</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>28/14</td>
                  <td>840/448</td>
                  <td>24.388/6.748</td>
                  <td>707.280/101.248</td>
                  <td>1.834.980/917.560</td>
                  <td>-</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>25/12</td>
                  <td>675/350</td>
                  <td>17.575/4.575</td>
                  <td>456.975/59.500</td>
                  <td>1.638.375/773.525</td>
                  <td>-/786.498</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>23/11</td>
                  <td>575/299</td>
                  <td>13.823/3.611</td>
                  <td>331.775/43.355</td>
                  <td>1.507.305/520.283</td>
                  <td>-/720.957</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>21/10</td>
                  <td>483/252</td>
                  <td>10.647/2.793</td>
                  <td>234.255/30.744</td>
                  <td>1.376.235/338.205</td>
                  <td>-/655.416</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>19/9</td>
                  <td>399/209</td>
                  <td>7.999/2.109</td>
                  <td>159.999/21.109</td>
                  <td>1.245.165/211.109</td>
                  <td>-/589.875</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>18/9</td>
                  <td>360/198</td>
                  <td>6.858/1.998</td>
                  <td>130.320/19.998</td>
                  <td>1.179.630/199.998</td>
                  <td>-/589.869</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>9</td>
                  <td>16/8</td>
                  <td>288/160</td>
                  <td>4.912/1.456</td>
                  <td>83.520/13.120</td>
                  <td>1.048.560/118.096</td>
                  <td>-/524.328</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>15/7</td>
                  <td>255/135</td>
                  <td>4.095/1.095</td>
                  <td>65.535/8.775</td>
                  <td>983.025/70.215</td>
                  <td>-/458.793</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>11-12</td>
                  <td>14/7</td>
                  <td>224/126</td>
                  <td>3.374/1.022</td>
                  <td>50.624/8.190</td>
                  <td>759.374/65.534</td>
                  <td>917.490/458.787</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>13</td>
                  <td>13/6</td>
                  <td>195/104</td>
                  <td>2.743/741</td>
                  <td>38.415/5.200</td>
                  <td>537.823/36.413</td>
                  <td>851.955/254.904</td>
                  <td>-/393.259</td>
                </tr>
                <tr>
                  <td>14-15</td>
                  <td>12/6</td>
                  <td>168/96</td>
                  <td>2.196/684</td>
                  <td>28.560/4.800</td>
                  <td>371.292/33.612</td>
                  <td>786.420/235.296</td>
                  <td>-/393.252</td>
                </tr>
              </tbody>
            </table>

            <p><b>Tabla 2: Longitudes de clave 16-51</b></p>
            <table>
              <thead>
                <tr>
                  <th>Long.Clave</th>
                  <th>Clav/Sect</th>
                  <th>Nivel 2</th>
                  <th>Nivel 3</th>
                  <th>Nivel 4</th>
                  <th>Nivel 5</th>
                  <th>Nivel 6</th>
                  <th>Nivel 7</th>
                  <th>Nivel 8</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>16-17</td>
                  <td>11/5</td>
                  <td>143/77</td>
                  <td>1.727/473</td>
                  <td>20.735/2.849</td>
                  <td>248.831/17.105</td>
                  <td>720.885/102.641</td>
                  <td>-/327.717</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>18-19</td>
                  <td>10/5</td>
                  <td>120/70</td>
                  <td>1.330/430</td>
                  <td>14.640/2.590</td>
                  <td>161.050/15.550</td>
                  <td>655.350/93.310</td>
                  <td>-/327.710</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>20-22</td>
                  <td>9/4</td>
                  <td>99/54</td>
                  <td>999/279</td>
                  <td>9.999/1.404</td>
                  <td>99.999/7.029</td>
                  <td>589.815/35.154</td>
                  <td>-/175.779</td>
                  <td>-/262.180</td>
                </tr>
                <tr>
                  <td>23-25</td>
                  <td>8/4</td>
                  <td>80/48</td>
                  <td>728/248</td>
                  <td>6.560/1.248</td>
                  <td>59.048/6.248</td>
                  <td>524.280/31.248</td>
                  <td>-/156.248</td>
                  <td>-/262.172</td>
                </tr>
                <tr>
                  <td>26-30</td>
                  <td>7/3</td>
                  <td>63/35</td>
                  <td>511/147</td>
                  <td>4.095/595</td>
                  <td>32.767/2.387</td>
                  <td>262.143/9.555</td>
                  <td>458.745/38.227</td>
                  <td>-/152.915</td>
                </tr>
                <tr>
                  <td>31-36</td>
                  <td>6/3</td>
                  <td>48/30</td>
                  <td>342/126</td>
                  <td>2.400/510</td>
                  <td>16.806/2.046</td>
                  <td>117.648/8.190</td>
                  <td>393.210/32.766</td>
                  <td>-/131.070</td>
                </tr>
                <tr>
                  <td>37-44</td>
                  <td>5/2</td>
                  <td>35/20</td>
                  <td>215/65</td>
                  <td>1.295/200</td>
                  <td>7.775/605</td>
                  <td>46.655/1.820</td>
                  <td>279.935/5.465</td>
                  <td>327.675/16.400</td>
                </tr>
                <tr>
                  <td>45-51</td>
                  <td>4/2</td>
                  <td>24/16</td>
                  <td>124/52</td>
                  <td>624/160</td>
                  <td>3.124/484</td>
                  <td>15.624/1.456</td>
                  <td>78.124/4.372</td>
                  <td>262.140/13.120</td>
                </tr>
              </tbody>
            </table>

            <p><b>Tabla 3: Niveles 9-12 (para claves largas)</b></p>
            <table>
              <thead>
                <tr>
                  <th>Long.Clave</th>
                  <th>Clav/Sect</th>
                  <th>Nivel 9</th>
                  <th>Nivel 10</th>
                  <th>Nivel 11</th>
                  <th>Nivel 12</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>26-30</td>
                  <td>7/3</td>
                  <td>-/196.641</td>
                  <td>-</td>
                  <td>-</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>31-36</td>
                  <td>6/3</td>
                  <td>-/196.632</td>
                  <td>-</td>
                  <td>-</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>37-44</td>
                  <td>5/2</td>
                  <td>-/49.205</td>
                  <td>-/131.100</td>
                  <td>-</td>
                  <td>-</td>
                </tr>
                <tr>
                  <td>45-51</td>
                  <td>4/2</td>
                  <td>-/39.364</td>
                  <td>-/118.096</td>
                  <td>-/131.092</td>
                  <td>-</td>
                </tr>
              </tbody>
            </table>

            <h4>Fichero Multi-Criterio</h4>
            <p>Un fichero multi-criterio se compone de un fichero S.I. y de dos ficheros de claves (-V y -R).</p>
            <p>El tama√±o del fichero S.I. se calcula como se ha visto m√°s arriba.</p>
            <p>Para los ficheros -V y -R hay que conocer la longitud de sus claves y el n√∫mero de art√≠culos para cada uno de los dos ficheros, despu√©s calcular como para un fichero S.I. sin datos.</p>
            <p>Se supondr√° que los enlaces se han creado y que los ficheros se han salvado y restaurados por SVSI / RTSI.</p>
            <p><b>Fichero -I y -D:</b> Ver S.I.</p>
            <p><b>Fichero -V:</b> Es un fichero de claves de tipo S.I.</p>
            <ul>
              <li>Longitud clave = 51 (bien 2 a 4 claves por sectores)</li>
              <li>No.de art√≠culos = (Nodif * No.enlaces) + No.r√∫bricas</li>
              </ul>

            <p>Donde Nodif = No. de art√≠culos S.I. cuyos valores de enlaces son diferentes unos a los otros m√°s 1.</p>
            <p><b>Fichero -R:</b> Es un fichero de claves de tipo S.I.</p>
            <ul>
              <li>Longitud clave = Longitud clave S.I. + 5</li>
              <li>No.de art√≠culos = ((No.art√≠culos S.I. + 1) * No.enlaces)</li>
              </ul>

            <h4>Ejemplo de C√°lculo M.C.</h4>
            <p>Sea un fichero multi-criterio de 1000 art√≠culos y de 10 r√∫bricas:</p>
            <ul>
              <li>Claves del S.I.: longitud de 10 octetos</li>
              <li>Datos: longitud 100 octetos</li>
              <li>Gr√°nulos: 16 sectores</li>
              <li>Por t√©rmino medio un art√≠culo de cada dos tiene valores de enlaces diferentes</li>
              </ul>

            <p><b>Fichero S.I.:</b></p>
            <ul>
              <li>-I: 68/144 (M√≠n./M√°x. de sectores) = 5/9 gr√°nulos</li>
              <li>-D: 391 sectores aprox. = 25 gr√°nulos</li>
              <li>Total S.I.: 30 a 34 gr√°nulos</li>
              </ul>

            <p><b>F√≥rmula aproximada:</b> 1000 * (100 + 10) / 0.85 = 505, es decir 32 gr√°nulos</p>
            <table>
              <thead>
                <tr>
                  <th>No.Enlaces</th>
                  <th>1</th>
                  <th>2</th>
                  <th>3</th>
                  <th>4</th>
                  <th>5</th>
                  <th>10</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Art√≠culos -R</td>
                  <td>1001</td>
                  <td>2002</td>
                  <td>3003</td>
                  <td>4004</td>
                  <td>5005</td>
                  <td>10010</td>
                </tr>
                <tr>
                  <td>M√≠n/M√°x -R Sectores</td>
                  <td>85/168</td>
                  <td>168/335</td>
                  <td>252/502</td>
                  <td>335/667</td>
                  <td>419/836</td>
                  <td>836/1670</td>
                </tr>
                <tr>
                  <td>M√≠n/M√°x -R Gr√°nulos</td>
                  <td>6/11</td>
                  <td>11/21</td>
                  <td>16/32</td>
                  <td>21/42</td>
                  <td>27/53</td>
                  <td>53/105</td>
                </tr>
                <tr>
                  <td>Art√≠culos -V</td>
                  <td>511</td>
                  <td>1011</td>
                  <td>1511</td>
                  <td>2011</td>
                  <td>2511</td>
                  <td>5011</td>
                </tr>
                <tr>
                  <td>M√≠n/M√°x -V Sectores</td>
                  <td>129/257</td>
                  <td>254/507</td>
                  <td>379/757</td>
                  <td>504/1007</td>
                  <td>629/1257</td>
                  <td>1254/2507</td>
                </tr>
                <tr>
                  <td>M√≠n/M√°x -V Gr√°nulos</td>
                  <td>9/17</td>
                  <td>16/32</td>
                  <td>24/48</td>
                  <td>32/63</td>
                  <td>40/79</td>
                  <td>79/157</td>
                </tr>
                <tr>
                  <td><b>Total M.C. Gr√°nulos</b></td>
                  <td><b>45/62</b></td>
                  <td><b>57/87</b></td>
                  <td><b>70/114</b></td>
                  <td><b>83/139</b></td>
                  <td><b>97/166</b></td>
                  <td><b>162/296</b></td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Ocupaci√≥n de Espacio Memoria en B.A.L.</h3>

            <p>En PROLOGUE &gt;= 2.2b, todo lo que sigue es v√°lido para el conjunto de los puestos de trabajo.</p>
            <h4>1) Carga del Ejecutor</h4>
            <p>El interpretador de comandos carga el ejecutor en la partici√≥n del puesto si es posible, si no, en la partici√≥n com√∫n. Si est√° en la partici√≥n com√∫n, es particionable y su c√≥digo solo ser√° almacenado una sola vez en memoria.</p>
            <ul>
              <li>Tama√±o del c√≥digo de EX: 25 K octetos</li>
              <li>Tama√±o del c√≥digo de EXBL: 34 K octetos</li>
              </ul>

            <h4>2) Data Segment del Ejecutor</h4>
            <p>El ejecutor va a hacer varias llamadas de alocaci√≥n de espacio de memoria de m√≥dulo 8 K, en la partici√≥n del puesto si es posible, si no, en la partici√≥n com√∫n. El espacio pedido no puede sobrepasar 64K octetos, este espacio debe ser continuo en memoria. Constituye el DATA SEGMENT del ejecutor.</p>
            <h4>3) Espacio Din√°mico</h4>
            <p>El programa de aplicaci√≥n puede pedir din√°micamente espacio memoria suplementario fuera de los espacios definidos en 1) y 2).</p>
            <p><b>En el curso de uso de m√©todos de acceso:</b></p>
            <p><b>Para NGF:</b> </p>
            <ul>
              <li>256 octetos en la primera apertura</li>
              <li>64 octetos por n√∫mero l√≥gico sistema NGF</li>
              </ul>

            <p><b>Para SEQ:</b> 512 octetos por puesto (cuando se use)</p>
            <p><b>Para S.I.:</b></p>
            <pre><code>512 + (528 * p) + (1440 * f) + (96 * o) + (272 * n) octetos</code></pre>

            <p>Donde:</p>
            <ul>
              <li>p = N√∫mero de puestos que usan S.I.</li>
              <li>f = N√∫mero de ficheros S.I. diferentes y abiertos simult√°neamente para cualquier puesto</li>
              <li>o = N√∫mero de OPEN S.I. simult√°neos, en todos los puestos y para todos los ficheros</li>
              <li>n = N√∫mero de niveles en el grafo, sin contar la ra√≠z ni el nivel siguiente, esto para los ficheros del apartado "f"</li>
              </ul>

            <p><b>Para M.C.:</b> 256 octetos por n√∫mero l√≥gico sistema M.C.</p>
            <p><b>En un LOAD.GO=</b> (de utilitario -X o de programa BAL -T)</p>
            <p><b>En un LOAD=</b> (de sub-programa ensamblador)</p>
            <h4>4) Imagen Espacio Memoria (ejemplo PLG 2.2b)</h4>
            <pre><code>         __________________________________
  0000h !                                  !
        !         PROLOGUE SYSTEME         !
        !                                  !
        !----------------------------------!
        !         PARTICI√ìN SISTEMA        !
        !----------------------------------!
        !            libre                 !
        !                                  !
--------!----------------------------------!-------------------------------
1)      !    C√≥d. de  EX   . . . . . . . . !  . . . . . 25  K octetos
        !    o  de    EXBL . . . . . . . . !  . . . . . 34  K octetos
--------!----------------------------------!-------------------------------
        !            libre                 !
        !                                  !
--------!----------------------------------!-------------------------------
2)  ^ a)! variables de EX o  EXBL  . . . . !  . . . . .  2  K octetos
    !   !----------------------------------!-------------------------------
    ! b)! Descripci√≥n de variables         ! 6, 7 u 11 octetos por nombre
    !   ! declaradas                       ! de variable (ver m√°s adelante)
    !   !----------------------------------!-------------------------------
    ! c)! Descripci√≥n de segmentos del -T  ! ( No segmentos * 11 ) + 1  oct
    !   !----------------------------------!-------------------------------
8 K ! d)! Valores de variables en memoria  ! "Longitud datos...."
    !   !----------------------------------!-------------------------------
    ! e)! Tabla de segmentos en memoria    !  ( No.segmentos * 6 ) + 1  oct
 a  !   !----------------------------------!-------------------------------
    ! f)! Tama√±o del segmento m√°s grande   ! "Longueur programme" del m√°s
    !   !                                  ! grande de los segmentos.
64 K!   ! [ + Tama√±o del segmento 0 ]      !  [ + "Longueur Programme" del
    !   !                                  !                   segmento 0 ]
    !   !----------------------------------!-------------------------------
    ! g)! Tamp√≥n de carga de segmento      !  . . . . .   256 octetos
    !   !----------------------------------!-------------------------------
    ! h)! Zona de trabajo de EX o  EXBL  . !  . . . . .     8  K octetos
    v   ! zona de trabajo de EX            !
--------!----------------------------------!-------------------------------
        !            libre                 !
--------!----------------------------------!-------------------------------
3)  ^   !                                  ! 0 a n espacios memoria
    !   !                                  ! discontinuos pedidos por los
    !   !                                  ! Nlog, LOAD=, LOAD.GO= del
    v   !                                  ! programa BAL.
--------!----------------------------------!-------------------------------
        !            libre                 !
        !----------------------------------!
        ! Extensi√≥n Sistema ( SI, MC, .. ) !
        !----------------------------------!
0FFFFFh ! Zona reservada                   !
        `----------------------------------'</code></pre>

            <h4>5) Detalle de la Parte (2)</h4>
            <p>Esta parte (2) existe para cada programa y sub-programa BAL ejecutado.</p>
            <table>
              <thead>
                <tr>
                  <th>Componente</th>
                  <th>Tama√±o</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>a) Variables del ejecutor</td>
                  <td>2 K octetos</td>
                </tr>
                <tr>
                  <td>b) Descripci√≥n variables memoria central no dimensionada</td>
                  <td>6 octetos por nombre</td>
                </tr>
                <tr>
                  <td>b) Descripci√≥n variables memoria virtual no dimensionada</td>
                  <td>7 octetos por nombre</td>
                </tr>
                <tr>
                  <td>b) Descripci√≥n variables dimensionadas</td>
                  <td>11 octetos por nombre</td>
                </tr>
                <tr>
                  <td>c) Descripci√≥n de segmentos T-code</td>
                  <td>(No.segmentos * 11) + 1 octetos</td>
                </tr>
                <tr>
                  <td>d) Valores de variables en memoria</td>
                  <td>"Longueur de donn√©es" (del traductor)</td>
                </tr>
                <tr>
                  <td>e) Tablas de segmentos en memoria</td>
                  <td>(No.segmentos * 6) + 1 octetos</td>
                </tr>
                <tr>
                  <td>f) Espacio para cambiar segmentos</td>
                  <td>"Longueur programme" del mayor [+ segmento 0]</td>
                </tr>
                <tr>
                  <td>g) Tamp√≥n de carga de segmento</td>
                  <td>256 octetos</td>
                </tr>
                <tr>
                  <td>h) Zona de trabajo de EX o EXBL</td>
                  <td>8 K octetos</td>
                </tr>
              </tbody>
            </table>

            <p><b>Nota sobre f):</b> Al cargar el ejecutor se reserva el espacio para el segmento m√°s grande (y si es posible para el segmento m√°s grande y el segmento 0). En este espacio, el ejecutor cargar√° tantos segmentos como espacio tenga disponible. En caso de necesitar espacio para cargar otro segmento, el (los) segmento(s) llamados menos recientemente se suprimen del espacio de memoria y su(s) plaza(s) se recupera(n). En este caso y si se necesita m√°s tarde, ser√°n recargados.</p>
            <h4>6) Detalle de la Parte (3)</h4>
            <p>Esta parte existe o no seg√∫n la aplicaci√≥n; este espacio no es forzosamente continuo (en general No lo es). Corresponde a las necesidades din√°micas de la aplicaci√≥n:</p>
            <ul>
              <li><b>N√∫meros l√≥gicos:</b> (ver m√°s arriba)</li>
              <li><b>LOAD= y/o LOAD.GO=:</b> El espacio usado depende del utilitario cargado</li>
              </ul>

            <p>En el caso de LOAD.GO= de un programa BAL (fichero de tipo -T) el ejecutor no se recarga, pero una zona de memoria suplementaria de 8 a 64 K octetos se usa para ejecutar el programa llamado.</p>
            <hr />

            <h3>N√∫meros L√≥gicos</h3>

            <p>El n√∫mero de n√∫meros l√≥gicos realmente necesarios para el sistema depende del n√∫mero abierto para cada aplicaci√≥n usando la misma unidad central.</p>
            <p>Cada m√©todo de acceso puede llamar a otro m√©todo de acceso, as√≠ pues es preciso contar, a nivel sistema, las llamadas a otros m√©todos de acceso. Por ejemplo una apertura de un fichero S.I., utiliza un n√∫mero l√≥gico S.I. y dos n√∫meros l√≥gicos NGF si este fichero S.I. tiene datos (un fichero -D).</p>
            <p>La tabla inferior da el n√∫mero de n√∫meros l√≥gicos del sistema para un n√∫mero l√≥gico de una aplicaci√≥n.</p>
            <h4>Tabla de N√∫meros L√≥gicos del Sistema</h4>
            <pre><code>:-------------------------------------------------------------------------:
!\  Nlog          ! Soporte     ! por defecto !             !             !
!   \ Aplicaci√≥n  !( IM, EC, ..)! de CLOSE=0  !             !             !
!      \          !             !             !     S.I.    !     M.C.    !
! Nlog    \       !   N G F     ! el fichero  !             !             !
!  Sistema  \     !   S E Q     ! -T est√°     !             !             !
!              \  !             !    abierto  !             !             !
!-------------------------------------------------------------------------!
! N G F  /  S E Q !             !             !  * 2 si -D  !             !
! M√°x. 127        !    * 1      !    * 1      !             !    * 4      !
! por puesto      !             !             !  * 1 si no  !             !
! si no error 51  !             !             !     hay -D  !             !
!-------------------------------------------------------------------------!
!   S. I.         !             !             !             !             !
! M√°x. 255        !      0      !     0       !    * 1      !    * 3      !
! por puesto      !             !             !             !             !
! si no error 72  !             !             !             !             !
!-------------------------------------------------------------------------!
!   M. C.         !             !             !             !             !
! M√°x. 255 en todo!             !             !             !             !
! e inferior al   !      0      !     0       !     0       !    * 1      !
! valor dado en   !             !             !             !             !
!   SYSCONF-X     !             !             !             !             !
! si no error 84  !             !             !             !             !
!-------------------------------------------------------------------------!
!   B A L         !             !             !             !             !
! 32 por prog -T  !             !             !             !             !
! si no error 50  !    * 1      !     0       !    * 1      !    * 1      !
!                 !             !             !             ! Limita a 31 !
!   Decor         !             !             !             ! por  N G F  !
! 32 por puesto   !             !             !             !             !
`-------------------------------------------------------------------------'</code></pre>

            <hr />

            <h3>Estructura de un Fichero Traducido -T</h3>

            <h4>En Principio del Fichero Traducido -T</h4>
            <pre><code>:-------------------------------------------------:
!   N√∫mero de versi√≥n del traductor      35 para 5! 3 octetos ASCII
!   Sub-n√∫mero de versi√≥n del traductor  31 para 1! aqu√≠ 5.1-1
!   N√∫mero de versi√≥n code - T           31 para 1! de /30 a /39
!-------------------------------------------------!
!            Longitud tabla de variables          ! 2 octetos, en
!        +   Longitud tabla de segmentos          ! notaci√≥n invertida
!-------------------------------------------------!
!                                                 ! 2 octetos, en
!            Longitud tabla de variables          ! notaci√≥n invertida
!-------------------------------------------------!
!                 TABLA de variables              ! Longitud = Longitud
!                                                 ! Tabla de variables
!-------------------------------------------------!
!                 TABLA de segmentos              ! Longitud = Longitud
!                                                 ! Tabla de segmentos
`-------------------------------------------------'</code></pre>

            <h4>Tabla de Segmentos</h4>
            <p>Cada segmento ocupa 11 octetos. Los octetos no utilizados siempre se inicializan a cero (/30). Las direcciones y longitudes est√°n siempre en notaci√≥n invertida (en el orden D√âBIL/FUERTE). Los segmentos se implantan siempre en el disco al principio de sector. Los n√∫meros de segmentos no est√°n forzosamente en orden, incluso para el segmento cero. Un segmento descrito en esta tabla es forzosamente ejecutable. Esto es, que se ha traducido sin error por la misma versi√≥n de c√≥d.intermediario que el indicado en cabecera.</p>
            <pre><code>----:-------------------------------------------------:----------------
 p  !     N√∫mero del segmento, fin de tabla si /FF    ! 1 octeto
 o  !-------------------------------------------------!
 r  !     Direcci√≥n sector relativo, en el fichero,   ! 2 octetos en
    !             del principio del segmento          ! notaci√≥n invertida
 s  !-------------------------------------------------!
 e  !     Longitud de este segmento en octetos        ! 2 octetos en
 g  !                                                 ! notaci√≥n invertida
 m  !-------------------------------------------------!
 e  !              6 octetos a cero                   ! 6 octetos
 n  !        ( reservados para el ejecutor )          !
 t  !                                                 !
 o  !                                                 !
----!-------------------------------------------------!-----------------
    !   /FF fin de tabla de segmentos                 !
    `-------------------------------------------------'</code></pre>

            <h4>Tabla de Variables</h4>
            <pre><code>:-------------------------------------------------:
!            N√∫mero de variables                  ! 2 octetos en
!                                                 ! notaci√≥n invertida
!-------------------------------------------------!
! Tabla de direcciones de descriptores de variable! Longitud = 2 *
! relativa al principio de descriptores de las    ! No de variables
! variables a partir de la direcci√≥n 1            ! Si 0, no existe.
! En el orden de declaraciones.                   !
----!-------------------------------------------------!--------------------
   p!            Tipo de la variable                  ! 1 octeto
d  o!-------------------------------------------------!
e  r! Longitud declarada para 1 elemento de  variable ! 1 octeto, 0=256
s   !-------------------------------------------------!
c  v! Direcci√≥n memoria relativa de implantaci√≥n en   ! 2 octetos si memoria
r  a! octetos en notaci√≥n invertida                   ! 3 octetos si externa
i  r!-------------------------------------------------!
p  i! Tama√±o segunda dimensi√≥n,                       ! 0 o 2 octetos en
t  a! ( si la variable est√° dimensionada )            ! notaci√≥n invertida
o  b!-------------------------------------------------!
r  l! Tama√±o primera dimensi√≥n,                       ! 0 o 2 octetos en
   e! ( si la variable est√° dimensionada )            ! notaci√≥n invertida
----!-------------------------------------------------!--------------------
    ! Lista de nombres de variables ( para Dbug )     ! Longitud = 8 *
    ! comando "M" modificar y "D" display             ! No. de nombre
    ! En el orden de declaraciones.                   ! variable
    `-------------------------------------------------'</code></pre>

            <h4>Octeto: Tipo de la Variable</h4>
            <pre><code>:------------------------------------:
!   !   !   !    :   !   !   !   !   !
`------------------------------------'
  !   ! `---v---'`---------v---------'
  !   !     !              `-----------&gt; N√∫mero l√≥gico 1 a 15 si externa
  !   !     !                            0 si soporte = memoria
  !   !     !
  !   !     `------&gt; Tipo declarado : 0 = binario 1 octeto  #
  !   !                               1 = binario 2 octetos %
  !   !                               2 = cadena
  !   !                               3 = num√©rico largo
  !   !
  !   `-----&gt; 1 = presencia primera dimensi√≥n
  !
  `---------&gt; 1 = presencia segunda dimensi√≥n</code></pre>

            <hr />

            <h3>Estructura de un Cat√°logo de PROLOGUE</h3>

            <p>Un cat√°logo comprende 13 a 256 sectores, permitiendo 31 a 895 ficheros.</p>
            <p>Un asterisco * significa que el valor se da en notaci√≥n invertida.</p>
            <h4>Estructura de Sectores 0-4</h4>
            <pre><code>Sector  :    0                1                2               3

Octeto:-------------:  :-------------:  :-------------:  :-------------:
 0-1  !No.Gr√°nulos *!  ! 1 bit = STAT!  !             !  !             !
      !-------------!  !    de un    !  !             !  !             !
otros !1 Bit=1 gran.!  !    de un    !  !             !  !             !
      ! Bit=0 :libre!  !   gr√°nulo   !  !             !  !             !
      `-------------'  `-------------'  `-------------'  `-------------'

       1 a 2032 gran.   0 a 2048 gran.   0 a 2048 gran.   0 a 2048 gran.
      `--------------------------------v--------------------------------'
                                 1 a 8176 gr√°nulos


Sector  :        4                         5          6 a 11       12

Octet 0    1   2      7 !8             0        7               0        63
    :----------------------------:    :----------:   ........  :----------:
  0 !LGR LCAT IND    VC ! Nom F1 !    !Nom volume!   :      :  ! DESC F28 !
    !----------------------------!    !..........!   :      :  !----------!
 16 ! Nom fichero F2    ! Nom F3 !  64! DESC F1  !   :      :  ! DESC F29 !
    !............................!    !----------!   :      :  !----------!
 32 /                   !        / 128! DESC F2  !   :      :  ! DESC F30 !
    !...................!........!    !----------!   :      :  !----------!
240 ! Nom fichero F30   ! Nom F31! 192! DESC F3  !   :      :  ! DESC F31 !
    `----------------------------'    `----------'   ........  `----------'

    `-------------v--------------'    `-----------------v-----------------'
    1 sector nombres de ficheros     8 sectores de descriptores de ficheros</code></pre>

            <h4>Estructura de Sectores 13+</h4>
            <pre><code>Sector  :       13                      14           15 a 20     21
Octetos   0         8             0              63             0       63
         :-------------------:   :-----------------:  .......  :----------:
         ! Nom F32 ! Nom F33 !   ! Descriptor  F32 !  :     :  ! Desc F60 !
0 a 27   !         !         !   !-----------------!  :     :  !----------!
         !         !         !   ! Descriptor  F33 !  :     :  ! Desc F61 !
veces 9  !         !         !   !-----------------!  :     :  !----------!
         !         !         !   ! Descriptor  F34 !  :     :  ! Desc F62 !
Sectores !         !         !   !-----------------!  :     :  !----------!
31 a 895 ! Nom F62 ! Nom F63 !   ! Descriptor  F35 !  :     :  ! Desc F63 !
ficheros `-------------------'   `-----------------'  .......  `----------'</code></pre>

            <h4>Cabecera del Volumen (Sector 4)</h4>
            <ul>
              <li><b>LGR:</b> Longitud de un gr√°nulo en sectores (0 = 256)</li>
              <li><b>LCAT:</b> N√∫mero del 1er sector despu√©s del cat√°logo (0 = 256)</li>
              <li><b>IND:</b> </li>
              <ul>
                <li>/9F = indicador de volumen PROLOGUE: nom.fichero en 7+1 √∫nicamente</li>
                <li>/A0 = indicador de volumen PROLOGUE: nom.fichero en 7+1 y/o 8+3</li>
                </ul>
              </ul>

            <ul>
              <li><b>VC:</b> Indicador volumen COPIA:</li>
              <ul>
                <li>0 si no, se puede usar este volumen</li>
                <li>01, 02, ... n√∫mero del volumen COPIA, el √∫ltimo volumen lleva su n√∫mero + /80, este volumen se usa por SV, RT, SVSI, RTSI</li>
                </ul>
              </ul>

            <h4>Nombre de Fichero (Nom Fxx)</h4>
            <p>Si Nom Fxx comienza por:</p>
            <ul>
              <li>Un octeto a 00H, no existe</li>
              <li>Un c√≥d. ASCII &gt; 20H el nombre del fichero est√° en 7 + 1</li>
              <li>01 el nombre del fichero est√° en 8 + 3 (IND=A0H)</li>
              </ul>

            <p>Si Nom Fxx est√° compuesto de 8 octetos a cero, es el fin de nombres de ficheros.</p>
            <h4>Descriptor de un Fichero</h4>
            <pre><code>           Nom.Fichero en 7 + 1             Nom.fichero en 8 + 3
Octet :-----------------------------:       :-----------------------------:
 0-3  ! claves de acceso lect/escr. !  0-3  ! fin del nombre fichero Tipo !
      !-----------------------------!       !-----------------------------!
 4-5  ! Long.datos * ! Long. datos  !  4-5  ! Long.datos * ! Long. datos  !
      !  SEQ, SI     ! Relativo(NGF)!       !  SEQ, SI     ! Relativo(NGF)!
      !--------------! en octetos   !       !--------------! en octetos   !
   6  ! Long.clave SI!     *        !    6  ! Long.clave SI!     *        !
      !-----------------------------!       !-----------------------------!
   7  ! N√∫mero de gr√°nulos 1er bloq.!    7  ! N√∫mero de gr√°nulos 1er bloq.!
      !-----------------------------!       !-----------------------------!
 8-9  ! 000 Rango 1er.gran.del bloq.!  8-9  ! 0xx Rango 1er.gran del bloq.!
      !-----------------------------!       !-----------------------------!
      !                             !    10 ! N√∫mero gr√°nulos 2o.bloque   !
      !                             !       !-----------------------------!
      !                             ! 11-12 ! yyy Rango 2o gran.del bloque!
      !                             !       !-----------------------------!
      !                             !    13 ! N√∫mero gr√°nulos 3er.bloque  !
      //                           //       !-----------------------------!
      !                             ! 14-15 ! zzz Rango 3er.gran.del bloq.!
      !                             !       !-----------------------------!
      !                             !      //                            //
      !-----------------------------!       !-----------------------------!
  58  ! N√∫mero gr√°nulos 18o bloque  !    58 ! N√∫mero gr√°nulos 18o bloque  !
      !-----------------------------!       !-----------------------------!
59-60 ! 000 Rango 18o gr.del bloque ! 59-60 ! 000 Rango 18o gr.del bloque !
      !-----------------------------!       !-----------------------------!
   61 ! Tipo de fichero             !    61 ! Tipo de fichero             !
      !-----------------------------!       !-----------------------------!
62-63 ! No.de registros SEQ       * ! 62-63 ! No.de registros SEQ       * !
      `-----------------------------'       `-----------------------------'</code></pre>

            <p>0xxyyyzzz c√≥d.sobre 8 bits un octeto de la clave de acc Lect/Escr. en 8+3.</p>
            <h4>Codificaci√≥n Tipo de Fichero (Octeto 61)</h4>
            <pre><code>  7   6   5   4   3   2   1   0
:-------------------------------:
!   .   :   .   !   .   :   .   !
`-------------------------------'
  !   !       !           `-v-'
  !   !       !             `------&gt; 00 = NGF , BLOC  ( bit )
  !   !       !                      01 = SEQ         ( bit )
  !   !       !                      10 = SI          ( bit )
  !   !       `------- &gt; 1 = Longitud Variable ( en S.I. )
  !   `----&gt; 1 = Cuadrar la clave cadena a derecha, si 0 cuadrar izquierda.
  `--------&gt; 1 = Clave cadena a cuadrar, si 0 clave binaria no cuadrar.</code></pre>

            <hr />

            <h3>Esquema de un Cable TELE</h3>

            <p>Este cable permite unir 2 MICRALES para transferir ficheros NGF, con la ayuda del utilitario TELE-X, que se suministra con la opci√≥n "Teletransmisi√≥n As√≠ncrona bajo PROLOGUE".</p>
            <p>Los ficheros de tipo SI (o MC, BD) deben ser transformados en NGF por SVSI, despu√©s de la transmisi√≥n, RTSI permitir√° devolverlos a S.I.</p>
            <h4>El Conector del Cable</h4>
            <ul>
              <li><b>Macho</b> para un MICRAL 90.50, 90.20, MICRAL 80.31 o 80.21-2 o QUESTAR M.</li>
              <li><b>Hembra</b> para un MICRAL 30.</li>
              </ul>

            <h4>Conexiones</h4>
            <pre><code>          :----:                       :----:
          !  2 !-----------------------!  3 !
          `----'                       `----'

          :----:                       :----:
          !  3 !-----------------------!  2 !
          `----'                       `----'

          :----:                       :----:
   :------!  4 !                       !  4 !------:
   !      `----'                       `----'      !
   !                                               !
   !      :----:                       :----:      !
   `------!  5 !                       !  5 !------'
          `----'                       `----'

          :----:                       :----:
   :------!  6 !                       !  6 !------:
   !      `----'                       `----'      !
   !                                               !
   !      :----:                       :----:      !
   !      !  7 !-----------------------!  7 !      !
   !      `----'                       `----'      !
   !                                               !
   !      :----:                       :----:      !
   `------!  8 !-----------------------!  8 !------'
          `----'                       `----'
             !                            !
          :----:                       :----:
          ! 20 !-----------------------! 20 !
          `----'                       `----'</code></pre>

            <h4>Resumen de Conexiones</h4>
            <table>
              <thead>
                <tr>
                  <th>Pin lado A</th>
                  <th>Pin lado B</th>
                  <th>Tipo</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>2</td>
                  <td>3</td>
                  <td>Cruzado (TX/RX)</td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>2</td>
                  <td>Cruzado (TX/RX)</td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>5 (mismo lado)</td>
                  <td>Puente local</td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>4 (mismo lado)</td>
                  <td>Puente local</td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>8 (mismo lado)</td>
                  <td>Puente local</td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>7</td>
                  <td>Directo (GND)</td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>6 (mismo lado)</td>
                  <td>Puente local</td>
                </tr>
                <tr>
                  <td>20</td>
                  <td>20</td>
                  <td>Directo</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Los C√≥digos ASCII</h3>

            <h4>Caracteres de Control (0-31)</h4>
            <table>
              <thead>
                <tr>
                  <th>DEC</th>
                  <th>HEX</th>
                  <th>CAR</th>
                  <th>DEC</th>
                  <th>HEX</th>
                  <th>CAR</th>
                  <th>DEC</th>
                  <th>HEX</th>
                  <th>CAR</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>000</td>
                  <td>00</td>
                  <td>NUL</td>
                  <td>011</td>
                  <td>0B</td>
                  <td>VT</td>
                  <td>022</td>
                  <td>16</td>
                  <td>SYN</td>
                </tr>
                <tr>
                  <td>001</td>
                  <td>01</td>
                  <td>SOH</td>
                  <td>012</td>
                  <td>0C</td>
                  <td>FF</td>
                  <td>023</td>
                  <td>17</td>
                  <td>ETB</td>
                </tr>
                <tr>
                  <td>002</td>
                  <td>02</td>
                  <td>STX</td>
                  <td>013</td>
                  <td>0D</td>
                  <td>CR</td>
                  <td>024</td>
                  <td>18</td>
                  <td>CAN</td>
                </tr>
                <tr>
                  <td>003</td>
                  <td>03</td>
                  <td>ETX</td>
                  <td>014</td>
                  <td>0E</td>
                  <td>SO</td>
                  <td>025</td>
                  <td>19</td>
                  <td>EM</td>
                </tr>
                <tr>
                  <td>004</td>
                  <td>04</td>
                  <td>EOT</td>
                  <td>015</td>
                  <td>0F</td>
                  <td>SI</td>
                  <td>026</td>
                  <td>1A</td>
                  <td>SUB</td>
                </tr>
                <tr>
                  <td>005</td>
                  <td>05</td>
                  <td>ENQ</td>
                  <td>016</td>
                  <td>10</td>
                  <td>DLE</td>
                  <td>027</td>
                  <td>1B</td>
                  <td>Escape</td>
                </tr>
                <tr>
                  <td>006</td>
                  <td>06</td>
                  <td>ACK</td>
                  <td>017</td>
                  <td>11</td>
                  <td>DC1</td>
                  <td>028</td>
                  <td>1C</td>
                  <td>FS</td>
                </tr>
                <tr>
                  <td>007</td>
                  <td>07</td>
                  <td>BEL</td>
                  <td>018</td>
                  <td>12</td>
                  <td>DC2</td>
                  <td>029</td>
                  <td>1D</td>
                  <td>GS</td>
                </tr>
                <tr>
                  <td>008</td>
                  <td>08</td>
                  <td>BS</td>
                  <td>019</td>
                  <td>13</td>
                  <td>DC3</td>
                  <td>030</td>
                  <td>1E</td>
                  <td>RS</td>
                </tr>
                <tr>
                  <td>009</td>
                  <td>09</td>
                  <td>HT</td>
                  <td>020</td>
                  <td>14</td>
                  <td>DC4</td>
                  <td>031</td>
                  <td>1F</td>
                  <td>US</td>
                </tr>
                <tr>
                  <td>010</td>
                  <td>0A</td>
                  <td>LF</td>
                  <td>021</td>
                  <td>15</td>
                  <td>NAK</td>
                  <td>032</td>
                  <td>20</td>
                  <td>ESPACIO</td>
                </tr>
              </tbody>
            </table>

            <h4>Caracteres Imprimibles (33-127)</h4>
            <table>
              <thead>
                <tr>
                  <th>DEC</th>
                  <th>HEX</th>
                  <th>CAR</th>
                  <th>DEC</th>
                  <th>HEX</th>
                  <th>CAR</th>
                  <th>DEC</th>
                  <th>HEX</th>
                  <th>CAR</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>033</td>
                  <td>21</td>
                  <td>!</td>
                  <td>065</td>
                  <td>41</td>
                  <td>A</td>
                  <td>097</td>
                  <td>61</td>
                  <td>a</td>
                </tr>
                <tr>
                  <td>034</td>
                  <td>22</td>
                  <td>"</td>
                  <td>066</td>
                  <td>42</td>
                  <td>B</td>
                  <td>098</td>
                  <td>62</td>
                  <td>b</td>
                </tr>
                <tr>
                  <td>035</td>
                  <td>23</td>
                  <td>#</td>
                  <td>067</td>
                  <td>43</td>
                  <td>C</td>
                  <td>099</td>
                  <td>63</td>
                  <td>c</td>
                </tr>
                <tr>
                  <td>036</td>
                  <td>24</td>
                  <td>$</td>
                  <td>068</td>
                  <td>44</td>
                  <td>D</td>
                  <td>100</td>
                  <td>64</td>
                  <td>d</td>
                </tr>
                <tr>
                  <td>037</td>
                  <td>25</td>
                  <td>%</td>
                  <td>069</td>
                  <td>45</td>
                  <td>E</td>
                  <td>101</td>
                  <td>65</td>
                  <td>e</td>
                </tr>
                <tr>
                  <td>038</td>
                  <td>26</td>
                  <td>&amp;</td>
                  <td>070</td>
                  <td>46</td>
                  <td>F</td>
                  <td>102</td>
                  <td>66</td>
                  <td>f</td>
                </tr>
                <tr>
                  <td>039</td>
                  <td>27</td>
                  <td>'</td>
                  <td>071</td>
                  <td>47</td>
                  <td>G</td>
                  <td>103</td>
                  <td>67</td>
                  <td>g</td>
                </tr>
                <tr>
                  <td>040</td>
                  <td>28</td>
                  <td>(</td>
                  <td>072</td>
                  <td>48</td>
                  <td>H</td>
                  <td>104</td>
                  <td>68</td>
                  <td>h</td>
                </tr>
                <tr>
                  <td>041</td>
                  <td>29</td>
                  <td>)</td>
                  <td>073</td>
                  <td>49</td>
                  <td>I</td>
                  <td>105</td>
                  <td>69</td>
                  <td>i</td>
                </tr>
                <tr>
                  <td>042</td>
                  <td>2A</td>
                  <td>*</td>
                  <td>074</td>
                  <td>4A</td>
                  <td>J</td>
                  <td>106</td>
                  <td>6A</td>
                  <td>j</td>
                </tr>
                <tr>
                  <td>043</td>
                  <td>2B</td>
                  <td>+</td>
                  <td>075</td>
                  <td>4B</td>
                  <td>K</td>
                  <td>107</td>
                  <td>6B</td>
                  <td>k</td>
                </tr>
                <tr>
                  <td>044</td>
                  <td>2C</td>
                  <td>,</td>
                  <td>076</td>
                  <td>4C</td>
                  <td>L</td>
                  <td>108</td>
                  <td>6C</td>
                  <td>l</td>
                </tr>
                <tr>
                  <td>045</td>
                  <td>2D</td>
                  <td>-</td>
                  <td>077</td>
                  <td>4D</td>
                  <td>M</td>
                  <td>109</td>
                  <td>6D</td>
                  <td>m</td>
                </tr>
                <tr>
                  <td>046</td>
                  <td>2E</td>
                  <td>.</td>
                  <td>078</td>
                  <td>4E</td>
                  <td>N</td>
                  <td>110</td>
                  <td>6E</td>
                  <td>n</td>
                </tr>
                <tr>
                  <td>047</td>
                  <td>2F</td>
                  <td>/</td>
                  <td>079</td>
                  <td>4F</td>
                  <td>O</td>
                  <td>111</td>
                  <td>6F</td>
                  <td>o</td>
                </tr>
                <tr>
                  <td>048</td>
                  <td>30</td>
                  <td>0</td>
                  <td>080</td>
                  <td>50</td>
                  <td>P</td>
                  <td>112</td>
                  <td>70</td>
                  <td>p</td>
                </tr>
                <tr>
                  <td>049</td>
                  <td>31</td>
                  <td>1</td>
                  <td>081</td>
                  <td>51</td>
                  <td>Q</td>
                  <td>113</td>
                  <td>71</td>
                  <td>q</td>
                </tr>
                <tr>
                  <td>050</td>
                  <td>32</td>
                  <td>2</td>
                  <td>082</td>
                  <td>52</td>
                  <td>R</td>
                  <td>114</td>
                  <td>72</td>
                  <td>r</td>
                </tr>
                <tr>
                  <td>051</td>
                  <td>33</td>
                  <td>3</td>
                  <td>083</td>
                  <td>53</td>
                  <td>S</td>
                  <td>115</td>
                  <td>73</td>
                  <td>s</td>
                </tr>
                <tr>
                  <td>052</td>
                  <td>34</td>
                  <td>4</td>
                  <td>084</td>
                  <td>54</td>
                  <td>T</td>
                  <td>116</td>
                  <td>74</td>
                  <td>t</td>
                </tr>
                <tr>
                  <td>053</td>
                  <td>35</td>
                  <td>5</td>
                  <td>085</td>
                  <td>55</td>
                  <td>U</td>
                  <td>117</td>
                  <td>75</td>
                  <td>u</td>
                </tr>
                <tr>
                  <td>054</td>
                  <td>36</td>
                  <td>6</td>
                  <td>086</td>
                  <td>56</td>
                  <td>V</td>
                  <td>118</td>
                  <td>76</td>
                  <td>v</td>
                </tr>
                <tr>
                  <td>055</td>
                  <td>37</td>
                  <td>7</td>
                  <td>087</td>
                  <td>57</td>
                  <td>W</td>
                  <td>119</td>
                  <td>77</td>
                  <td>w</td>
                </tr>
                <tr>
                  <td>056</td>
                  <td>38</td>
                  <td>8</td>
                  <td>088</td>
                  <td>58</td>
                  <td>X</td>
                  <td>120</td>
                  <td>78</td>
                  <td>x</td>
                </tr>
                <tr>
                  <td>057</td>
                  <td>39</td>
                  <td>9</td>
                  <td>089</td>
                  <td>59</td>
                  <td>Y</td>
                  <td>121</td>
                  <td>79</td>
                  <td>y</td>
                </tr>
                <tr>
                  <td>058</td>
                  <td>3A</td>
                  <td>:</td>
                  <td>090</td>
                  <td>5A</td>
                  <td>Z</td>
                  <td>122</td>
                  <td>7A</td>
                  <td>z</td>
                </tr>
                <tr>
                  <td>059</td>
                  <td>3B</td>
                  <td>;</td>
                  <td>091</td>
                  <td>5B</td>
                  <td>[</td>
                  <td>123</td>
                  <td>7B</td>
                  <td>{</td>
                </tr>
                <tr>
                  <td>060</td>
                  <td>3C</td>
                  <td>&lt;</td>
                  <td>092</td>
                  <td>5C</td>
                  <td>\</td>
                  <td>124</td>
                  <td>7C</td>
                  <td>\</td>
                  <td></td>
                </tr>
                <tr>
                  <td>061</td>
                  <td>3D</td>
                  <td>=</td>
                  <td>093</td>
                  <td>5D</td>
                  <td>]</td>
                  <td>125</td>
                  <td>7D</td>
                  <td>}</td>
                </tr>
                <tr>
                  <td>062</td>
                  <td>3E</td>
                  <td>&gt;</td>
                  <td>094</td>
                  <td>5E</td>
                  <td>^</td>
                  <td>126</td>
                  <td>7E</td>
                  <td>~</td>
                </tr>
                <tr>
                  <td>063</td>
                  <td>3F</td>
                  <td>?</td>
                  <td>095</td>
                  <td>5F</td>
                  <td>_</td>
                  <td>127</td>
                  <td>7F</td>
                  <td>DEL</td>
                </tr>
                <tr>
                  <td>064</td>
                  <td>40</td>
                  <td>@</td>
                  <td>096</td>
                  <td>60</td>
                  <td>`</td>
                  <td></td>
                  <td></td>
                  <td></td>
                </tr>
              </tbody>
            </table>

            <h4>Abreviaturas de Caracteres de Control</h4>
            <table>
              <thead>
                <tr>
                  <th>HEX</th>
                  <th>CAR</th>
                  <th>Ingl√©s</th>
                  <th>Espa√±ol</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>00</td>
                  <td>NUL</td>
                  <td>Null</td>
                  <td>Nulo</td>
                </tr>
                <tr>
                  <td>01</td>
                  <td>SOH</td>
                  <td>Start of Heading</td>
                  <td>Principio de Cabecera</td>
                </tr>
                <tr>
                  <td>02</td>
                  <td>STX</td>
                  <td>Start Text</td>
                  <td>Principio de Texto</td>
                </tr>
                <tr>
                  <td>03</td>
                  <td>ETX</td>
                  <td>End Text</td>
                  <td>Fin de texto</td>
                </tr>
                <tr>
                  <td>04</td>
                  <td>EOT</td>
                  <td>End of Transmission</td>
                  <td>Fin de transmisi√≥n</td>
                </tr>
                <tr>
                  <td>05</td>
                  <td>ENQ</td>
                  <td>Enquiry</td>
                  <td>Interrogaci√≥n</td>
                </tr>
                <tr>
                  <td>06</td>
                  <td>ACK</td>
                  <td>Acknowledge</td>
                  <td>Acuse de Recepci√≥n</td>
                </tr>
                <tr>
                  <td>07</td>
                  <td>BEL</td>
                  <td>Bell</td>
                  <td>Pitido</td>
                </tr>
                <tr>
                  <td>08</td>
                  <td>BS</td>
                  <td>Backspace</td>
                  <td>Espacio Atr√°s</td>
                </tr>
                <tr>
                  <td>09</td>
                  <td>HT</td>
                  <td>Horizontal Tab</td>
                  <td>Tabulaci√≥n Horizontal</td>
                </tr>
                <tr>
                  <td>0A</td>
                  <td>LF</td>
                  <td>Line Feed</td>
                  <td>Salto de L√≠nea</td>
                </tr>
                <tr>
                  <td>0B</td>
                  <td>VT</td>
                  <td>Vertical Tab</td>
                  <td>Tabulaci√≥n Vertical</td>
                </tr>
                <tr>
                  <td>0C</td>
                  <td>FF</td>
                  <td>Form Feed</td>
                  <td>Salto de p√°gina</td>
                </tr>
                <tr>
                  <td>0D</td>
                  <td>CR</td>
                  <td>Carriage Return</td>
                  <td>Retorno de Carro (ENTER)</td>
                </tr>
                <tr>
                  <td>0E</td>
                  <td>SO</td>
                  <td>Shift Out</td>
                  <td>Fuera de c√≥digo</td>
                </tr>
                <tr>
                  <td>0F</td>
                  <td>SI</td>
                  <td>Shift In</td>
                  <td>En c√≥digo</td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>DLE</td>
                  <td>Data Link Escape</td>
                  <td>Salida de enlace</td>
                </tr>
                <tr>
                  <td>11</td>
                  <td>DC1</td>
                  <td>Direct Control 1</td>
                  <td>Control Directo 1</td>
                </tr>
                <tr>
                  <td>12</td>
                  <td>DC2</td>
                  <td>Direct Control 2</td>
                  <td>Control Directo 2</td>
                </tr>
                <tr>
                  <td>13</td>
                  <td>DC3</td>
                  <td>Direct Control 3</td>
                  <td>Control Directo 3</td>
                </tr>
                <tr>
                  <td>14</td>
                  <td>DC4</td>
                  <td>Direct Control 4</td>
                  <td>Control Directo 4</td>
                </tr>
                <tr>
                  <td>15</td>
                  <td>NAK</td>
                  <td>Negative Acknowledge</td>
                  <td>Acuse de recepci√≥n Negativa</td>
                </tr>
                <tr>
                  <td>16</td>
                  <td>SYN</td>
                  <td>Synchronous Idle</td>
                  <td>Sincronizaci√≥n Reposo</td>
                </tr>
                <tr>
                  <td>17</td>
                  <td>ETB</td>
                  <td>End Transmission Block</td>
                  <td>Fin Bloque de Transmisi√≥n</td>
                </tr>
                <tr>
                  <td>18</td>
                  <td>CAN</td>
                  <td>Cancel</td>
                  <td>Anular</td>
                </tr>
                <tr>
                  <td>19</td>
                  <td>EM</td>
                  <td>End of Medium</td>
                  <td>Fin de soporte</td>
                </tr>
                <tr>
                  <td>1A</td>
                  <td>SUB</td>
                  <td>Substitute</td>
                  <td>Sustituci√≥n / C√≥digo fin de fichero</td>
                </tr>
                <tr>
                  <td>1B</td>
                  <td>ESC</td>
                  <td>Escape</td>
                  <td>Escape (Salida)</td>
                </tr>
                <tr>
                  <td>1C</td>
                  <td>FS</td>
                  <td>Form Separator</td>
                  <td>Separador de Estado</td>
                </tr>
                <tr>
                  <td>1D</td>
                  <td>GS</td>
                  <td>Group Separator</td>
                  <td>Separador de Grupo</td>
                </tr>
                <tr>
                  <td>1E</td>
                  <td>RS</td>
                  <td>Record Separator</td>
                  <td>Separador de Registros</td>
                </tr>
                <tr>
                  <td>1F</td>
                  <td>US</td>
                  <td>Unit Separator</td>
                  <td>Separador de Sub-Registros</td>
                </tr>
              </tbody>
            </table>

            <p><b>ASCII</b> = American Standard Code for Information Interchange (C√≥digo de Normas Americanas para Intercambios de Informaciones).</p>
            <hr />

            <h3>Los C√≥digos PROLOGUE</h3>

            <p>Los c√≥digos PROLOGUE se forman con los c√≥digos ASCII sin paridad, el bit de rango 7 est√° a cero. El uso del bit de rango 7 permite codificar los caracteres acentuados y otros grafismos.</p>
            <hr />

            <h3>C√≥digos de Respuesta (Errores)</h3>

            <h4>Errores Perif√©ricos (01-15)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>01</td>
                  <td>Unidad No Dispuesta o un time-out de transmisi√≥n en una red SPR</td>
                </tr>
                <tr>
                  <td>02</td>
                  <td>Error lectura/escritura, o de suma de control sobre los datos</td>
                </tr>
                <tr>
                  <td>03</td>
                  <td>Error b√∫squeda pista/sector, o detecci√≥n de TAPE MARK en una banda magn√©tica</td>
                </tr>
                <tr>
                  <td>04</td>
                  <td>Par√°metro incorrecto en un descriptor de E/S: direcci√≥n sector inexistente en este perif√©rico</td>
                </tr>
                <tr>
                  <td>05</td>
                  <td>Protecci√≥n para Escritura. Falta de acoplador de E/S en esta direcci√≥n (o error de inicializaci√≥n del acoplador en una extensi√≥n SPR o V24 por ej.). Error creaci√≥n/activaci√≥n del servidor del encaminamiento en SPR</td>
                </tr>
                <tr>
                  <td>06</td>
                  <td>Error controlador perif√©rico, error disco lectura/escritura (5")</td>
                </tr>
                <tr>
                  <td>07</td>
                  <td>Error de sincronizaci√≥n en el sector direccionado - error del formato del sector (5"), o detecci√≥n del principio de banda magn√©tica</td>
                </tr>
                <tr>
                  <td>08</td>
                  <td>Error posicionamiento de pista en disco (5"), o detecci√≥n fin de banda</td>
                </tr>
                <tr>
                  <td>09</td>
                  <td>Error posicionamiento de pista del acoplador (5"), o operaci√≥n en curso en una banda magn√©tica</td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>Error en el sector de reemplazamiento - status incoherente del acoplador (5"), o registro incompleto sobre una banda magn√©tica</td>
                </tr>
                <tr>
                  <td>11</td>
                  <td>Control de escritura incorrecta - tabla de sectores inv√°lidos incorrecta (5"), o banda magn√©tica no creada en 1.600 BPI</td>
                </tr>
                <tr>
                  <td>12</td>
                  <td>Tabla de sectores inv√°lidos incorrecta</td>
                </tr>
                <tr>
                  <td>13</td>
                  <td>Saturaci√≥n de la tabla de sectores inv√°lidos</td>
                </tr>
                <tr>
                  <td>14</td>
                  <td>Demasiados sectores inv√°lidos en una pista (auto-correcci√≥n de datos (5"))</td>
                </tr>
                <tr>
                  <td>15</td>
                  <td>Formateado del sector destruido</td>
                </tr>
              </tbody>
            </table>

            <h4>Respuestas de SPR (SOR) (16-19)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>16</td>
                  <td>Time-Out en transmisi√≥n, o eco de car√°cter incorrecto</td>
                </tr>
                <tr>
                  <td>17</td>
                  <td>C√≥d. o formato mensaje incorrecto o desbordamiento de zona recepci√≥n. Incoherencia l√≥gica</td>
                </tr>
                <tr>
                  <td>18</td>
                  <td>Petici√≥n no satisfecha por el central</td>
                </tr>
                <tr>
                  <td>19</td>
                  <td>Reservado para desarrollo</td>
                </tr>
              </tbody>
            </table>

            <h4>Monitor de Tiempo Real (MTZ) (20-29)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>20</td>
                  <td>Comando No v√°lido (n√∫mero de tarea igual a cero)</td>
                </tr>
                <tr>
                  <td>21</td>
                  <td>Declaraci√≥n tarea incorrecta</td>
                </tr>
                <tr>
                  <td>22</td>
                  <td>Tarea Ya existente</td>
                </tr>
                <tr>
                  <td>23</td>
                  <td>Tarea Desconocida</td>
                </tr>
                <tr>
                  <td>24</td>
                  <td>N√∫mero de tareas demasiado grande</td>
                </tr>
                <tr>
                  <td>25</td>
                  <td>Tarea Ya activa</td>
                </tr>
                <tr>
                  <td>26</td>
                  <td>Funci√≥n prohibida para un recurso</td>
                </tr>
                <tr>
                  <td>27</td>
                  <td>Alocaci√≥n memoria imposible (no existe un espacio en memoria lo suficientemente grande)</td>
                </tr>
                <tr>
                  <td>28</td>
                  <td>Direcci√≥n p√°rrafo incorrecta en una desalocaci√≥n</td>
                </tr>
                <tr>
                  <td>29</td>
                  <td>Segmento memoria no asignado por la llamada en una desalocaci√≥n</td>
                </tr>
              </tbody>
            </table>

            <h4>Interpretador de Comandos (INTR) (30-38)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>30</td>
                  <td>Sintaxis del comando Incorrecta</td>
                </tr>
                <tr>
                  <td>31</td>
                  <td>N√∫mero de recurso desconocido (mnem√≥nico de soporte desconocido)</td>
                </tr>
                <tr>
                  <td>32</td>
                  <td>Unidad No gestionada por el sistema (n√∫mero de unidad demasiado grande)</td>
                </tr>
                <tr>
                  <td>33</td>
                  <td>Fichero de tipo incorrecto</td>
                </tr>
                <tr>
                  <td>34</td>
                  <td>Sintaxis direcci√≥n de carga incorrecta</td>
                </tr>
                <tr>
                  <td>35</td>
                  <td>Referencia Externa no resuelta en la carga</td>
                </tr>
                <tr>
                  <td>36</td>
                  <td>Registro incorrecto en un fichero objeto (binario -X)</td>
                </tr>
                <tr>
                  <td>38</td>
                  <td>Sobrepasado el l√≠mite de memoria en carga (programa muy grande)</td>
                </tr>
              </tbody>
            </table>

            <h4>N√∫cleo de Gesti√≥n de Ficheros (NGF) (40-59)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>40</td>
                  <td>Fichero inexistente</td>
                </tr>
                <tr>
                  <td>41</td>
                  <td>Fichero existente (Ya creado)</td>
                </tr>
                <tr>
                  <td>42</td>
                  <td>Fichero cerrado (no est√° abierto por este Nlog ni los previos)</td>
                </tr>
                <tr>
                  <td>43</td>
                  <td>Fichero Ya abierto, o soporte (impresora) reservada</td>
                </tr>
                <tr>
                  <td>44</td>
                  <td>Fichero No particionable</td>
                </tr>
                <tr>
                  <td>45</td>
                  <td>Fichero con demasiados bloques de extensi√≥n (Aumentar LGR + REORG)</td>
                </tr>
                <tr>
                  <td>46</td>
                  <td>Desbordamiento de volumen: optimizar los S.I. por SVSI, cambiar el vol.</td>
                </tr>
                <tr>
                  <td>47</td>
                  <td>Claves de acceso lectura/escritura incorrectas</td>
                </tr>
                <tr>
                  <td>48</td>
                  <td>Fin de fichero (NGF - SEQ - SI)</td>
                </tr>
                <tr>
                  <td>49</td>
                  <td>Cat√°logo saturado (Aumentar NBFIC, volviendo a crear el volumen)</td>
                </tr>
                <tr>
                  <td>50</td>
                  <td>N√∫mero l√≥gico muy grande o nulo (=0)</td>
                </tr>
                <tr>
                  <td>51</td>
                  <td>Tabla de n√∫meros l√≥gicos saturada</td>
                </tr>
                <tr>
                  <td>52</td>
                  <td>Fichero cerrado para usted (para la llamada)</td>
                </tr>
                <tr>
                  <td>53</td>
                  <td>Direcci√≥n de sector desconocida. El sector direccionado no pertenece al fichero NGF</td>
                </tr>
                <tr>
                  <td>54</td>
                  <td>Ausencia de cat√°logo (formato volumen incorrecto o volumen no PROLOGUE)</td>
                </tr>
                <tr>
                  <td>55</td>
                  <td>Funci√≥n NGF desconocida</td>
                </tr>
                <tr>
                  <td>56</td>
                  <td>Funci√≥n inexistente para este sistema. Reconfigurar, o extensi√≥n ausente</td>
                </tr>
                <tr>
                  <td>57</td>
                  <td>Soporte no particionable, modificaci√≥n de atributo (atb=) imposible</td>
                </tr>
                <tr>
                  <td>58</td>
                  <td>Funci√≥n prohibida por configuraci√≥n del sistema. Par√°metros generales de PROLOGUE</td>
                </tr>
                <tr>
                  <td>59</td>
                  <td>Incoherencia en la estructura del volumen, o este n√∫mero de gr√°nulos no puede ser gestionado por el NGF</td>
                </tr>
              </tbody>
            </table>

            <h4>Acceso Secuencial SEQ (60-65)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>60</td>
                  <td>Tipo fichero incorrecto, orden SEQ prohibida en este tipo de fichero</td>
                </tr>
                <tr>
                  <td>61</td>
                  <td>La longitud de los registros debe ser diferente de 0, orden CFILE</td>
                </tr>
                <tr>
                  <td>62</td>
                  <td>Longitud de registro incorrecta en escritura, &gt; a la declaraci√≥n</td>
                </tr>
                <tr>
                  <td>63</td>
                  <td>P√©rdida de informaci√≥n en lectura (zona de recepci√≥n muy peque√±a, no se lee m√°s que el principio del registro (o art√≠culo), con la pr√≥xima instrucci√≥n se leer√° el registro (o art√≠culo) siguiente</td>
                </tr>
                <tr>
                  <td>64</td>
                  <td>Principio de fichero (SEQ - SI)</td>
                </tr>
                <tr>
                  <td>65</td>
                  <td>Soporte secuencial: supresi√≥n de fichero en/o escritura imposible, pues no es el √∫ltimo fichero de un soporte secuencial (ej: banda magn√©tica)</td>
                </tr>
              </tbody>
            </table>

            <h4>Acceso Secuencial Indexado SI (70-82)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>70</td>
                  <td>Longitud de clave muy peque√±a (inferior a 2)</td>
                </tr>
                <tr>
                  <td>71</td>
                  <td>Longitud de clave muy grande (superior a 51 en general)</td>
                </tr>
                <tr>
                  <td>72</td>
                  <td>N√∫mero de ficheros (S.I.) abiertos muy grande</td>
                </tr>
                <tr>
                  <td>73</td>
                  <td>Valor del index nulo (en insert= o modif=)</td>
                </tr>
                <tr>
                  <td>74</td>
                  <td>Clave ya bloqueada por otro n√∫mero l√≥gico</td>
                </tr>
                <tr>
                  <td>75</td>
                  <td>Desbordamiento del fichero de claves</td>
                </tr>
                <tr>
                  <td>76</td>
                  <td>Estructura del fichero de claves incoherente, clave siguiente &lt; clave precedente por ej. Fichero No explotable</td>
                </tr>
                <tr>
                  <td>77</td>
                  <td>Desbordamiento del fichero de datos</td>
                </tr>
                <tr>
                  <td>78</td>
                  <td>Clave inexistente</td>
                </tr>
                <tr>
                  <td>79</td>
                  <td>Clave Ya existe pero con un index distinto</td>
                </tr>
                <tr>
                  <td>80</td>
                  <td>Desbordamiento de la estructura del grafo de claves: muchos niveles</td>
                </tr>
                <tr>
                  <td>81</td>
                  <td>Clave Ya existe (en un insert=)</td>
                </tr>
                <tr>
                  <td>82</td>
                  <td>Tama√±o tamp√≥n inferior al tama√±o de la clave, m√°s 1 si el √≠ndice es le√≠do</td>
                </tr>
              </tbody>
            </table>

            <h4>Multi-Criterios M.C. (83-99)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>83</td>
                  <td>C√≥digo de funci√≥n inexistente. N√∫mero l√≥gico incorrecto</td>
                </tr>
                <tr>
                  <td>84</td>
                  <td>Demasiados ficheros abiertos simult√°neamente. Cambiar el n√∫mero de ficheros MC a abrir en SYSC...-S</td>
                </tr>
                <tr>
                  <td>85</td>
                  <td>Incoherencia del diccionario. Error Fatal, volver a crear el diccionario</td>
                </tr>
                <tr>
                  <td>86</td>
                  <td>Demasiadas r√∫bricas (&gt; 255). Demasiados enlaces (&gt; 255). Asegurarse que los enlaces no son involuntariamente redundantes. Demasiados registros en el fichero de datos. El n√∫mero 2**24-1 (o 131.092 a 262.140) se ha alcanzado</td>
                </tr>
                <tr>
                  <td>87</td>
                  <td>Las caracter√≠sticas de la r√∫brica son incorrectas: Longitud de r√∫brica incorrecta, Descripci√≥n de r√∫brica Ya existente, Enlace Ya existente</td>
                </tr>
                <tr>
                  <td>88</td>
                  <td>Descripci√≥n r√∫brica inexistente: Una r√∫brica no-declarada figura en una descripci√≥n de enlace, Una r√∫brica no-declarada figura en una interrogaci√≥n, Una r√∫brica figura varias veces en la misma cuesti√≥n</td>
                </tr>
                <tr>
                  <td>89</td>
                  <td>N√∫mero de criterios incorrecto, Demasiadas r√∫bricas en un enlace, Demasiadas r√∫bricas en una interrogaci√≥n</td>
                </tr>
                <tr>
                  <td>90</td>
                  <td>Descripci√≥n de enlace inexistente, Alg√∫n enlace ya creado no puede responder a la cuesti√≥n, Crear el nuevo enlace, utilizando la opci√≥n (S)</td>
                </tr>
                <tr>
                  <td>91</td>
                  <td>Valor de multi-criterios muy largo, Una r√∫brica, en una interrogaci√≥n, tiene una longitud incorrecta</td>
                </tr>
                <tr>
                  <td>92</td>
                  <td>Incompatibilidad entre el fichero de DATOS y el DICCIONARIO. Las modificaciones se han hecho en el fichero de DATOS, sin pasar por el multi-criterio</td>
                </tr>
                <tr>
                  <td>93</td>
                  <td>Operador desconocido</td>
                </tr>
                <tr>
                  <td>94</td>
                  <td>Tipo del descriptor incorrecto</td>
                </tr>
                <tr>
                  <td>95</td>
                  <td>Reservado para desarrollo</td>
                </tr>
                <tr>
                  <td>96</td>
                  <td>Fin de respuestas en DOWN.. / UP.. despu√©s de POSIT.. o fin de R√∫bricas o enlaces en LKEY= o LLINK=</td>
                </tr>
                <tr>
                  <td>97</td>
                  <td>Expresiones multi-criterios incorrectas, Mal operador, sintaxis incorrecta</td>
                </tr>
                <tr>
                  <td>98</td>
                  <td>R√∫brica no declarada por una orden KEY=. R√∫brica no interrogable puesto que su longitud es muy grande</td>
                </tr>
                <tr>
                  <td>99</td>
                  <td>Tipo del valor incorrecto, Este tipo es diferente del descrito en la orden KEY=</td>
                </tr>
              </tbody>
            </table>

            <h4>Ejecutor BAL EX o EXBL (100-127)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>100</td>
                  <td>Segmento inexistente, o error de traducci√≥n en este segmento</td>
                </tr>
                <tr>
                  <td>101</td>
                  <td>Fin de las DATA en una orden READ=0 en memoria</td>
                </tr>
                <tr>
                  <td>102</td>
                  <td>√çndice a cero en una tabla, o divisi√≥n por cero de un num√©rico corto (# %)</td>
                </tr>
                <tr>
                  <td>103</td>
                  <td>√çndice de una tabla muy grande teniendo en cuenta su declaraci√≥n</td>
                </tr>
                <tr>
                  <td>104</td>
                  <td>Un √≠ndice no puede ser una cadena de caracteres. Cadena usada como num√©rica, o cadena no hexadecimal usada en DEC</td>
                </tr>
                <tr>
                  <td>105</td>
                  <td>RETURN incorrecto en un GOSUB</td>
                </tr>
                <tr>
                  <td>106</td>
                  <td>Desbordamiento de capacidad de una variable num√©rica larga, Nombre de r√∫brica superior a 16 caracteres, Valor de r√∫brica superior a la declaraci√≥n KEY= El contador asociado a COUNT= POSIT[.D]= es muy peque√±o para recibir el n√∫mero de respuestas</td>
                </tr>
                <tr>
                  <td>107</td>
                  <td>Demasiados niveles de GOSUB o LDGO.SEG. (24 niveles como m√°ximo)</td>
                </tr>
                <tr>
                  <td>108</td>
                  <td>Desbordamiento en una operaci√≥n aritm√©tica</td>
                </tr>
                <tr>
                  <td>109</td>
                  <td>Fichero intermediario incorrecto</td>
                </tr>
                <tr>
                  <td>110</td>
                  <td>Variable num√©rica larga incorrecta, operaci√≥n prohibida</td>
                </tr>
                <tr>
                  <td>111</td>
                  <td>N√∫mero err√≥neo (de perif√©rico direccionado por ASK= y PRINT= o de tecla de funci√≥n en KBF)</td>
                </tr>
                <tr>
                  <td>112</td>
                  <td>Error en un formato, Cadena recepci√≥n muy corta con Ch = HEX(..)</td>
                </tr>
                <tr>
                  <td>113</td>
                  <td>Variable muy grande no pudiendo estar contenida en la memoria</td>
                </tr>
                <tr>
                  <td>114</td>
                  <td>Desbordamiento memoria, hacer los segmentos m√°s peque√±os, o simplificar las expresiones de c√°lculo o de relaci√≥n</td>
                </tr>
                <tr>
                  <td>115</td>
                  <td>Orden desconocida para este ejecutor (nivel de EX diferente de TR)</td>
                </tr>
                <tr>
                  <td>116</td>
                  <td>N√∫mero l√≥gico no declarado por una orden ASSIGN=</td>
                </tr>
                <tr>
                  <td>117</td>
                  <td>N√∫mero l√≥gico referenciando un fichero y no un soporte</td>
                </tr>
                <tr>
                  <td>118</td>
                  <td>Variable externa prohibida en este lugar en esta orden</td>
                </tr>
                <tr>
                  <td>119</td>
                  <td>N√∫mero l√≥gico referenciando un soporte y no un fichero ("IM0.")</td>
                </tr>
                <tr>
                  <td>120</td>
                  <td>Fichero o soporte protegido en escritura</td>
                </tr>
                <tr>
                  <td>121</td>
                  <td>El nombre dado es un nombre de soporte y no un nombre de fichero</td>
                </tr>
                <tr>
                  <td>122</td>
                  <td>La zona de recepci√≥n es muy peque√±a para contener el resultado de la orden, o la longitud, o el index en las √≥rdenes de consulta. Error de formato. Incoherencia entre dos descripciones l√≥gicas (ej.ASSIGN y CATALOG)</td>
                </tr>
                <tr>
                  <td>123</td>
                  <td>No hay "ON ERROR" posicionados en el curso de ejecuci√≥n de un RESUME</td>
                </tr>
                <tr>
                  <td>124</td>
                  <td>No ha sobrevenido ning√∫n error en un RESUME</td>
                </tr>
                <tr>
                  <td>125</td>
                  <td>Las √≥rdenes Multi-criterios no se gestionan por este ejecutor</td>
                </tr>
                <tr>
                  <td>126</td>
                  <td>La funci√≥n pedida es incompatible con el m√©todo de acceso utilizado para este fichero</td>
                </tr>
                <tr>
                  <td>127</td>
                  <td>En relativo: tentativa de leer detr√°s del √∫ltimo gr√°nulo asignado</td>
                </tr>
              </tbody>
            </table>

            <h4>Base de Datos BD (170-189)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>170</td>
                  <td>C√≥digo de funci√≥n inexistente</td>
                </tr>
                <tr>
                  <td>171</td>
                  <td>Demasiados ficheros abiertos simult√°neamente</td>
                </tr>
                <tr>
                  <td>172</td>
                  <td>N√∫mero l√≥gico, descriptor o modo de apertura incorrecto. La apertura en EXclusividad puede ser obligatoria</td>
                </tr>
                <tr>
                  <td>173</td>
                  <td>Incoherencia del diccionario</td>
                </tr>
                <tr>
                  <td>174</td>
                  <td>Longitud de claves o datos o tipo de fichero incorrecto</td>
                </tr>
                <tr>
                  <td>175</td>
                  <td>Descripci√≥n de uni√≥n, o N√∫mero de uni√≥n u operador incorrecto. Uni√≥n imposible: en el mismo fichero hay tama√±os y tipos de r√∫bricas diferentes</td>
                </tr>
                <tr>
                  <td>176</td>
                  <td>Descripci√≥n / Nombre de fichero ya existente</td>
                </tr>
                <tr>
                  <td>177</td>
                  <td>Descripci√≥n / Nombre de fichero inexistente</td>
                </tr>
                <tr>
                  <td>178</td>
                  <td>Nombre de r√∫brica ya existe</td>
                </tr>
                <tr>
                  <td>179</td>
                  <td>Nombre de r√∫brica no existe</td>
                </tr>
                <tr>
                  <td>180</td>
                  <td>Descripci√≥n / Nombre de uni√≥n ya existe</td>
                </tr>
                <tr>
                  <td>181</td>
                  <td>Descripci√≥n / Nombre de uni√≥n no existe</td>
                </tr>
                <tr>
                  <td>182</td>
                  <td>Demasiados ficheros en el diccionario, demasiadas r√∫bricas en el diccionario, demasiadas uniones en el diccionario</td>
                </tr>
                <tr>
                  <td>183</td>
                  <td>No hay POSIT antes DOWN / UP</td>
                </tr>
                <tr>
                  <td>184</td>
                  <td>Clave encontrada pero con index falso</td>
                </tr>
                <tr>
                  <td>185</td>
                  <td>No hay respuesta para este fichero</td>
                </tr>
                <tr>
                  <td>186</td>
                  <td>Reservado</td>
                </tr>
                <tr>
                  <td>187</td>
                  <td>Reservado</td>
                </tr>
                <tr>
                  <td>188</td>
                  <td>Reservado</td>
                </tr>
                <tr>
                  <td>189</td>
                  <td>Reservado</td>
                </tr>
              </tbody>
            </table>

            <h4>Gr√°ficos GR (190-196)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>190</td>
                  <td>Descriptor de entorno incorrecto</td>
                </tr>
                <tr>
                  <td>191</td>
                  <td>Tabla de n√∫meros l√≥gicos saturada</td>
                </tr>
                <tr>
                  <td>192</td>
                  <td>Llamada incorrecta o inexistente en esta pantalla (VIEWPORT=)</td>
                </tr>
                <tr>
                  <td>193</td>
                  <td>P√©rdidas de informaci√≥n</td>
                </tr>
                <tr>
                  <td>194</td>
                  <td>"Cierre" no particionable</td>
                </tr>
                <tr>
                  <td>195</td>
                  <td>Modificaci√≥n de "cierre"</td>
                </tr>
                <tr>
                  <td>196</td>
                  <td>Funci√≥n inexistente</td>
                </tr>
              </tbody>
            </table>

            <h4>Otros Errores N.G.F. (200-202)</h4>
            <table>
              <thead>
                <tr>
                  <th>C√≥d.</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>200</td>
                  <td>Funci√≥n volumen rechazada (hay un fichero abierto en este volumen)</td>
                </tr>
                <tr>
                  <td>201</td>
                  <td>Problema interno en el N.G.F.</td>
                </tr>
                <tr>
                  <td>202</td>
                  <td>Incoherencia entre el soporte y su imagen memoria. Acci√≥n: verificar la integridad de los ficheros</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <h3>Palabras Reservadas</h3>

            <p>El uso de estas palabras est√° prohibido como identificadores. Ninguna palabra reservada tiene cifras.</p>
            <pre><code>ABORT       ABS         ARC         ASK         ASSIGN
ATB         ATN
BACKSPAC    BELL

CALL        CATALOG     CFILE       CHAIN       CHR
CIRCLE      CJOIN       CKEY        CLEAR       CLINK
CLOSE       COL         CONF        CONV        COS
COUNT

DATA        DATE        DEC         DEFESG      DELETE
DFILE       DJOIN       DOWN

ELSE        ENDIF       ERROR       ESEG        EXP
EXTEND
FILE        FILLER      FIX         FKEY        FM
FMT         FOR         FP

GENER       GOSUB       GOTO
HEX         HOME

IF          INCLUD      INCLUDE     INDEX       INP
INSERT      INSTR       INT         INV         IO
JOIN
KBF         KEY

LARGE       LEFT        LEN         LET         LFILE
LIN         LINE        LINK        LJOIN       LKEY
LLINK       LOAD        LOG

MASK        MOD         MODIF       MOVE
NEXT        NKEY
OF          ON          OP          OPEN        OUT

PAGE        PAUSE       PEEK        PEN         POINT
POKE        POSIT       PREAD       PRINT       PROCESS

READ        RECORD      REMxxxxx    RENAME      REPEAT
RESTORE     RESUME      RETURN      RIGHT       RJOIN
RKEY        RND         ROUN

SEARCH      SGN         SHL         SHR         SIN
SMALL       SPACE       SQR         STAT        STOP
STRN        SUBSTR

TAB         TABV        TAN         TRAN
UNTIL       UP
VAL         VIEWPORT    VOLUME      VPTR
WAIT        WEND        WHILE       WINDOW      WRITE</code></pre>

            <hr />

            <h3>Tabla de INDEX</h3>

            <h4>S√≠mbolos y Directivas</h4>
            <table>
              <thead>
                <tr>
                  <th>Elemento</th>
                  <th>Referencia</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>#DEF</td>
                  <td>Directiva de compilaci√≥n condicional</td>
                </tr>
                <tr>
                  <td>#ELSE</td>
                  <td>Directiva de compilaci√≥n condicional</td>
                </tr>
                <tr>
                  <td>#ENDIF</td>
                  <td>Directiva de compilaci√≥n condicional</td>
                </tr>
                <tr>
                  <td>#IFDEF</td>
                  <td>Directiva de compilaci√≥n condicional</td>
                </tr>
                <tr>
                  <td>#RDEF</td>
                  <td>Directiva de compilaci√≥n condicional</td>
                </tr>
                <tr>
                  <td>#UNDEF</td>
                  <td>Directiva de compilaci√≥n condicional</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>Comentario / Multiplicaci√≥n</td>
                </tr>
                <tr>
                  <td>.</td>
                  <td>Separador</td>
                </tr>
                <tr>
                  <td>;</td>
                  <td>Comentario en l√≠nea</td>
                </tr>
                <tr>
                  <td>/</td>
                  <td>Divisi√≥n</td>
                </tr>
                <tr>
                  <td>&lt;</td>
                  <td>Menor que</td>
                </tr>
                <tr>
                  <td>&gt;</td>
                  <td>Mayor que</td>
                </tr>
              </tbody>
            </table>

            <h4>A</h4>
            <table>
              <thead>
                <tr>
                  <th>Elemento</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>ABORT</td>
                  <td>Terminaci√≥n anormal del programa</td>
                </tr>
                <tr>
                  <td>ABS</td>
                  <td>Valor absoluto</td>
                </tr>
                <tr>
                  <td>afectaci√≥n</td>
                  <td>Asignaci√≥n de valores</td>
                </tr>
                <tr>
                  <td>AND</td>
                  <td>Operador l√≥gico Y</td>
                </tr>
                <tr>
                  <td>ARG</td>
                  <td>Argumentos</td>
                </tr>
                <tr>
                  <td>ASK=</td>
                  <td>Entrada de datos con formato</td>
                </tr>
                <tr>
                  <td>ASSIGN=</td>
                  <td>Asignaci√≥n de ficheros/soportes</td>
                </tr>
                <tr>
                  <td>ATB</td>
                  <td>Atributos de pantalla</td>
                </tr>
                <tr>
                  <td>ATB=</td>
                  <td>Modificaci√≥n de atributos</td>
                </tr>
                <tr>
                  <td>ATN</td>
                  <td>Arcotangente</td>
                </tr>
                <tr>
                  <td>atributos</td>
                  <td>Caracter√≠sticas de visualizaci√≥n</td>
                </tr>
              </tbody>
            </table>

            <h4>B-C</h4>
            <table>
              <thead>
                <tr>
                  <th>Elemento</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>BACKSPACE=</td>
                  <td>Retroceso en fichero</td>
                </tr>
                <tr>
                  <td>BELL</td>
                  <td>Emitir pitido</td>
                </tr>
                <tr>
                  <td>bucles</td>
                  <td>Estructuras de repetici√≥n</td>
                </tr>
                <tr>
                  <td>CALL</td>
                  <td>Llamada a subprograma</td>
                </tr>
                <tr>
                  <td>CATALOG=</td>
                  <td>Acceso al cat√°logo</td>
                </tr>
                <tr>
                  <td>cat√°logo</td>
                  <td>Directorio de ficheros</td>
                </tr>
                <tr>
                  <td>CFILE=</td>
                  <td>Creaci√≥n de fichero</td>
                </tr>
                <tr>
                  <td>CHAIN=</td>
                  <td>Encadenamiento de programas</td>
                </tr>
                <tr>
                  <td>carga</td>
                  <td>Carga de programa en memoria</td>
                </tr>
                <tr>
                  <td>CHR$</td>
                  <td>Car√°cter desde c√≥digo ASCII</td>
                </tr>
                <tr>
                  <td>CKEY=</td>
                  <td>Creaci√≥n de claves M.C.</td>
                </tr>
                <tr>
                  <td>clave</td>
                  <td>Identificador de registro</td>
                </tr>
                <tr>
                  <td>CLEAR</td>
                  <td>Borrar pantalla</td>
                </tr>
                <tr>
                  <td>CLINK=</td>
                  <td>Creaci√≥n de enlaces M.C.</td>
                </tr>
                <tr>
                  <td>CLOSE=</td>
                  <td>Cierre de fichero</td>
                </tr>
                <tr>
                  <td>CLOSE=0</td>
                  <td>Cierre de todos los ficheros</td>
                </tr>
                <tr>
                  <td>CLR</td>
                  <td>Comando de limpieza</td>
                </tr>
                <tr>
                  <td>c√≥d.formato</td>
                  <td>C√≥digos de formato</td>
                </tr>
                <tr>
                  <td>COL</td>
                  <td>Columna actual</td>
                </tr>
                <tr>
                  <td>comando</td>
                  <td>Instrucci√≥n del sistema</td>
                </tr>
                <tr>
                  <td>CONF</td>
                  <td>Configuraci√≥n del sistema</td>
                </tr>
                <tr>
                  <td>CONST</td>
                  <td>Constante</td>
                </tr>
                <tr>
                  <td>constante</td>
                  <td>Valor fijo</td>
                </tr>
                <tr>
                  <td>CONV</td>
                  <td>Conversi√≥n a cadena</td>
                </tr>
                <tr>
                  <td>COS</td>
                  <td>Coseno</td>
                </tr>
                <tr>
                  <td>COUNT=</td>
                  <td>Contar respuestas M.C.</td>
                </tr>
              </tbody>
            </table>

            <h4>D-G</h4>
            <table>
              <thead>
                <tr>
                  <th>Elemento</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>DATA</td>
                  <td>Datos en l√≠nea</td>
                </tr>
                <tr>
                  <td>DATE</td>
                  <td>Fecha del sistema</td>
                </tr>
                <tr>
                  <td>dbug</td>
                  <td>Depurador</td>
                </tr>
                <tr>
                  <td>DB</td>
                  <td>Debug</td>
                </tr>
                <tr>
                  <td>DCL</td>
                  <td>Declaraci√≥n de variables</td>
                </tr>
                <tr>
                  <td>DEC</td>
                  <td>Conversi√≥n hexadecimal a decimal</td>
                </tr>
                <tr>
                  <td>declaraci√≥n</td>
                  <td>Definici√≥n de variables</td>
                </tr>
                <tr>
                  <td>DEFSEG</td>
                  <td>Definir segmento</td>
                </tr>
                <tr>
                  <td>DELETE=</td>
                  <td>Suprimir registro</td>
                </tr>
                <tr>
                  <td>DFILE=</td>
                  <td>Destruir fichero</td>
                </tr>
                <tr>
                  <td>dimensi√≥n</td>
                  <td>Tama√±o de arrays</td>
                </tr>
                <tr>
                  <td>DOWN=</td>
                  <td>Leer siguiente registro</td>
                </tr>
                <tr>
                  <td>DOWN.L=</td>
                  <td>Leer siguiente con longitud</td>
                </tr>
                <tr>
                  <td>DOWN.M=</td>
                  <td>Leer siguiente con bloqueo</td>
                </tr>
                <tr>
                  <td>DOWN.ML=</td>
                  <td>Leer siguiente con bloqueo y longitud</td>
                </tr>
                <tr>
                  <td>ELSE</td>
                  <td>Alternativa en IF</td>
                </tr>
                <tr>
                  <td>END</td>
                  <td>Fin de programa</td>
                </tr>
                <tr>
                  <td>ENDIF</td>
                  <td>Fin de bloque IF</td>
                </tr>
                <tr>
                  <td>ERROR</td>
                  <td>Variable de error</td>
                </tr>
                <tr>
                  <td>ESEG</td>
                  <td>Fin de segmento</td>
                </tr>
                <tr>
                  <td>EXP</td>
                  <td>Exponencial</td>
                </tr>
                <tr>
                  <td>expresiones</td>
                  <td>C√°lculos y operaciones</td>
                </tr>
                <tr>
                  <td>EXTEND=</td>
                  <td>Extender fichero</td>
                </tr>
                <tr>
                  <td>FIELD=</td>
                  <td>Definir campos</td>
                </tr>
                <tr>
                  <td>FILLER=</td>
                  <td>Relleno</td>
                </tr>
                <tr>
                  <td>FIX</td>
                  <td>Fijar decimales</td>
                </tr>
                <tr>
                  <td>FKEY=</td>
                  <td>Teclas de funci√≥n M.C.</td>
                </tr>
                <tr>
                  <td>FM</td>
                  <td>Formato</td>
                </tr>
                <tr>
                  <td>FMT</td>
                  <td>Formato</td>
                </tr>
                <tr>
                  <td>FOR</td>
                  <td>Inicio de bucle</td>
                </tr>
                <tr>
                  <td>formatos</td>
                  <td>Especificaciones de E/S</td>
                </tr>
                <tr>
                  <td>FP</td>
                  <td>Parte decimal</td>
                </tr>
                <tr>
                  <td>GENER</td>
                  <td>Generar cadena</td>
                </tr>
                <tr>
                  <td>GOSUB</td>
                  <td>Llamada a subrutina</td>
                </tr>
                <tr>
                  <td>GOTO</td>
                  <td>Salto incondicional</td>
                </tr>
              </tbody>
            </table>

            <h4>H-O</h4>
            <table>
              <thead>
                <tr>
                  <th>Elemento</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>HEX</td>
                  <td>Conversi√≥n a hexadecimal</td>
                </tr>
                <tr>
                  <td>HOME</td>
                  <td>Inicio de pantalla</td>
                </tr>
                <tr>
                  <td>identificador</td>
                  <td>Nombre de variable</td>
                </tr>
                <tr>
                  <td>IF</td>
                  <td>Condicional</td>
                </tr>
                <tr>
                  <td>INCLUD</td>
                  <td>Incluir cadena</td>
                </tr>
                <tr>
                  <td>INCLUDE</td>
                  <td>Incluir fichero fuente</td>
                </tr>
                <tr>
                  <td>√≠ndice</td>
                  <td>Posici√≥n en array</td>
                </tr>
                <tr>
                  <td>INDEX</td>
                  <td>√çndice de registro</td>
                </tr>
                <tr>
                  <td>INP</td>
                  <td>Entrada de puerto</td>
                </tr>
                <tr>
                  <td>INSERT=</td>
                  <td>Insertar registro</td>
                </tr>
                <tr>
                  <td>INSTR</td>
                  <td>Buscar subcadena</td>
                </tr>
                <tr>
                  <td>INT</td>
                  <td>Parte entera</td>
                </tr>
                <tr>
                  <td>INV</td>
                  <td>Invertir cadena</td>
                </tr>
                <tr>
                  <td>IO=</td>
                  <td>Entrada/Salida directa</td>
                </tr>
                <tr>
                  <td>KBF</td>
                  <td>Tecla de funci√≥n</td>
                </tr>
                <tr>
                  <td>KEY=</td>
                  <td>Declarar r√∫brica M.C.</td>
                </tr>
                <tr>
                  <td>LARGE</td>
                  <td>Convertir a may√∫sculas</td>
                </tr>
                <tr>
                  <td>LDGO.SEG</td>
                  <td>Cargar y ejecutar segmento</td>
                </tr>
                <tr>
                  <td>LEFT</td>
                  <td>Subcadena izquierda</td>
                </tr>
                <tr>
                  <td>LEN</td>
                  <td>Longitud declarada</td>
                </tr>
                <tr>
                  <td>LEN$</td>
                  <td>Longitud real</td>
                </tr>
                <tr>
                  <td>LET</td>
                  <td>Asignaci√≥n (opcional)</td>
                </tr>
                <tr>
                  <td>LIN</td>
                  <td>L√≠nea actual</td>
                </tr>
                <tr>
                  <td>LINK=</td>
                  <td>Declarar enlace M.C.</td>
                </tr>
                <tr>
                  <td>LKEY=</td>
                  <td>Listar r√∫bricas M.C.</td>
                </tr>
                <tr>
                  <td>LLINK=</td>
                  <td>Listar enlaces M.C.</td>
                </tr>
                <tr>
                  <td>LOAD=</td>
                  <td>Cargar m√≥dulo</td>
                </tr>
                <tr>
                  <td>LOAD.GO=</td>
                  <td>Cargar y ejecutar</td>
                </tr>
                <tr>
                  <td>LOG</td>
                  <td>Logaritmo natural</td>
                </tr>
                <tr>
                  <td>MASK</td>
                  <td>M√°scara de entrada</td>
                </tr>
                <tr>
                  <td>m√©todos de acceso</td>
                  <td>NGF, SEQ, SI, MC</td>
                </tr>
                <tr>
                  <td>MOD</td>
                  <td>M√≥dulo (resto)</td>
                </tr>
                <tr>
                  <td>MODIF=</td>
                  <td>Modificar registro</td>
                </tr>
                <tr>
                  <td>MOVE</td>
                  <td>Mover datos</td>
                </tr>
                <tr>
                  <td>MSIZE</td>
                  <td>Tama√±o de memoria</td>
                </tr>
                <tr>
                  <td>NEXT</td>
                  <td>Fin de bucle FOR</td>
                </tr>
                <tr>
                  <td>NKEY=</td>
                  <td>Nueva clave</td>
                </tr>
                <tr>
                  <td>NOCLR</td>
                  <td>No limpiar</td>
                </tr>
                <tr>
                  <td>NOLIST</td>
                  <td>No listar</td>
                </tr>
                <tr>
                  <td>OF</td>
                  <td>Selector m√∫ltiple</td>
                </tr>
                <tr>
                  <td>ON ERROR</td>
                  <td>Tratamiento de errores</td>
                </tr>
                <tr>
                  <td>ON</td>
                  <td>Salto indexado</td>
                </tr>
                <tr>
                  <td>OP</td>
                  <td>Interrupci√≥n operador</td>
                </tr>
                <tr>
                  <td>OPEN=</td>
                  <td>Abrir fichero</td>
                </tr>
                <tr>
                  <td>operadores</td>
                  <td>S√≠mbolos de operaci√≥n</td>
                </tr>
                <tr>
                  <td>OR</td>
                  <td>Operador l√≥gico O</td>
                </tr>
                <tr>
                  <td>OUT</td>
                  <td>Salida a puerto</td>
                </tr>
                <tr>
                  <td>OX</td>
                  <td>Or exclusivo</td>
                </tr>
              </tbody>
            </table>

            <h4>P-Z</h4>
            <table>
              <thead>
                <tr>
                  <th>Elemento</th>
                  <th>Descripci√≥n</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>PAINT</td>
                  <td>Rellenar √°rea</td>
                </tr>
                <tr>
                  <td>PAGE</td>
                  <td>Salto de p√°gina</td>
                </tr>
                <tr>
                  <td>PAUSE</td>
                  <td>Pausa con mensaje</td>
                </tr>
                <tr>
                  <td>PEEK</td>
                  <td>Leer memoria</td>
                </tr>
                <tr>
                  <td>POKE</td>
                  <td>Escribir en memoria</td>
                </tr>
                <tr>
                  <td>POSIT=</td>
                  <td>Posicionar en respuestas M.C.</td>
                </tr>
                <tr>
                  <td>POSIT.D=</td>
                  <td>Posicionar descendente M.C.</td>
                </tr>
                <tr>
                  <td>PRINT</td>
                  <td>Imprimir cadena</td>
                </tr>
                <tr>
                  <td>PRINT=</td>
                  <td>Salida formateada</td>
                </tr>
                <tr>
                  <td>PROCESS</td>
                  <td>Control de procesos</td>
                </tr>
                <tr>
                  <td>PROGRAM</td>
                  <td>Cabecera de programa</td>
                </tr>
                <tr>
                  <td>cuesti√≥n M.C.</td>
                  <td>Interrogaci√≥n multicriterio</td>
                </tr>
                <tr>
                  <td>READ=</td>
                  <td>Leer de fichero</td>
                </tr>
                <tr>
                  <td>REM</td>
                  <td>Comentario</td>
                </tr>
                <tr>
                  <td>RENAME=</td>
                  <td>Renombrar fichero</td>
                </tr>
                <tr>
                  <td>REPEAT</td>
                  <td>Inicio bucle REPEAT</td>
                </tr>
                <tr>
                  <td>RESTORE</td>
                  <td>Restaurar DATA</td>
                </tr>
                <tr>
                  <td>RESUME</td>
                  <td>Continuar tras error</td>
                </tr>
                <tr>
                  <td>RET.SEG</td>
                  <td>Retorno de segmento</td>
                </tr>
                <tr>
                  <td>RETURN</td>
                  <td>Retorno de subrutina</td>
                </tr>
                <tr>
                  <td>RIGHT</td>
                  <td>Subcadena derecha</td>
                </tr>
                <tr>
                  <td>RKEY=</td>
                  <td>R√∫brica clave</td>
                </tr>
                <tr>
                  <td>RND</td>
                  <td>N√∫mero aleatorio</td>
                </tr>
                <tr>
                  <td>ROUN</td>
                  <td>Redondear</td>
                </tr>
                <tr>
                  <td>rupturas de secuencia</td>
                  <td>Saltos en el programa</td>
                </tr>
                <tr>
                  <td>SEARCH=</td>
                  <td>Buscar registro</td>
                </tr>
                <tr>
                  <td>SEARCH.L=</td>
                  <td>Buscar con longitud</td>
                </tr>
                <tr>
                  <td>SEARCH.M=</td>
                  <td>Buscar con bloqueo</td>
                </tr>
                <tr>
                  <td>SEARCH.ML=</td>
                  <td>Buscar con bloqueo y longitud</td>
                </tr>
                <tr>
                  <td>SEGMENT</td>
                  <td>Inicio de segmento</td>
                </tr>
                <tr>
                  <td>SGN</td>
                  <td>Signo</td>
                </tr>
                <tr>
                  <td>SHL</td>
                  <td>Desplazamiento izquierda</td>
                </tr>
                <tr>
                  <td>SHR</td>
                  <td>Desplazamiento derecha</td>
                </tr>
                <tr>
                  <td>SIN</td>
                  <td>Seno</td>
                </tr>
                <tr>
                  <td>SMALL</td>
                  <td>Convertir a min√∫sculas</td>
                </tr>
                <tr>
                  <td>sub-programas</td>
                  <td>Rutinas reutilizables</td>
                </tr>
                <tr>
                  <td>SPACE</td>
                  <td>Generar espacios</td>
                </tr>
                <tr>
                  <td>SQR</td>
                  <td>Ra√≠z cuadrada</td>
                </tr>
                <tr>
                  <td>STAT=</td>
                  <td>Estad√≠sticas M.C.</td>
                </tr>
                <tr>
                  <td>STOP</td>
                  <td>Detener programa</td>
                </tr>
                <tr>
                  <td>STRN</td>
                  <td>Conversi√≥n num√©rica a cadena</td>
                </tr>
                <tr>
                  <td>SUBSTR</td>
                  <td>Subcadena</td>
                </tr>
                <tr>
                  <td>estructura</td>
                  <td>Organizaci√≥n del programa</td>
                </tr>
                <tr>
                  <td>TAB</td>
                  <td>Tabulaci√≥n horizontal</td>
                </tr>
                <tr>
                  <td>tab-lista</td>
                  <td>Lista de tabulaciones</td>
                </tr>
                <tr>
                  <td>tabulaci√≥n</td>
                  <td>Posicionamiento</td>
                </tr>
                <tr>
                  <td>TABV</td>
                  <td>Tabulaci√≥n vertical</td>
                </tr>
                <tr>
                  <td>TAN</td>
                  <td>Tangente</td>
                </tr>
                <tr>
                  <td>TRAN</td>
                  <td>Traducir caracteres</td>
                </tr>
                <tr>
                  <td>UNTIL</td>
                  <td>Fin bucle REPEAT</td>
                </tr>
                <tr>
                  <td>UP=</td>
                  <td>Leer registro anterior</td>
                </tr>
                <tr>
                  <td>UP.L=</td>
                  <td>Leer anterior con longitud</td>
                </tr>
                <tr>
                  <td>UP.M=</td>
                  <td>Leer anterior con bloqueo</td>
                </tr>
                <tr>
                  <td>UP.ML=</td>
                  <td>Leer anterior con bloqueo y longitud</td>
                </tr>
                <tr>
                  <td>VAL</td>
                  <td>Valor num√©rico de cadena</td>
                </tr>
                <tr>
                  <td>variable</td>
                  <td>Almacenamiento de datos</td>
                </tr>
                <tr>
                  <td>virtual</td>
                  <td>Variable en disco</td>
                </tr>
                <tr>
                  <td>VOLUME=</td>
                  <td>Acceso a volumen</td>
                </tr>
                <tr>
                  <td>VPTR</td>
                  <td>Puntero virtual</td>
                </tr>
                <tr>
                  <td>WAIT</td>
                  <td>Esperar segundos</td>
                </tr>
                <tr>
                  <td>WEND</td>
                  <td>Fin bucle WHILE</td>
                </tr>
                <tr>
                  <td>WHILE</td>
                  <td>Inicio bucle WHILE</td>
                </tr>
                <tr>
                  <td>WRITE=</td>
                  <td>Escribir en fichero</td>
                </tr>
              </tbody>
            </table>

            <hr />

            <p><i>Manual de Referencia BAL - Edici√≥n Junio 1987 - Versi√≥n 2.1</i></p>
            <hr />

            <!-- ==================== FIN DEL DOCUMENTO ==================== -->            
            <p><i>Documento digitalizado y convertido a formato HTML.</i></p>
            
          </article>
        </div>
      </section>

      <!-- SIDEBAR -->
      <aside class="sidebar-sticky no-print">
        <div class="card">
          <h2>üìã Copiar para LibreOffice</h2>
          <div style="font-size: 0.875rem; color: #4b5563; margin-top: 0.5rem;">
            <ol style="padding-left: 1.25rem; margin: 0; line-height: 1.5;">
              <li>Click en <b>"Copiar formato enriquecido"</b>.</li>
              <li>Abre LibreOffice Writer.</li>
              <li>Pega con <b>Ctrl+V</b>.</li>
            </ol>
            <div style="margin-top: 0.75rem; background: #fffbeb; border: 1px solid #fcd34d; padding: 0.5rem; border-radius: 0.375rem; color: #92400e; font-size: 0.75rem;">
              <b>Tip:</b> Si falla, usa <b>Edici√≥n ‚Üí Pegado especial ‚Üí HTML</b>.
            </div>
          </div>
        </div>

        <div class="card">
          <h3>Acciones</h3>
          <div class="action-list">
            <button id="selectAll" class="btn btn-secondary">Seleccionar todo</button>
            <button id="togglePlaceholders" class="btn btn-secondary">Ocultar/Mostrar marcadores</button>
            <button id="toggleBorders" class="btn btn-secondary">Alternar vista "Papel"</button>
          </div>
        </div>
        <div id="toast" class="toast-success"></div>
      </aside>

    </div>
  </main>

  <!-- JAVASCRIPT -->
  <script>
    const doc = document.getElementById('doc');
    const toast = document.getElementById('toast');

    function showToast(msg, isError = false) {
      toast.textContent = msg;
      toast.className = isError ? 'toast-error' : 'toast-success';
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove('show'), 4000);
    }

    function selectNodeContents(node) {
      const range = document.createRange();
      range.selectNodeContents(node);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }

    // Generar HTML optimizado para portapapeles
    function generateStyledHTML() {
      const clone = doc.cloneNode(true);
      clone.querySelectorAll('.chapter-placeholder').forEach(el => el.remove());
      
      const styles = `
        <style>
          body { 
            font-family: "Times New Roman", Times, serif; 
            font-size: 12pt; 
            color: #000000; 
            line-height: 1.5; 
          }
          h1, h2, h3, h4 { font-family: "Times New Roman", Times, serif; color: #000000; }
          h1 { font-size: 24pt; font-weight: bold; margin-bottom: 12pt; }
          h2 { font-size: 18pt; font-weight: bold; margin-top: 24pt; margin-bottom: 12pt; border-bottom: 2px solid #CCCCCC; padding-bottom: 4pt; page-break-before: always; }
          h3 { font-size: 14pt; font-weight: bold; margin-top: 18pt; margin-bottom: 8pt; }
          p { margin-bottom: 10pt; text-align: justify; }
          
          /* C√≥digo: Fondo gris claro, borde, color texto oscuro (sin rojo) */
          code { font-family: "Courier New", monospace; background: #f5f7f9; padding: 2px 4px; border: 1px solid #CCCCCC; font-size: 10.5pt; color: #374151; }
          pre { font-family: "Courier New", monospace; background: #f6f8fa; padding: 10pt; border: 1px solid #CCCCCC; margin-bottom: 14pt; white-space: pre-wrap; color: #000000; }
          
          table { width: 100%; border-collapse: collapse; margin-bottom: 14pt; }
          td, th { border: 1px solid #000000; padding: 6pt 10pt; vertical-align: top; }
          th { background: #F0F0F0; font-weight: bold; text-align: left; }
          blockquote { border-left: 4px solid #0056b3; padding-left: 10pt; margin-left: 0; color: #444; font-style: italic; background: #f8fbff; }
        </style>
      `;
      return `<!DOCTYPE html><html lang="es"><head><meta charset="utf-8">${styles}</head><body>${clone.innerHTML}</body></html>`;
    }

    async function copyForLibreOffice() {
      try {
        const html = generateStyledHTML();
        const text = doc.innerText;

        if (navigator.clipboard && window.ClipboardItem) {
          const item = new ClipboardItem({
            'text/html': new Blob([html], { type: 'text/html' }),
            'text/plain': new Blob([text], { type: 'text/plain' })
          });
          await navigator.clipboard.write([item]);
          showToast('‚úÖ ¬°Copiado! Pega en LibreOffice con Ctrl+V');
        } else {
          throw new Error('API Clipboard incompleta');
        }
      } catch (err) {
        selectNodeContents(doc);
        showToast('‚ö†Ô∏è Selecci√≥n manual. Pulsa Ctrl+C.', true);
      }
    }

    async function copyPlainText() {
      try {
        await navigator.clipboard.writeText(doc.innerText);
        showToast('‚úÖ Texto copiado (sin formato)');
      } catch (err) {
        selectNodeContents(doc);
        showToast('üìã Seleccionado. Usa Ctrl+C.', true);
      }
    }

    document.getElementById('copyLibreOffice').addEventListener('click', copyForLibreOffice);
    document.getElementById('copyPlain').addEventListener('click', copyPlainText);
    document.getElementById('print').addEventListener('click', () => window.print());
    document.getElementById('selectAll').addEventListener('click', () => { selectNodeContents(doc); showToast('üìã Todo seleccionado'); });
    document.getElementById('togglePlaceholders').addEventListener('click', () => {
      const placeholders = document.querySelectorAll('.chapter-placeholder');
      const isHidden = placeholders[0]?.style.display === 'none';
      placeholders.forEach(el => el.style.display = isHidden ? 'block' : 'none');
      showToast(isHidden ? 'Marcadores visibles' : 'Marcadores ocultos');
    });
    document.getElementById('toggleBorders').addEventListener('click', () => {
      const page = document.querySelector('.page');
      const hasShadow = page.style.boxShadow !== 'none';
      page.style.boxShadow = hasShadow ? 'none' : '0 10px 40px rgba(0,0,0,0.1)';
      page.style.border = hasShadow ? 'none' : '1px solid #e5e7eb';
      showToast('Vista actualizada');
    });
  </script>
</body>
</html>
